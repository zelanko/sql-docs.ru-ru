---
title: Создание синхронного преобразования с помощью компонента скрипта | Документы Майкрософт
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: reference
dev_langs:
- VB
helpviewer_keywords:
- synchronous outputs [Integration Services]
- transformation components [Integration Services]
- Script component [Integration Services], transformation components
ms.assetid: aa1bee1a-ab06-44d8-9944-4bff03d73016
author: janinezhang
ms.author: janinez
manager: craigg
ms.openlocfilehash: 7e2fc735cd4834fcb6e59550604b831b5d8790fb
ms.sourcegitcommit: 5a8678bf85f65be590676745a7fe4fcbcc47e83d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2019
ms.locfileid: "58379982"
---
# <a name="creating-a-synchronous-transformation-with-the-script-component"></a>Создание синхронного преобразования с помощью компонента скрипта
  Компонент преобразования используется в потоке данных пакета служб [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] для изменения и анализа данных, передаваемых из источника в назначение. Преобразование с синхронными выходами обрабатывает каждую входную строку, проходящую через компонент. Преобразование с асинхронными выходами ожидает, пока не получит все входные строки, чтобы завершить обработку. В этом разделе рассматривается синхронное преобразование. Сведения об асинхронных преобразованиях см. в разделе [Создание асинхронного преобразования с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md). Дополнительные сведения о различиях между синхронными и асинхронными компонентами см. в разделе [Основные сведения о синхронных и асинхронных преобразованиях](../understanding-synchronous-and-asynchronous-transformations.md).  
  
 Общие сведения о компоненте скрипта см. в разделе [Расширение потока данных с помощью компонента скрипта](../extending-packages-scripting/data-flow-script-component/extending-the-data-flow-with-the-script-component.md).  
  
 Компонент скрипта и формируемый им код инфраструктуры значительно упрощают процесс создания пользовательских компонентов потока данных. Однако, чтобы понять, как работает компонент скрипта, может быть полезно ознакомиться с шагами по разработке пользовательских компонентов потока данных, описанными в разделе [Разработка пользовательского компонента потока данных](../extending-packages-custom-objects/data-flow/developing-a-custom-data-flow-component.md) и в особенности в разделе [Разработка пользовательского компонента преобразования с синхронными выходами](../extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md).  
  
## <a name="getting-started-with-a-synchronous-transformation-component"></a>Приступая к работе над компонентом синхронного преобразования  
 При добавлении компонента скриптов на панель "Поток данных" конструктора служб [!INCLUDE[ssIS](../../includes/ssis-md.md)] открывается диалоговое окно **Выбор типа компонента скрипта**, где нужно выбрать тип компонента — источник, назначение или преобразование. В этом диалоговом окне выберите пункт **Преобразование**.  
  
## <a name="configuring-a-synchronous-transformation-component-in-metadata-design-mode"></a>Настройка компонента синхронного преобразования в режиме конструктора метаданных  
 После выбора варианта для создания компонента преобразования выполняется настройка компонента с помощью **редактора преобразования "Скрипт"**. Дополнительные сведения см. в разделе [Настройка компонента скрипта в редакторе компонента скрипта](../extending-packages-scripting/data-flow-script-component/configuring-the-script-component-in-the-script-component-editor.md).  
  
 Чтобы определить язык скрипта для компонента скрипта, необходимо задать свойство **ScriptLanguage** на странице **Скрипт** в **редакторе преобразования "Скрипт"**.  
  
> [!NOTE]  
>  Чтобы установить язык скрипта по умолчанию для компонента скрипта, воспользуйтесь параметром **Язык сценариев** на странице **Общие** диалогового окна **Параметры**. Дополнительные сведения см. в разделе [General Page](../general-page-of-integration-services-designers-options.md).  
  
 Компонент преобразования потока данных имеет один вход и поддерживает один или несколько выходов. Настройка входа и выходов компонента является одним из шагов, которые необходимо выполнить в режиме конструктора метаданных с использованием **редактора преобразования "Скрипт"**, прежде чем приступать к написанию пользовательского скрипта.  
  
### <a name="configuring-input-columns"></a>Настройка входных столбцов  
 Компонент преобразования имеет один вход.  
  
 На странице **Входные столбцы** в **редакторе преобразования "Скрипт"** список столбцов содержит доступные столбцы на выходе вышестоящего компонента в потоке данных. Выделите столбцы, которые хотите преобразовать или передать. Пометьте все столбцы, участвующие в преобразовании, как доступные для чтения и записи.  
  
 Дополнительные сведения о странице **Входные столбцы** **редактора преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Входные столбцы")](../script-transformation-editor-input-columns-page.md).  
  
### <a name="configuring-inputs-outputs-and-output-columns"></a>Настройка входов, выходов и выходных столбцов  
 Компонент преобразования поддерживает один или несколько выходов.  
  
 На странице **Входы и выходы** в **редакторе преобразования "Скрипт"** можно убедиться в том, что создан один выход, который не имеет столбцов. На этой странице редактора может понадобиться настроить следующие элементы.  
  
-   Создайте один или несколько дополнительных выходов, например, имитацию вывода ошибок для строк, содержащих непредвиденные значения. Используйте кнопки **Добавить выход** и **Удалить выход** для управления выходами компонента синхронного преобразования. Все входные строки направляются во все доступные выходы, если не указано, что необходимо перенаправлять каждую строку в тот или иной определенный выход. Чтобы указать на необходимость перенаправления строк, следует присвоить свойству `ExclusionGroup` для выходов ненулевое целочисленное значение. Конкретное целочисленное значение, заданное для свойства `ExclusionGroup`, не имеет принципиальной важности, однако необходимо использовать одно и то же число последовательно в указанной группе выходов.  
  
    > [!NOTE]  
    >  Также можно использовать ненулевое значение для свойства `ExclusionGroup` с единственным выходом, если не нужно выводить все строки. Однако в этом случае необходимо явно вызывать метод **DirectRowTo\<выходной_буфер>** для каждой строки, которую следует отправить на выход.  
  
-   Присвойте как можно более описательные имена входу и выходам. Компонент скрипта использует эти имена для создания типизированных свойств метода доступа, с помощью которых в скрипте выполняется обращение к входам и выходам.  
  
-   Для синхронных преобразований оставьте столбцы без изменения. Обычно синхронное преобразование не добавляет столбцы в поток данных. Данные изменяются на месте, прямо в буфере, который передается в следующий компонент потока данных. В подобной ситуации нет необходимости добавлять и настраивать выходные столбцы явным образом для выходов преобразования. Выходы отображаются в редакторе без явно определенных столбцов.  
  
-   Добавьте новые столбцы для имитации вывода ошибок для ошибок на уровне строк. Обычно несколько выходов в одной и той же группе `ExclusionGroup` имеют один и тот же набор выходных столбцов. Однако при создании имитации вывода ошибок может оказаться целесообразным добавление нескольких столбцов, содержащих сведения об ошибках. Сведения об обработке ошибочных строк в подсистеме обработки потока данных см. в разделе [Использование выводов ошибок в компоненте потока данных](../extending-packages-custom-objects/data-flow/using-error-outputs-in-a-data-flow-component.md). Обратите внимание на то, что в компоненте скрипта необходимо написать собственный код для заполнения дополнительных столбцов соответствующими сведениями об ошибках. Дополнительные сведения см. в разделе [Имитация вывода ошибок для компонента скрипта](../extending-packages-scripting-data-flow-script-component-examples/simulating-an-error-output-for-the-script-component.md).  
  
 Дополнительные сведения о странице **Входы и выходы** **редактора преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Входы и выходы")](../script-transformation-editor-inputs-and-outputs-page.md).  
  
### <a name="adding-variables"></a>Добавление переменных  
 Если вы хотите использовать существующие переменные в скрипте, можно добавить их в `ReadOnlyVariables` и `ReadWriteVariables` поля свойств на **сценарий** странице **редактор преобразования "скрипт"**.  
  
 Если в поле свойства добавляются несколько переменных, их имена нужно разделять запятыми. Можно также выбрать несколько переменных, нажав кнопку с многоточием (**...** ) рядом с пунктом `ReadOnlyVariables` и `ReadWriteVariables` поля свойств, а затем выбрав переменные в **Выбор переменных** диалоговое окно.  
  
 Общие сведения об использовании переменных в компоненте скрипта см. в разделе [Использование переменных в компоненте скрипта](../extending-packages-scripting/data-flow-script-component/using-variables-in-the-script-component.md).  
  
 Дополнительные сведения о странице **Скрипт** в окне **Редактор преобразования "Скрипт"** см. в разделе [Редактор преобразования "Скрипт" (страница "Скрипт")](../script-transformation-editor-script-page.md).  
  
## <a name="scripting-a-synchronous-transformation-component-in-code-design-mode"></a>Создание скрипта компонента синхронного преобразования в режиме конструктора кода  
 После настройки метаданных для компонента можно написать пользовательский скрипт. В **редакторе преобразования "Скрипт"** на странице **Скрипт** нажмите кнопку **Изменить скрипт**, чтобы открыть интегрированную среду разработки средств [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[vsprvs](../../includes/vsprvs-md.md)] для приложений (VSTA), где можно добавить пользовательский скрипт. Используемый язык скриптов зависит от значения свойства **ScriptLanguage**, указанного на странице **Скрипт**. В качестве значения можно выбрать язык [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic или [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual C#.  
  
 Важные сведения, относящиеся ко всем типам компонентов, создаваемым с помощью компонента скрипта, см. в разделе [Кодирование и отладка компонента скрипта](../extending-packages-scripting/data-flow-script-component/using-variables-in-the-script-component.md).  
  
### <a name="understanding-the-auto-generated-code"></a>Основные сведения об автоматически создаваемом коде  
 При открытии интегрированной среды разработки VSTA после создания и настройки компонента преобразования, изменяемый класс `ScriptMain` отображается в редакторе кода с заглушкой для метода `ProcessInputRow`. Пользовательский код создается в классе `ScriptMain`, а самым важным методом в компоненте преобразования является `ProcessInputRow`.  
  
 Если вы откроете **обозревателя проектов** окна в VSTA, можно увидеть, что компонент скрипта также создал доступные только для чтения `BufferWrapper` и `ComponentWrapper` элементов проекта. Класс `ScriptMain` наследует класс `UserComponent` в элементе проекта `ComponentWrapper`.  
  
 Во время выполнения подсистема обработки потока данных вызывает метод `ProcessInput` в классе `UserComponent`, который переопределяет метод <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent.ProcessInput%2A> родительского класса <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent>. В свою очередь, метод `ProcessInput` проходит по строкам во входном буфере и вызывает для каждой строки метод `ProcessInputRow`.  
  
### <a name="writing-your-custom-code"></a>Написание пользовательского кода  
 Компонент преобразования с синхронными выходами является наиболее простым для написания компонентом потока данных. Например, в образце с единственным выходом, который приведен далее в этом разделе, содержится следующий пользовательский код:  
  
```vb  
Row.City = UCase(Row.City)  
```  
  
```csharp  
Row.City = (Row.City).ToUpper();  
  
```  
  
 Чтобы завершить создание пользовательского компонента синхронного преобразования, необходимо переопределить метод `ProcessInputRow` для преобразования данных в каждой строке входного буфера. Когда этот буфер оказывается заполненным, подсистема обработки потока данных передает его следующему компоненту в потоке данных.  
  
 В зависимости от потребностей, возможно, понадобится написать скрипт с методами `PreExecute` и `PostExecute`, доступными в классе `ScriptMain`, чтобы обеспечить предварительную или итоговую обработку.  
  
### <a name="working-with-multiple-outputs"></a>Работа с несколькими выходами  
 Направление входных строк в один из двух или более возможных выходов не требует большого объема дополнительного пользовательского кода по сравнению со скриптом с единственным выходом, который был рассмотрен выше. Например, в примере с двумя выходами, который приведен далее в этом разделе, содержится следующий пользовательский код:  
  
```vb  
Row.City = UCase(Row.City)  
If Row.City = "REDMOND" Then  
    Row.DirectRowToMyRedmondAddresses()  
Else  
    Row.DirectRowToMyOtherAddresses()  
End If  
```  
  
```csharp  
Row.City = (Row.City).ToUpper();  
  
if (Row.City=="REDMOND")  
{  
    Row.DirectRowToMyRedmondAddresses();  
}  
else  
{  
    Row.DirectRowToMyOtherAddresses();  
}  
```  
  
 В этом примере компонент скрипта формирует методы **DirectRowTo\<OutputBufferX>** на основе имен выходов, настроенных пользователем. Можно использовать аналогичный код для направления строк ошибок в имитированный вывод ошибок.  
  
## <a name="examples"></a>Примеры  
 В приведенных здесь примерах демонстрируется пользовательский код, который необходимо использовать в классе `ScriptMain` для создания компонента синхронного преобразования.  
  
> [!NOTE]  
>  В этих примерах используется **Person.Address** в таблицу `AdventureWorks` образца базы данных и передается ее первый и четвертый столбец — **intAddressID** и **nvarchar (30) City**поток данных. Эти же данные используются в образцах источника, преобразования и назначения, приведенных в этом разделе. Для каждого примера приведены необходимые дополнительные условия и принимаемые предположения.  
  
### <a name="single-output-synchronous-transformation-example"></a>Пример синхронного преобразования с единственным выходом  
 В этом примере демонстрируется компонент синхронного преобразования с единственным выходом. Это преобразование передает столбец **AddressID** без обработки, а столбец **City** преобразует к верхнему регистру.  
  
 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.  
  
1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.  
  
2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из **Person.Address** таблицы `AdventureWorks` образца базы данных, содержащий **AddressID** и **Город** столбцов.  
  
3.  Откройте **редактор преобразования "Скрипт"**. На странице **Входные столбцы** выберите столбцы **AddressID** и **City**. Пометьте столбец **City** как доступный для чтения и записи.  
  
4.  На странице **Входы и выходы** переименуйте вход и выход, дав им более описательные имена, например **MyAddressInput** и **MyAddressOutput**. Обратите внимание, что идентификатор `SynchronousInputID` выхода соответствует идентификатору `ID` входа. Таким образом, нет необходимости добавлять и настраивать выходные столбцы.  
  
5.  На странице **Скрипт** нажмите кнопку **Изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования "Скрипт"**.  
  
6.  Создайте и настройте компонент назначения, ожидающий столбцы **AddressID** и **City**, например назначение [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] или образец компонента назначения, показанный в разделе [Создание назначения с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините выход преобразования с компонентом назначения. Можно создать целевую таблицу, выполнив следующую команду [!INCLUDE[tsql](../../includes/tsql-md.md)] в базе данных `AdventureWorks`:  
  
    ```  
    CREATE TABLE [Person].[Address2]([AddressID] [int] NOT NULL,  
        [City] [nvarchar](30) NOT NULL)  
    ```  
  
7.  Запустите образец.  
  
```vb  
Public Class ScriptMain  
    Inherits UserComponent  
  
    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)  
  
        Row.City = UCase(Row.City)  
  
    End Sub  
  
End Class  
```  
  
```csharp  
public class ScriptMain:  
    UserComponent  
  
{  
    public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)  
    {  
  
        Row.City = (Row.City).ToUpper();  
  
    }  
  
}  
```  
  
### <a name="two-output-synchronous-transformation-example"></a>Пример синхронного преобразования с двумя выходами  
 В этом примере демонстрируется компонент синхронного преобразования с двумя выходами. Это преобразование передает столбец **AddressID** без обработки, а столбец **City** преобразует к верхнему регистру. Если названием города является «Redmond», строка направляется в один выход. Все остальные строки направляются в другой выход.  
  
 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.  
  
1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.  
  
2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из **Person.Address** таблицы `AdventureWorks` образца базы данных, который содержит по крайней мере **AddressID** и **Город** столбцов.  
  
3.  Откройте **редактор преобразования "Скрипт"**. На странице **Входные столбцы** выберите столбцы **AddressID** и **City**. Пометьте столбец **City** как доступный для чтения и записи.  
  
4.  На странице **Входы и выходы** создайте второй выход. После создания нового выхода убедитесь в том, что идентификатору `SynchronousInputID` присвоено значение, совпадающее с идентификатором `ID` входа. Это свойство уже задано для первого выхода, создаваемого по умолчанию. Для каждого выхода присвойте свойству `ExclusionGroup` одно и то же ненулевое значение, чтобы предписать распределение входных строк между двумя взаимоисключающими выходами. Нет необходимости добавлять какие-либо выходные столбцы в выходы.  
  
5.  Переименуйте вход и выходы, дав им более описательные имена, например **MyAddressInput**, **MyRedmondAddresses** и **MyOtherAddresses**.  
  
6.  На странице **Скрипт** нажмите кнопку **Изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования "Скрипт"**.  
  
7.  Создайте и настройте два компонента назначения, ожидающие столбцы **AddressID** и **City**, например назначение [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], назначение "Неструктурированный файл" или образец компонента назначения, показанный в разделе [Создание назначения с помощью компонента скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините каждый из выходов преобразования с одним из компонентов назначения. Можно создать целевые таблицы, выполнив команду [!INCLUDE[tsql](../../includes/tsql-md.md)], аналогичную следующей (с соответствующими уникальными именами таблиц) в базе данных `AdventureWorks`:  
  
    ```  
    CREATE TABLE [Person].[Address2](  
        [AddressID] [int] NOT NULL,  
        [City] [nvarchar](30) NOT NULL  
    ```  
  
8.  Запустите образец.  
  
```vb  
Public Class ScriptMain  
    Inherits UserComponent  
  
    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)  
  
        Row.City = UCase(Row.City)  
  
        If Row.City = "REDMOND" Then  
            Row.DirectRowToMyRedmondAddresses()  
        Else  
            Row.DirectRowToMyOtherAddresses()  
        End If  
  
    End Sub  
  
End Class  
```  
  
```csharp  
public class ScriptMain:  
    UserComponent  
  
public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)  
    {  
  
        Row.City = (Row.City).ToUpper();  
  
        if (Row.City == "REDMOND")  
        {  
            Row.DirectRowToMyRedmondAddresses();  
        }  
        else  
        {  
            Row.DirectRowToMyOtherAddresses();  
        }  
  
    }  
}  
```  
  
|![](./media/creating-a-synchronous-transformation-with-the-script-component/dts-16.gif)  **Оставайтесь в курсе со службами Integration Services**<br /> Чтобы загрузить новейшую документацию, статьи, образцы и видеоматериалы корпорации Майкрософт, а также лучшие решения участников сообщества, посетите страницу служб [!INCLUDE[ssISnoversion](../../includes/msconame-md.md)] на сайте MSDN:<br /><br /> [Посетите страницу служб Integration Services на сайте MSDN](https://go.microsoft.com/fwlink/?LinkId=136655)<br /><br /> Чтобы получать автоматические уведомления об этих обновлениях, подпишитесь на RSS-каналы, предлагаемые на этой странице.  
  
## <a name="see-also"></a>См. также  
 [Основные сведения о синхронных и асинхронных преобразованиях](../understanding-synchronous-and-asynchronous-transformations.md) [Создание асинхронного преобразования с компонентом скрипта](../extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md) [Разработка пользовательского компонента преобразования с синхронным Выходные данные](../extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md)  
  
  
