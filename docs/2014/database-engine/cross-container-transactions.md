---
title: Транзакции между контейнерами | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 5d84b51a-ec17-4c5c-b80e-9e994fc8ae80
author: stevestein
ms.author: sstein
manager: craigg
ms.openlocfilehash: 290aff0bfcb01e098ae87b48cf582cdf999314c4
ms.sourcegitcommit: c44014af4d3f821e5d7923c69e8b9fb27aeb1afd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2019
ms.locfileid: "58528305"
---
# <a name="cross-container-transactions"></a>Транзакции между контейнерами
  Транзакции между контейнерами представляют собой неявные или явные пользовательские транзакции, включающие вызовы хранимых процедур, скомпилированных в собственном коде, или операции над оптимизированными для памяти таблицами.  
  
 В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] вызовы хранимых процедур не инициируют транзакцию. Выполнение хранимых процедур, скомпилированных в собственном коде, в режиме автоматической фиксации (не в контексте пользовательской транзакции) не считается транзакциями между контейнерами.  
  
 Любой интерпретируемый запрос, который ссылается на оптимизированные для памяти таблицы, считается частью транзакции между контейнерами, как при выполнении из явных или неявных транзакций, так и в режиме автоматической фиксации.  
  
##  <a name="isolation"></a> Изоляция отдельных операций  
 Каждая транзакция [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] имеет уровень изоляции. Уровень изоляции по умолчанию — READ COMMITTED. Чтобы использовать другой уровень изоляции, можно задать уровень изоляции с использованием [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).  
  
 Часто приходится выполнять операции над оптимизированными для памяти таблицами с другим уровнем изоляции, чем операции над дисковыми таблицами. В транзакции можно задать другой уровень изоляции для коллекции инструкций или отдельной операции считывания.  
  
### <a name="specifying-the-isolation-level-of-individual-operations"></a>Задание уровня изоляции отдельных операций  
 Чтобы задать другой уровень изоляции для набора инструкций в транзакции, можно использовать `SET TRANSACTION ISOLATION LEVEL`. В следующем примере транзакции по умолчанию используется уровень изоляции SERIALIZABLE. Операции вставки и выбора над t3, t2 и t1 выполняются при использовании уровня изоляции REPEATABLE READ.  
  
```sql  
set transaction isolation level serializable  
go  
  
begin transaction  
 ......  
  set transaction isolation level repeatable read  
  
  insert t3 select * from t1 join t2 on t1.id=t2.id  
  
  set transaction isolation level serializable  
 ......  
commit  
```  
  
 Чтобы задать уровень изоляции для отдельных операций чтения, отличный от назначаемого транзакции по умолчанию, можно использовать табличное указание (например, SERIALIZABLE). Каждый выбор соответствует операции считывания, а каждое обновление и каждое удаление соответствуют чтению, поскольку строку всегда необходимо прочитать, прежде чем ее можно будет обновить или удалить. Операции вставки не имеют уровня изоляции, поскольку запись всегда изолирована в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. В следующем примере уровень изоляции по умолчанию для транзакций — READ COMMITTED, но доступ к таблице t1 происходит в режиме изоляции SERIALIZABLE, а к таблице t2 — в режиме изоляции SNAPSHOT.  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
 ......  
  
  insert t3 select * from t1 (serializable) join t2 (snapshot) on t1.id=t2.id  
  
  ......  
commit  
```  
  
### <a name="isolation-semantics-for-individual-operations"></a>Семантика изоляции для отдельных операций  
 Cериализуемая транзакция T выполняется в полной изоляции. То есть как бы каждая другая транзакция зафиксирована перед запуском T или запущена после фиксации T. Ситуация становится более сложной, если различные операции в транзакции имеют разные уровни изоляции.  
  
 Общая семантика уровней изоляции транзакций в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], наряду с последствиями для блокировки, описан в [SET TRANSACTION ISOLATION LEVEL &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-transaction-isolation-level-transact-sql).  
  
 Для транзакций между контейнерами, где различные операции могут иметь различные уровни изоляции, необходимо понимать семантику изоляции отдельных операций чтения. Операции записи всегда изолированы. Записи в разных транзакциях не могут повлиять друг на друга.  
  
 Операция считывания данных возвращает несколько строк, удовлетворяющих условию фильтра.  
  
 Операции чтения выполняются как часть уровни изоляции T. транзакций для операций чтения, распознаваемый:  
  
 Состояние фиксации  
 Состояние фиксации указывает, гарантирована ли фиксация считывания данных.  
  
 Согласованность (транзакций)  
 Согласованность транзакций для набора операция чтения показывает, гарантировано ли, что чтение версий строк будет включать обновления из точно такого же набора транзакций.  
  
 Гарантии стабильности система дает транзакции T относительно считывания данных.  
 Стабильность показывает, повторяемы ли операции считывания транзакции. То есть, если операции чтения повторяются, возвратят ли они одни и те же строки и версии строк?  
  
 Некоторые гарантии относятся ко времени логического завершения транзакции. В целом время логического завершения — это время фиксации транзакции в базе данных. Если транзакция выполняет доступ к оптимизируемым для памяти таблицам, то время логического завершения технически представляет собой начало этапа проверки. (Дополнительные сведения см. в разделе существования транзакции в [транзакции в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
 Независимо от уровня изоляции транзакция (T) всегда видит свои собственные обновления.  
  
 READ UNCOMMITTED  
 Чтение данных не может быть зафиксировано, согласовано или стабильно. Однако оно содержит операции записи, выполненные ранее транзакцией T.  
  
 READ COMMITTED  
 Считывание данных будет зафиксировано.  
  
 SNAPSHOT  
 Все операции считывания, выполняемые транзакцией T в режиме изоляции SNAPSHOT, имеют то же время логического чтения, которое представляет собой начало транзакции. Считывание данных гарантированно фиксируется и согласовано для времени логического чтения. Повтор чтения во время первоначального чтения гарантированно возвращает тот же результат.  
  
 REPEATABLE READ  
 Считывание данных гарантированно фиксируется и стабильно до времени логического завершения транзакции.  
  
 SERIALIZABLE  
 Все гарантии REPEATABLE READ, а также Предотвращение фантомов и согласованность транзакций по отношению к всем сериализуемым операциям чтения, выполненных T. фантомов предотвращения означает, что операция просмотра может возвращать только дополнительные строки, записанные транзакцией T, но не строки, которые были записаны другими транзакциями.  
  
 Рассмотрим следующую транзакцию:  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
  -- remove all rows from t3; the related read operation is performed under read committed   
  -- isolation, as this is the default for the transaction  
  delete from t3  
  
  -- copy the contents from t1 to t3; the read on t1 is performed under the serializable   
  -- isolation level  
  insert t3 select * from t1 (serializable)  
  
  -- compare t3 and t1; note: the result set may not be empty, as rows may have been added   
  -- by other transaction before this select, due to the read committed isolation level  
  select * from t3 except t1  
  
  -- compare t1 and t3; note: the result set is empty, as no rows have been added to t1   
  -- since its contents were copied to t1, due to the serializable isolation level  
  select * from t1 except t3  
commit  
```  
  
 Эта транзакция удаляет все строки из t3 в режиме изоляции READ COMMITTED, копирует все строки от t1 до t3 в режиме изоляции SERIALIZABLE, а затем сравнивает t1 и t3. Некоторые строки [не в t1] могут быть добавлены к t3, поскольку таблица стала пустой. Строки не были добавлены к t1, так как копия была сериализуемая.  
  
 Несмотря на то, что чтения из t1 в конце транзакции синтаксически — read committed, но фактически является сериализуемой, поскольку та же операция чтения выполнялась ранее в транзакции в режиме изоляции serializable: возможность сериализации гарантирует, что если считывание выполнить в любой момент в транзакции, возвращаются те же строки.  
  
## <a name="cross-container-transactions-and-isolation-levels"></a>Транзакции между контейнерами и уровни изоляции  
 Транзакции между контейнерами можно рассматривать с двух сторон: дисковой стороны (для операций на дисковых таблицах) и стороны оптимизированной памяти (для операций на таблицах, оптимизированных для памяти). Уровни изоляции этих двух сторон могут быть различными. В действительности отдельные операции чтения с каждой стороны могут иметь различные уровни изоляции.  
  
 Дисковая сторона данной транзакции T достигает определенного уровня изоляции X, если выполняется одно из следующих условий.  
  
-   Она запускается в X. То есть сеанс по умолчанию — X, потому что выполнена `SET TRANSACTION ISOLATION LEVEL`, или это [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] по умолчанию.  
  
-   Во время транзакции уровень изоляции по умолчанию изменяется на X с помощью `SET TRANSACTION ISOLATION LEVEL`.  
  
-   Операция считывания в дисковой таблице выполняется на уровне изоляции X с использованием синтаксиса `WITH (X)`.  
  
 Сторона оптимизированной для памяти T достигает уровня изоляции Y, если во время выполнения T любая операция считывания в таблице, оптимизированной для памяти, или любая хранимая процедура, скомпилированная в собственном коде, выполняется с уровнем изоляции Y.  
  
 В качестве примера рассмотрим следующую транзакцию. В данном случае t1 и t2 — дисковые таблицы, а t3 и t4 — оптимизированные для памяти таблицы.  
  
 Дисковая сторона транзакции достигает уровня изоляции READ COMMITTED, поскольку запускается на данном уровне. Дисковая сторона также достигает уровня изоляции REPEATABLE READ, так как первая операция чтения выполняется на этом уровне изоляции. Удаление в конце транзакции выполняется с уровнем изоляции READ COMMITTED, поэтому не вызывает перехода на новый уровень изоляции.  
  
 Оптимизированные для памяти сторона транзакции может достигать одного из двух уровней: Если Условие1 имеет значение true, то достигается сериализуемый, если он имеет значение false, оптимизированная для памяти сторона достигает только режим изоляции моментального снимка.  
  
```sql  
set transaction isolation level read committed  
go  
  
begin transaction  
  select * from t1 (repeatableread)  
  
  if condition1 begin  
    insert t3 select * from t4 (serializable)  
  end  
  else begin  
    insert t3 select * from t4 (snapshot)  
  end  
  
  delete from t1  
commit  
```  
  
### <a name="supported-isolation-levels-for-cross-container-transactions"></a>Поддерживаемые уровни изоляции для транзакций между контейнерами  
 Существуют ограничения на уровни изоляции, используемые с операциями над оптимизированными для памяти таблицами в транзакциях между контейнерами.  
  
 Оптимизированные для памяти таблицы поддерживают уровни изоляции SNAPSHOT, REPEATABLE READ и SERIALIZABLE. Для транзакций с автоматической фиксацией оптимизированные для памяти таблицы поддерживают уровень изоляции READ COMMITTED.  
  
 Поддерживаются следующие сценарии:  
  
-   Транзакции между контейнерами READ UNCOMMITTED, READ COMMITTED и READ_COMMITTED_SNAPSHOT могут получить доступ к оптимизированным для памяти таблицам в режиме изоляции SNAPSHOT, REPEATABLE READ и SERIALIZABLE. Гарантия READ COMMITTED действует для транзакции; все строки, считанные транзакцией, были зафиксированы в базе данных.  
  
-   Транзакции REPEATABLE READ и SERIALIZABLE могут получить доступ к оптимизированным для памяти таблицам в режиме изоляции SNAPSHOT.  
  
## <a name="read-only-cross-container-transactions"></a>Транзакции между контейнерами только для чтения  
 Большинство транзакции только для чтения в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] откатываются в момент фиксации. Поскольку отсутствуют изменения, которые будут зафиксированы в базе данных, система просто освобождает ресурсы, используемые транзакцией. Для дисковых транзакций только для чтения все блокировки, сделанные транзакцией, снимаются в данный момент. Оптимизированные для памяти транзакции только для чтения, которые занимают одну скомпилированную в собственном коде хранимую процедуру, не проверяются.  
  
 Транзакции только для чтения между контейнерами в режиме автоматической фиксации просто откатываются в конце транзакции. Проверка не произведена.  
  
 Явные или неявные транзакции только для чтения между контейнерами выполняют проверку в момент фиксации, если транзакция обращается к таблицам с оптимизацией для памяти в уровне изоляции REPEATABLE READ или SERIALIZABLE. Сведения о проверке см. в разделе об обнаружении конфликтов, проверки, и проверках зависимости фиксации в [транзакции в таблицах, оптимизированных для памяти](../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
## <a name="see-also"></a>См. также  
 [Основные сведения о транзакциях в таблицах, оптимизированных для памяти](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md)   
 [Рекомендации для уровней изоляции транзакций с таблицами, оптимизированными для памяти](../../2014/database-engine/guidelines-for-transaction-isolation-levels-with-memory-optimized-tables.md)   
 [Рекомендации для логики повторного выполнения транзакций для таблиц, оптимизированных для памяти](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md)  
  
  
