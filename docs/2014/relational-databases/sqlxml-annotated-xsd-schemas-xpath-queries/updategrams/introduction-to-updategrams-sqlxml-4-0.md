---
title: Введение в диаграмм обновления (SQLXML 4,0) | Документация Майкрософт
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- explicit schema mapping [SQLXML]
- updategrams [SQLXML], mapping schema specifying
- namespaces [SQLXML]
- updategrams [SQLXML], about updategrams
- attribute-centric mapping
- invalid characters [SQLXML]
- element-centric mapping [SQLXML]
- mapping schema [SQLXML], updategrams
- namespaces [SQLXML], updategrams
- executing updategrams [SQLXML]
- implicit schema mapping
ms.assetid: cfe24e82-a645-4f93-ab16-39c21f90cce6
author: rothja
ms.author: jroth
ms.openlocfilehash: aa0c46afa3c91f9256f5789148bceaa2f73e3165
ms.sourcegitcommit: 57f1d15c67113bbadd40861b886d6929aacd3467
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/18/2020
ms.locfileid: "85047510"
---
# <a name="introduction-to-updategrams-sqlxml-40"></a>Общие сведения о диаграммах обновления (SQLXML 4.0)
  Можно изменить (вставить, обновить или удалить) базу данных [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] из существующего XML-документа с помощью функции диаграмма обновления или OPENXML [!INCLUDE[tsql](../../../includes/tsql-md.md)] .  
  
 Функция OPENXML изменяет базу данных, разделяя существующий XML-документ и формируя набор строк, который можно передавать инструкциям INSERT, UPDATE и DELETE. С помощью функции OPENXML операции выполняются непосредственно с таблицами базы данных. Поэтому использование функции OPENXML является наиболее оптимальным вариантом во всех случаях, когда поставщики наборов строк, например таблицы, могут быть источниками.  
  
 Диаграммы обновления, подобно функции OPENXML, позволяют вставлять, обновлять и удалять данные в базе данных. Однако диаграммы обновления работают не с таблицами, а с XML-представлениями, создаваемыми аннотированной XSD-схемой (или XDR-схемой); например, обновления применяются к XML-представлению, созданному сопоставляемой схемой. Схема сопоставления в свою очередь содержит данные, необходимые для сопоставления XML-элементов и атрибутов с соответствующими таблицами и столбцами базы данных. Диаграмма обновления использует эти данные сопоставления, чтобы выполнить обновление таблиц и столбцов базы данных.  
  
> [!NOTE]  
>  Настоящая документация предназначена для тех, кто знаком с шаблонами и поддержкой схем сопоставления в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. Дополнительные сведения см. [в разделе Введение в схемы XSD с Заметками &#40;SQLXML 4,0&#41;](../../sqlxml/annotated-xsd-schemas/introduction-to-annotated-xsd-schemas-sqlxml-4-0.md). Дополнительные сведения о устаревших приложениях, использующих XDR, см. [в разделе схемы XDR с Заметками &#40;не рекомендуется в SQLXML 4,0&#41;](../../sqlxml/annotated-xsd-schemas/annotated-xdr-schemas-deprecated-in-sqlxml-4-0.md).  
  
## <a name="required-namespaces-in-the-updategram"></a>Обязательные пространства имен в диаграмме обновления  
 Ключевые слова в диаграмма обновления, такие как **\<sync>** , **\<before>** и **\<after>** , существуют в `urn:schemas-microsoft-com:xml-updategram` пространстве имен. Префикс пространства имен может быть произвольным. В этой документации префикс `updg` обозначает пространство имен `updategram`.  
  
## <a name="reviewing-syntax"></a>Обзор синтаксиса  
 Диаграмма обновления — это шаблон с **\<sync>** **\<before>** блоками, и **\<after>** , которые формируют синтаксис диаграмма обновления. Следующий код показывает этот синтаксис в его простейшей форме:  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
  <updg:sync [mapping-schema= "AnnotatedSchemaFile.xml"] >  
    <updg:before>  
        ...  
    </updg:before>  
    <updg:after>  
        ...  
    </updg:after>  
  </updg:sync>  
</ROOT>  
```  
  
 Следующие определения описывают роль каждого блока.  
  
 **\<before>**  
 Определяет текущее состояние (называемое также «исходным состоянием») экземпляра записи.  
  
 **\<after>**  
 Определяет новое состояние изменяемых данных.  
  
 **\<sync>**  
 Содержит **\<before>** блоки и **\<after>** . **\<sync>** Блок может содержать более одного набора **\<before>** **\<after>** блоков и. Если имеется более одного набора **\<before>** **\<after>** блоков и, эти блоки (даже если они пусты) должны быть указаны парами. Более того, диаграмма обновления может иметь более одного **\<sync>** блока. Каждый **\<sync>** блок является одной единицей транзакции (что означает, что все в **\<sync>** блоке выполняется или ничего не происходит). При указании нескольких **\<sync>** блоков в диаграмма обновления сбой одного **\<sync>** блока не влияет на другие **\<sync>** блоки.  
  
 Будет ли диаграмма обновления удалять, вставлять или обновлять экземпляр записи, зависит от содержимого **\<before>** **\<after>** блоков и:  
  
-   Если экземпляр записи отображается только в **\<before>** блоке без соответствующего экземпляра в **\<after>** блоке, диаграмма обновления выполняет операцию удаления.  
  
-   Если экземпляр записи отображается только в **\<after>** блоке без соответствующего экземпляра в **\<before>** блоке, это операция вставки.  
  
-   Если экземпляр записи присутствует в **\<before>** блоке и имеет соответствующий экземпляр в **\<after>** блоке, это операция обновления. В этом случае диаграмма обновления обновляет экземпляр записи на значения, указанные в **\<after>** блоке.  
  
## <a name="specifying-a-mapping-schema-in-the-updategram"></a>Указание сопоставления схемы в диаграмме обновления  
 В диаграмме обновления XML-абстракция, созданная сопоставляемой схемой (поддерживаются схемы XSD и XDR), может быть явной или неявной (то есть диаграмма обновления может работать как с заданной схемой сопоставления, так и без нее). Если схема сопоставления не указана, диаграмма обновления предполагает неявное сопоставление (сопоставление по умолчанию), где каждый элемент в **\<before>** блоке или **\<after>** сопоставляется с таблицей, а дочерний элемент или атрибут каждого элемента сопоставляется со столбцом в базе данных. Если схема сопоставления указана явно, то элементы и атрибуты в диаграмме обновления должны совпадать с элементами и атрибутами сопоставляемой схемы.  
  
### <a name="implicit-default-mapping"></a>Неявное сопоставление (по умолчанию)  
 В большинстве случаев диаграмма обновления, выполняющая простые обновления, не требует схемы сопоставления. В такой ситуации диаграмма обновления полагается на схему сопоставления, принятую по умолчанию.  
  
 В следующей диаграмме обновления показано неявное сопоставление. В этом примере диаграмма обновления применяется для вставки данных нового клиента в таблицу Sales.Customer. Так как в этом диаграмма обновления используется неявное сопоставление, \<Sales.Customer> элемент сопоставляется с таблицей Sales. Customer, а атрибуты CustomerID и SalesPersonID сопоставляются с соответствующими столбцами в таблице Sales. Customer.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
<updg:before>  
</updg:before>  
<updg:after>  
    <Sales.Customer CustomerID="1" SalesPersonID="277" />  
    </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="explicit-mapping"></a>Явное сопоставление  
 Если указывается схема сопоставления (XSD или XDR), диаграмма обновления использует эту схему для определения подлежащих обновлению таблиц и столбцов базы данных.  
  
 Если диаграмма обновления выполняет сложное обновление (например, вставку записей в несколько таблиц на основе связи «родители-потомки», заданной в схеме сопоставления), необходимо явно задать схему сопоставления с помощью атрибута `mapping-schema`, по которому выполняется диаграмма обновления.  
  
 Диаграмма обновления является шаблоном, поэтому заданный в ней путь для схемы сопоставления зависит от расположения файла шаблона (является относительным). Дополнительные сведения см. [в разделе Указание схемы сопоставления с заметками в диаграмма обновления &#40;SQLXML 4,0&#41;](specifying-an-annotated-mapping-schema-in-an-updategram-sqlxml-4-0.md).  
  
## <a name="element-centric-and-attribute-centric-mapping-in-updategrams"></a>Элементная и атрибутивная модель сопоставления в диаграммах обновления  
 При сопоставлении по умолчанию (когда сопоставляемая схема не указывается в диаграмме обновления), элементы диаграммы обновления сопоставляются с таблицами и дочерними элементами (в случае элементной модели сопоставления), а атрибуты сопоставляются со столбцами (в случае атрибутивной модели сопоставления).  
  
### <a name="element-centric-mapping"></a>Сопоставление, ориентированное на элементы  
 В диаграмме обновления, основанной на элементах, элемент содержит дочерние элементы, обозначающие свойства этого элемента. В качестве примера см. следующую диаграмму обновления. **\<Person.Contact>** Элемент содержит **\<FirstName>** **\<LastName>** дочерние элементы и. Эти дочерние элементы являются свойствами **\<Person.Contact>** элемента.  
  
 Так как в этом диаграмма обновления не указана схема сопоставления, диаграмма обновления использует неявное сопоставление, где **\<Person.Contact>** элемент сопоставляется с таблицей Person. Contact и ее дочерними элементами сопоставляются со столбцами FirstName и LastName.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:after>  
    <Person.Contact>  
       <FirstName>Catherine</FirstName>  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="attribute-centric-mapping"></a>атрибутивное сопоставление  
 В атрибутивной модели сопоставления элементы имеют атрибуты. В следующей диаграмме обновления используется атрибутивная модель сопоставления. В этом примере **\<Person.Contact>** элемент состоит из атрибутов **FirstName** и **LastName** . Эти атрибуты являются свойствами **\<Person.Contact>** элемента. Как и в предыдущем примере, в этом диаграмма обновления не указана схема сопоставления, поэтому она использует неявное сопоставление для сопоставления **\<Person.Contact>** элемента с таблицей Person. Contact и атрибутами элемента с соответствующими столбцами в таблице.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" LastName="Abel" />  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="using-both-element-centric-and-attribute-centric-mapping"></a>Одновременное использование элементной и атрибутивной моделей сопоставления  
 Можно использовать сочетание элементной и атрибутивной моделей сопоставления, как показано в следующей диаграмме обновления. Обратите внимание, что **\<Person.Contact>** элемент содержит как атрибут, так и дочерний элемент. Кроме того, в этой диаграмме обновления используется неявное сопоставление. Таким образом, атрибут **FirstName** и **\<LastName>** дочерний элемент сопоставляются с соответствующими столбцами в таблице Person. Contact.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" >  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
## <a name="working-with-characters-valid-in-sql-server-but-not-valid-in-xml"></a>Работа с символами, допустимыми в SQL Server, но не допустимыми в XML  
 В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] имена таблиц могут содержать пробелы. Но в XML имена таблиц такого типа не допускаются.  
  
 Для кодирования символов, которые являются допустимыми [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] идентификаторами, но не являются допустимыми XML-идентификаторами, используйте "__xHHHH \_ \_ " в качестве значения кодировки, где HHHH означает шестнадцатеричный код UCS-2 для символа в наиболее значительном порядке. При использовании этой схемы кодирования символ пробела заменяется на x0020 (шестнадцатеричный код из четырех цифр для символа пробела); Таким же именем таблица [Order Details] в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] _x005B_Order_x0020_Details_x005Dся \_ в XML.  
  
 Аналогичным образом может потребоваться указать имена элементов из трех частей, например \<[database].[owner].[table]> . Поскольку символы квадратной скобки ([и]) недопустимы в XML, необходимо указать этот параметр как \<_x005B_database_x005D\_._x005B_owner_x005D\_._x005B_table_x005D\_> , где _x005B \_ — это кодировка для левой квадратной скобки ([), а _x005D — это \_ Кодировка правой квадратной скобки (]).  
  
## <a name="executing-updategrams"></a>Выполнение диаграмм обновления  
 Диаграмма обновления является шаблоном, поэтому к ней применяются все механизмы обработки шаблона. В SQLXML 4.0 диаграмму обновления можно выполнить следующими способами:  
  
-   с помощью команды ADO;  
  
-   с помощью команды OLE DB.  
  
## <a name="see-also"></a>См. также:  
 [Вопросы безопасности диаграмма обновления &#40;SQLXML 4,0&#41;](../security/updategram-security-considerations-sqlxml-4-0.md)  
  
  
