---
title: Полнотекстовый поиск в столбцах XML | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dbe-xml
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- xml columns [full-text search]
- indexes [full-text search]
ms.assetid: 8096cfc6-1836-4ed5-a769-a5d63b137171
caps.latest.revision: 13
author: craigg-msft
ms.author: craigg
manager: jhubbard
ms.openlocfilehash: f184bde2fd63407671713285d80489068eee62d7
ms.sourcegitcommit: 5dd5cad0c1bbd308471d6c885f516948ad67dfcf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/19/2018
ms.locfileid: "36095419"
---
# <a name="use-full-text-search-with-xml-columns"></a>Полнотекстовый поиск в XML-столбцах
  Для XML-столбцов можно создавать полнотекстовые индексы, индексирующие XML-значения, но игнорирующие XML-разметку. Теги элементов используются в качестве границ токенов. Индексируются следующие элементы:  
  
-   Содержимое XML-элементов.  
  
-   Только содержимое XML-атрибутов элемента на высшем уровне, за исключением случаев, когда эти значения являются числовыми.  
  
 Иногда можно совместно пользоваться полнотекстовым поиском и XML-индексом следующим образом.  
  
1.  Сначала отфильтруйте интересующие XML-значения, используя механизм полнотекстового поиска SQL.  
  
2.  Затем запросите XML-значения, которые используют XML-индекс, связанный с XML-столбцом.  
  
## <a name="example-combining-full-text-search-with-xml-querying"></a>Пример. Комбинирование полнотекстового поиска с XML-запросами  
 После создания полнотекстового индекса для XML-столбца следующий запрос проверяет, что название книги содержит слово «custom»:  
  
```  
SELECT *   
FROM   T   
WHERE  CONTAINS(xCol,'custom')   
AND    xCol.exist('/book/title/text()[contains(.,"custom")]') =1  
```  
  
 В методе **contains()** полнотекстовый индекс используется для выделения всех XML-значений, содержащих слово "custom". Предложение **exist()** гарантирует, что это слово входит в название книги.  
  
 Инструкции полнотекстового поиска, в которых используются методы **contains()** и **contains()** языка XQuery, имеют различную семантику. Во втором случае выполняется сопоставление подстрок, а в первом — сопоставление токенов с применением лемматизации. Таким образом, если искать строку, содержащую в заголовке слово "run", в число найденных вариантов войдут "run", "runs" и "running", потому что они соответствуют требованиям как метода **contains()** механизма полнотекстового поиска, так и метода **contains()** языка XQuery. Однако условия нашего запроса не соответствуют слову customizable в заголовке, что вызывает сбой **contains()** , хотя условия метода **contains()** языка XQuery были бы удовлетворены. Как правило, чтобы провести истинное сопоставление подстрок, метод **contains()** механизма полнотекстового поиска использовать не следует.  
  
 Кроме того, при полнотекстовом поиске выполняется лемматизация, а метод **contains()** языка XQuery осуществляет буквальное сопоставление. Это различие поясняет следующий пример.  
  
## <a name="example-full-text-search-on-xml-values-using-stemming"></a>Пример. Полнотекстовый поиск XML-значений с использованием выделения корней  
 Проверку **contains()** языка XQuery, выполненную в предыдущем примере, обычно устранить нельзя. Рассмотрим следующий запрос:  
  
```  
SELECT *   
FROM   T   
WHERE  CONTAINS(xCol,'run')   
```  
  
 Слово «run» в документе соответствует условию поиска, потому что при этом осуществляется лемматизация. Кроме того, при использовании XQuery не проверяется контекст поиска.  
  
 Если при помощи схем XML-данные распределены по реляционным столбцам, для которых выполнено полнотекстовое индексирование, при обработке запросов XPath, адресованных XML-представлению, полнотекстовый поиск в базовых таблицах не выполняется.  
  
## <a name="see-also"></a>См. также  
 [XML-индексы (SQL Server)](xml-indexes-sql-server.md)  
  
  