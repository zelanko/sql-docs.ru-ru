---
title: Справочник по логическим и физическим операторам Showplan | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: e4e45de57f4ea1ea88b72df7190e5ec8c3a1f768
ms.sourcegitcommit: 6fd8c1914de4c7ac24900fe388ecc7883c740077
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2020
ms.locfileid: "62627737"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Справочник по логическим и физическим операторам Showplan
  Операторы описывают, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет запрос или инструкцию языка DML. Оптимизатор запросов использует операторы для построения плана запроса, чтобы создать результат, заданный в запросе, или произвести операцию, указанную в инструкции DML. План запроса — это дерево физических операторов. Можно просмотреть план запроса с помощью инструкций SET SHOWPLAN, параметров графического плана выполнения в среде [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]и классов событий SQL Server Profiler Showplan.  
  
 Операторы классифицируются как логические и физические.  
  
 **Логические операторы**  
 Логические операторы описывают операции реляционной алгебры, используемые для обработки инструкции. Другими словами, логические операторы описывают на концептуальном уровне, какие действия следует совершить.  
  
 **Физические операторы**  
 Физические операторы реализуют действия, описанные логическими операторами. Каждый физический оператор является объектом или процедурой, выполняющей операцию. Например, некоторые физические операторы обращаются к столбцам и строкам таблицы, индекса или представления. Другие физические операторы выполняют другие операции, такие как вычисления, статистическая обработка, проверка целостности данных или соединения. Физическим операторам соответствует их стоимость.  
  
 Физические операторы производят инициализацию, собирают данные и закрываются. Если формулировать более конкретно, физический оператор может ответить на вызов трех следующих методов.  
  
-   **Init()** . Метод **Init()** заставляет физический оператор инициализировать себя и подготовить все необходимые структуры данных. Физический оператор может получать много вызовов **Init()** , хотя обычно получает лишь один.  
  
-   **GetNext()** . Метод **GetNext()** заставляет физический оператор получить первую или последующую строку данных. Физический оператор может получить много вызовов **GetNext()** или не получить ни одного.  
  
-   **Close()** . При вызове метода **Close()** физический оператор выполняет некоторые действия по очистке и завершает свою работу. Физический оператор получает только один вызов **Close()** .  
  
 Метод **GetNext()** возвращает одну строку данных, а число его вызовов отображается значением **ActualRows** в выводе инструкции Showplan, который формируется с использованием инструкций SET STATISTICS PROFILE ON или SET STATISTICS XML ON. Дополнительные сведения об этих параметрах SET см. в разделах [SET STATISTICS PROFILE (Transact-SQL)](/sql/t-sql/statements/set-statistics-profile-transact-sql) и [SET STATISTICS XML (Transact-SQL)](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Счетчики **ActualRebinds** и **ActualRewinds**, которые появляются в выводе инструкции Showplan, указывают на число вызовов метода **Init()** . Если оператор не находится внутри цикла соединения, **ActualRebinds** равняется одному, а **ActualRewinds** нулю. Если оператор находится внутри цикла соединения, сумма числа повторных привязок и сбросов на начало должна равняться количеству строк, обработанных снаружи цикла. Повторная привязка значит, что изменился один и более связанный параметр соединения, и внутреннюю часть нужно пересчитать. Сброс на начало значит, что не изменился ни один из связанных параметров и можно вновь использовать прежний внутренний результирующий набор.  
  
 Счетчики**ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, который произведен с использованием инструкции SET STATISTICS XML ON. Они заполняются только для **некластеризованной очереди индексов**, `Remote Query`, **строки с буферизацией строк**, `Sort`, **буферизации таблицы**и **возвращающих** табличное значение функций. **Счетчики actualrebinds** и **ActualRewinds** также могут быть заполнены для операторов `Assert` **фильтров** и, если атрибут **startupexpression установлен** имеет значение true.  
  
 Когда счетчики **ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, их значения сравнимы со значениями **EstimateRebinds** и **EstimateRewinds**. Когда они отсутствуют, оценочное число строк (**EstimateRows**) сравнимо с действительным числом строк (**ActualRows**). Обратите внимание, что действительный графический вывод Showplan отображает нули для действительных повторных привязок и сбросов на начало, когда те отсутствуют.  
  
 Связанный счетчик **ActualEndOfScans**доступен только в том случае, когда вывод инструкции Showplan производится с помощью инструкции SET STATISTICS XML ON. Всякий раз, когда физический оператор достигает конца потока данных, этот счетчик увеличивается на единицу. Физический оператор может достигать конца своего потока данных ни одного, один или несколько раз. Как и в случае с повторными привязками и сбросами на начало, число окончаний просмотров может превышать единицу только в том случае, если оператор находится внутри цикла соединения. Количество окончаний просмотров должно быть меньше или равно сумме количеств повторных привязок и сбросов на начало.  
  
## <a name="mapping-physical-and-logical-operators"></a>Сопоставление физических и логических операторов  
 Оптимизатор запросов создает план запроса в виде дерева логических операторов. После этого оптимизатор запросов выбирает наиболее эффективный физический оператор для каждого логического. Оптимизатор запросов использует подход, основанный на стоимости, чтобы определить, с помощью какого физического оператора будет реализован логический.  
  
 Обычно логическую операцию можно реализовать с помощью нескольких физических операторов. Однако в редких случаях физический оператор может реализовывать несколько логических операций.  
  
## <a name="operator-descriptions"></a>Описание оператора  
 Этот раздел содержит описания логических и физических операторов.  
  
|Значок графического плана выполнения|Оператор Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|Оператор `Aggregate` вычисляет выражения с функциями MIN, MAX, SUM, COUNT или AVG. Оператор `Aggregate` может быть логическим или физическим.|  
|![Значок оператора Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Значок оператора Arithmetic Expression")|`Arithmetic Expression`|Оператор `Arithmetic Expression` вычисляет новое значение на основе существующих значений в строке. Оператор `Arithmetic Expression` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Значок оператора Assert](../../2014/database-engine/media/assert-32x.gif "Значок оператора Assert")|`Assert`|Оператор `Assert` проверяет условие. Например, этот оператор проверяет целостность ссылок или гарантирует, что скалярный вложенный запрос возвращает одну строку. Для каждой входной строки `Assert` оператор вычисляет выражение в `Argument` столбце плана выполнения. Если значением этого выражения является NULL, строка передается через оператор `Assert` и выполнение запроса продолжается. При значении этого выражения, отличном от NULL, будет выдана соответствующая ошибка. `Assert` является физическим оператором.|  
|![Значок элемента Assign Language](../../2014/database-engine/media/assign-32.gif "Значок элемента Assign Language")|`Assign`|Оператор `Assign` присваивает переменной значение выражения или константы. `Assign` является элементом языка.|  
|Отсутствуют|`Asnyc Concat`|Оператор `Asnyc Concat` применяется только в удаленных запросах (распределенных запросах). Он имеет *n* дочерних узлов и один родительский узел. Обычно некоторые дочерние узлы являются удаленными компьютерами, участвующими в распределенном запросе. Оператор `Asnyc Concat` выполняет вызовы методов `open()` одновременно ко всем дочерним узлам, а затем применяет к каждому битовую карту. Для каждого бита, равного 1, оператор `Async Concat` по запросу отправляет выходные строки родительскому узлу.|  
|![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Значок оператора Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]использует `Bitmap` оператор для реализации фильтрации по битовым картам в параллельных планах запросов. Фильтрация по битовым картам ускоряет выполнение запроса, исключая строки со значениями ключа, которые не могут создавать записи объединения, перед передачей строк через другой оператор, например `Parallelism` оператор. Фильтр по битовым картам использует компактное представление набора значений из таблицы, находящейся в одной части дерева операторов, для фильтрации строк из другой таблицы, находящейся в другой части дерева. Если сразу удалять ненужные строки в запросе, последующие операторы работают с меньшим количеством строк, тем самым повышая общую производительность. Оптимизатор определяет, достаточно ли избирательна битовая маска, чтобы быть полезной, и в каких операторах применить фильтр. `Bitmap` является физическим оператором.|  
|![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Значок оператора Bitmap")|`Bitmap Create`|Оператор `Bitmap Create` появляется на выходе инструкции Showplan, в которой строятся битовые маски. `Bitmap Create` является логическим оператором.|  
|![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")|`Bookmark Lookup`|Оператор `Bookmark Lookup` производит поиск соответствующей строки в таблице или кластеризованном индексе по закладке (идентификатору строки или ключу кластеризации). `Argument` Столбец содержит метку закладки, используемую для поиска строки в таблице или кластеризованном индексе. `Argument` Столбец также содержит имя таблицы или кластеризованного индекса, в котором выполняется поиск строки. Если в `Argument` столбце ПРИСУТСТВУЕТ предложение WITH упреждающей выборки, обработчик запросов определил, что оптимально использовать асинхронную предварительную выборку (упреждающее чтение) при поиске закладок в таблице или кластеризованном индексе.<br /><br /> Оператор `Bookmark Lookup` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. Вместо этого функцию поиска закладок обеспечивают операторы `Clustered Index Seek` и `RID Lookup`. Оператор `Key Lookup` также выполняет данные функции.|  
|Отсутствуют|`Branch Repartition`|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`. Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`. `Branch Repartition` и `Segment Repartition` являются логическими операторами.|  
|Отсутствуют|`Broadcast`|`Broadcast`имеет один дочерний узел и *n* родительских узлов. `Broadcast` рассылает входные строки нескольким получателям по требованию. Каждый пользователь получает полный набор строк. Например, если все получатели являются элементами хэш-соединения, то будет создано *n* копий хэш-таблиц.|  
|![Значок оператора Build Hash](../../2014/database-engine/media/build-hash.gif "Значок оператора Build Hash")|`Build Hash`|Указывает сборку хэш-таблицы пакета для индекса columnstore, оптимизированного для памяти xVelocity.|  
|Отсутствуют|`Cache`|`Cache`является специализированной версией оператора **spool** . Он сохраняет только одну строку данных. `Cache` является логическим оператором. Оператор `Cache` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Значок оператора Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Значок оператора Clustered Index Delete")|`Clustered Index Delete`|Оператор `Clustered Index Delete` удаляет строки из кластеризованного индекса, заданного в столбце Argument плана выполнения запроса. При наличии в столбце Argument предиката WHERE:() удаляются только строки, удовлетворяющие условиям предиката.`Clustered Index Delete`  является физическим оператором.|  
|![Значок оператора Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Значок оператора Clustered Index Insert")|`Clustered Index Insert`|Оператор `Clustered Index Insert` инструкции Showplan вставляет строки со своего входа в кластеризованный индекс, указанный в столбце Argument. В столбце Argument также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. Если `Clustered Index Insert` не имеет дочерних элементов для вставки значений, вставляемая строка берется из самого `Insert` оператора.`Clustered Index Insert`  является физическим оператором.|  
|![Оператор Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Оператор Clustered Index Merge")|**Clustered Index Merge**|Оператор **Clustered Index Merge** применяет поток данных слияния к кластеризованному индексу. Оператор удаляет, обновляет или вставляет строки из кластеризованного индекса, указанного в `Argument` столбце оператора. Фактическая операция зависит от значения времени выполнения столбца **Action** , указанного в `Argument` столбце оператора. **Clustered Index Merge** является физическим.|  
|![Значок оператора Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Значок оператора Clustered Index Scan")|`Clustered Index Scan`|Оператор `Clustered Index Scan` сканирует кластеризованный индекс, заданный в столбце Argument плана выполнения запроса. При наличии необязательного предиката WHERE:() возвращаются только строки, удовлетворяющие предикату. Если столбец Argument содержит предложение ORDERED, обработчик запросов требует, чтобы выходные данные строк были возвращены в порядке, в соответствии с которым они были отсортированы в кластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск в индексе оптимальным способом, без обязательной сортировки выходных данных. `Clustered Index Scan` является логическим и физическим оператором.|  
|![Значок оператора Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Значок оператора Clustered Index Seek")|`Clustered Index Seek`|Оператор `Clustered Index Seek` использует возможности поиска по индексам для получения строк из кластеризованного индекса. `Argument` Столбец содержит имя используемого кластеризованного индекса и предикат SEEK:(). Подсистема хранилища использует этот индекс для обработки только тех строк, которые удовлетворяют данному предикату SEEK:(). Также может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:(), но это не является обязательным и не использует индексы для завершения процесса.<br /><br /> Если `Argument` столбец содержит предложение ORDERED, обработчик запросов определил, что строки должны возвращаться в том порядке, в котором они были отсортированы в кластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск индекса оптимальным способом, без обязательной сортировки выходных данных. Сохранять порядок выходных данных является менее эффективным, чем формировать несортированные выходные данные. При указании ключевого слова LOOKUP выполняется поиск закладок. В [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях `Key Lookup` оператор предоставляет функцию поиска закладок. `Clustered Index Seek` является логическим и физическим оператором.|  
|![Значок оператора Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Значок оператора Clustered Index Update")|`Clustered Index Update`|`Clustered Index Update` Оператор обновляет входные строки в кластеризованном индексе, указанном в `Argument` столбце. Если имеется предикат WHERE:(), обновляются только те строки, которые соответствуют этому предикату. При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. При наличии предиката DEFINE:() перечисляются значения, определенные данным оператором. Ссылки на эти значения могут присутствовать в предложении SET или в любом месте внутри данного оператора либо внутри данного запроса. `Clustered Index Update` является логическим и физическим оператором.|  
|![Значок оператора Collapse](../../2014/database-engine/media/collapse-32x.gif "Значок оператора Collapse")|`Collapse`|Оператор `Collapse` оптимизирует процедуру обновления. При выполнении она может быть разбита (оператором `Split`) на операции удаления и вставки. `Argument` Столбец содержит предложение Group By:(), которое задает список ключевых столбцов. Если обработчик запросов встречает смежные строки, удаляющие и вставляющие одни и те же значения ключей, он заменяет эти отдельные операции на одну, более эффективную операцию обновления. `Collapse` является логическим и физическим оператором.|  
|![Просмотр индекса columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Просмотр индекса columnstore")|`Columnstore Index Scan`|`Columnstore Index Scan` Оператор сканирует индекс columnstore, указанный в `Argument` столбце плана выполнения запроса.|  
|![Значок оператора Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Значок оператора Compute Scalar")|`Compute Scalar`|`Compute Scalar` Оператор вычисляет выражение для получения вычисляемого скалярного значения. Затем эту величину можно вернуть пользователю или сослаться на нее в каком-либо запросе, а также выполнить эти действия одновременно. Примерами одновременного использования этих возможностей являются предикаты фильтра или соединения. `Compute Scalar` является логическим и физическим оператором.<br /><br /> `Compute Scalar`операторы, которые отображаются в Showplan, созданных с помощью SET STATISTICS XML, `RunTimeInformation` могут не содержать элемент. (В графических инструкциях Showplan **Фактическое число строк**, **Фактическое число повторных привязок**и **Фактическое число сбросов на начало** могут отсутствовать в окне **Свойства** , если в среде **выбран параметр** Включить действительный план выполнения [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].) В данном случае это означает, что хотя эти операторы были использованы в скомпилированном плане запроса, их работа выполнялась другими операторами в исполняемом плане запроса. Кроме того, обратите внимание, что число запусков на выходе Showplan, сформированных SET STATISTICS PROFILE, равно сумме повторных привязок и сбросов на начало в инструкциях Showplan, сформированных XML SET STATISTICS.|  
|![Значок оператора Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Значок оператора Concatenation")|**Объединения**|Оператор **Concatenation** просматривает несколько входов, возвращая каждую просмотренную строку. Оператор**Concatenation** обычно используется для реализации конструкции [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. Физический оператор **Concatenation** имеет два или более входов и один выход. Он копирует строки из первого входного потока в выходной поток и повторяет эту операцию для каждого дополнительного входного потока. **Concatenation** является как логическим, так и физическим оператором.|  
|![Значок оператора Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Значок оператора Constant Scan")|`Constant Scan`|`Constant Scan` Оператор вводит в запрос одну или несколько строк констант. `Compute Scalar` Оператор часто используется после, `Constant Scan` чтобы добавить столбцы в строку, созданную `Constant Scan` оператором.|  
|![Значок элемента языка Convert (ядро СУБД)](../../2014/database-engine/media/convert-32x.gif "Значок элемента языка Convert (ядро СУБД)")|`Convert`|Оператор `Convert` автоматически преобразует скалярные данные из одного типа в другой. `Convert` является элементом языка.|  
|Отсутствуют|`Cross Join`|Оператор `Cross Join` соединяет каждую строку из первого (верхнего) входного параметра с каждой строкой второго (нижнего) входного параметра. `Cross Join` является логическим оператором.|  
|![Значок оператора курсора Cursor Catchall](../../2014/database-engine/media/cursor-catch-all.gif "Значок оператора курсора Cursor Catchall")|`catchall`|Общий значок отображается в тех случаях, когда с помощью логики, управляющей графическими планами визуализации, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существует три общих значка захвата: синий (итераторы), оранжевый (курсоры) и зеленый (элементы языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|Отсутствуют|**Курсор**|Логический и физический операторы **Cursor** предназначены для описания того, каким образом выполняются операции запроса или обновления с участием курсора. Физические операторы описывают алгоритм физической реализации обработки курсора, например использование курсора, управляемого набором ключей. Каждый шаг выполнения курсора соответствует физическому оператору. Логические операторы описывают свойства курсора, например доступность курсора только для чтения.<br /><br /> Логические операторы включают в себя Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary и Synchronous.<br /><br /> Физические операторы включают в себя Dynamic, Fetch Query, Keyset, Population Query, Refresh Query и Snapshot.|  
|![Значок элемента языка Declare](../../2014/database-engine/media/declare-32x.gif "Значок элемента языка Declare")|`Declare`|`Declare` Оператор выделяет локальную переменную в плане запроса. `Declare` является элементом языка.|  
|![Значок оператора Delete (ядро СУБД)](../../2014/database-engine/media/delete-32x.gif "Значок оператора Delete (ядро СУБД)")|`Delete`|`Delete` Оператор удаляет из строк объекта, которые соответствуют необязательному предикату в `Argument` столбце.|  
|![Значок оператора Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Значок оператора Delete Scan")|`Deleted Scan`|Оператор `Deleted Scan` просматривает удаленную таблицу в триггере.|  
|Отсутствуют|`Distinct`|Оператор `Distinct` удаляет дубликаты из набора строк или из коллекции значений. `Distinct` является логическим оператором.|  
|Отсутствуют|`Distinct Sort`|`Distinct Sort` Логический оператор сканирует входные данные, удаляя дубликаты и сортировку по столбцам, указанным в ПРЕДИКАТЕ DISTINCT ORDER BY `Argument` :() столбца. `Distinct Sort` является логическим оператором.|  
|![Значок оператора параллелизма Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Значок оператора параллелизма Distribute Streams")|**Distribute Streams**|Оператор **Distribute Streams** используется только в параллельных планах запросов. Оператор **Distribute Streams** преобразует один входящий поток записей в несколько выходящих потоков. Формат и содержимое записей не меняются. Каждая запись из входящего потока направляется в один из выходящих потоков. Данный оператор автоматически сохраняет в выходящих потоках относительный порядок входящих записей. Чтобы определить выходящий поток, в который попадет запись из входящего потока, обычно используется хэширование.<br /><br /> Если выходные данные секционированы, то `Argument` столбец содержит ПРЕДИКАТ PARTITION COLUMNS:() и столбцы секционирования. Оператор**Distribute Streams** является логическим оператором.|  
|![Значок оператора Dynamic Cursor](../../2014/database-engine/media/dynamic-32x.gif "Значок оператора Dynamic Cursor")|`Dynamic`|В операторе `Dynamic` используется курсор, который отслеживает изменения, внесенные другими.|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")|**Eager Spool**|Оператор **безотлагательной буферизации** принимает все входные данные, сохраняя каждую строку в скрытом временном объекте `tempdb` , хранящемся в базе данных. Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Eager Spool** выполняет построение своего буферного файла «жадным» способом: когда родительский оператор буфера запрашивает первую строку, оператор буферизации принимает все строки из своего входного оператора и сохраняет ее в буфер. **Eager Spool** — логический оператор.|  
|![Значок оператора Fetch Query Cursor](../../2014/database-engine/media/fetch-query-32x.gif "Значок оператора Fetch Query Cursor")|`Fetch Query`|Оператор `Fetch Query` извлекает строки, если выборка выполняется в курсоре.|  
|![Значок оператора Filter (ядро СУБД)](../../2014/database-engine/media/filter-32x.gif "Значок оператора Filter (ядро СУБД)")|**Filter**|Оператор **Filter** просматривает входные данные, возвращая только те строки, которые соответствуют критерию фильтра (предикату) `Argument` , который отображается в столбце.|  
|Отсутствуют|`Flow Distinct`|Логический оператор `Flow Distinct` просматривает входные данные и удаляет дубликаты. В то время `Distinct` как оператор принимает все входные данные до получения выходных данных, оператор **фловдистинкт** возвращает каждую строку, как получено от входных данных (если эта строка не является дубликатом, в этом случае она отбрасывается).|  
|None|`Full Outer Join`|Логический оператор `Full Outer Join` возвращает каждую строку, удовлетворяющую предикату соединения из первого (верхнего) входа и соединенную с каждой строкой из второго (нижнего) входа. Он также возвращает строки из:<br /><br /> первых входных данных, не имеющих соответствий во вторых входных данных;<br /><br /> вторых входных данных, не имеющих соответствий в первых входных данных.<br /><br /> <br /><br /> Вход, не содержащий совпадающих значений, возвращается как значение NULL. `Full Outer Join` является логическим оператором.|  
|![Значок оператора параллелизма Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Значок оператора параллелизма Gather Streams")|**Gather Streams**|Оператор **Gather Streams** используется только в планах параллельных запросов. Оператор **Gather Streams** считывает несколько входных потоков и создает один выходной поток записей, комбинируя все входные потоки. Формат и содержимое записей не меняются. Если этот оператор сохраняет порядок, все входные потоки должны быть упорядочены. Если выходные данные упорядочены, `Argument` столбец содержит ПРЕДИКАТ Order By:() и имена упорядоченных столбцов. **Gather Streams** — логический оператор.|  
|![Значок оператора Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Значок оператора Hash Match")|`Hash Match`|Оператор `Hash Match` строит хэш-таблицу при помощи вычисления хэш-значения для каждой строки из своих входных данных. В `Argument` столбце появится предикат Hash:() со списком столбцов, используемых для создания хэш-значения. Затем для каждой тестовой строки (если возможно) он вычисляет хэш-значение (с использованием той же хэш-функции) и осуществляет поиск совпадений по хэш-таблице. При наличии остаточного предиката (определяемого ОСТАТКом предиката `Argument` :() в столбце) Этот предикат должен также удовлетворять требованиям, чтобы строки считались совпадающими. Поведение зависит от выполняемой логической операции.<br /><br /> Для любых соединений используйте первую (верхнюю) входную строку с целью построения хэш-таблицы, а вторую (нижнюю) входную строку — для тестирования хэш-таблицы. Выходные данные совпадают (или не совпадают) в зависимости от типа соединения. Если несколько операций соединения используют один и тот же столбец соединения, эти операции группируются в хэш-группу.<br /><br /> Для операторов Distinct и Aggregate используйте входные данные с целью построения хэш-таблицы (удаляя дубликаты и вычисляя любые статистические выражения). Когда хэш-таблица будет построена, просмотрите таблицу и выведите все записи.<br /><br /> Для оператора Union используйте первую входную строку с целью построения хэш-таблицы (с удалением дубликатов). Используйте вторую входную строку (в которой не должно быть дубликатов) с целью тестирования хэш-таблицы, возвращения всех строк, не имеющих совпадений, затем просмотрите хэш-таблицу для возвращения всех записей.<br /><br /> <br /><br /> `Hash Match` является физическим оператором.|  
|![Значок элемента языка If](../../2014/database-engine/media/if-32x.gif "Значок элемента языка If")|`If`|Оператор `If` выполняет условную обработку в зависимости от значения выражения. `If` является элементом языка.|  
|None|`Inner Join`|Логический оператор `Inner Join` возвращает каждую строку, которая удовлетворяет соединению первого (верхнего) входа со вторым (нижним).|  
|![Значок оператора Insert (ядро СУБД)](../../2014/database-engine/media/insert-32x.gif "Значок оператора Insert (ядро СУБД)")|`Insert`|`Insert` Логический оператор вставляет каждую строку из входных данных в объект, указанный в `Argument` столбце. Соответствующим физическим оператором является `Table Insert`, `Index Insert` или `Clustered Index Insert`.|  
|![Значок оператора Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Значок оператора Inserted Scan")|**Inserted Scan**|Оператор **Inserted Scan** просматривает таблицу **inserted** . **Inserted Scan** является логическим и физическим оператором.|  
|![Значок элемента языка Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Значок элемента языка Intrinsic")|`Intrinsic`|Оператор `Intrinsic` вызывает внутреннюю функцию [!INCLUDE[tsql](../includes/tsql-md.md)]. `Intrinsic` является элементом языка.|  
|![Значок оператора Iterator Catchall](../../2014/database-engine/media/iterator-catch-all.gif "Значок оператора Iterator Catchall")|`Iterator`|Общий значок `Iterator` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")|`Key Lookup`|`Key Lookup` Оператор является уточняющим запросом закладки для таблицы с кластеризованным индексом. `Argument` Столбец содержит имя кластеризованного индекса и ключ кластеризации, используемый для поиска строки в кластеризованном индексе. `Key Lookup`всегда сопровождается `Nested Loops` оператором. Если в `Argument` столбце ПРИСУТСТВУЕТ предложение WITH упреждающей выборки, обработчик запросов определил, что оптимально использовать асинхронную предварительную выборку (упреждающее чтение) при поиске закладок в кластеризованном индексе.<br /><br /> Использование `Key Lookup` оператора в плане запроса указывает на то, что запрос может выиграть от настройки производительности. Например, производительность запроса можно повысить, добавив покрывающий индекс.|  
|![Значок оператора курсора Keyset](../../2014/database-engine/media/keyset-32x.gif "Значок оператора курсора Keyset")|`Keyset`|Оператор `Keyset` использует курсор, для которого видимыми являются обновления, но не вставки, выполненные другими.|  
|![Значок Language Element Catchall](../../2014/database-engine/media/language-construct-catch-all.gif "Значок Language Element Catchall")|`Language Element`|Общий значок `Language Element` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")|**Lazy Spool**|Логический оператор **Lazy spool** сохраняет каждую строку из входных данных в скрытом временном объекте, `tempdb` хранящемся в базе данных. Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Lazy Spool** производит отложенное построение своего буферного файла: каждый раз, когда родительский оператор буфера запрашивает строку, оператор буферизации получает строку из своего входного оператора и сохраняет ее в буфер, а не обрабатывает все строки сразу. Lazy Spool — это логический оператор.|  
|None|`Left Anti Semi Join`|Оператор `Left Anti Semi Join` возвращает каждую строку первого (верхнего) входа, для которой нет соответствующей строки во втором (нижнем) входе. Если в `Argument` столбце нет предиката объединения, каждая строка будет соответствующей строкой. `Left Anti Semi Join` является логическим оператором.|  
|Отсутствуют|`Left Outer Join`|Оператор `Left Outer Join` возвращает строки, удовлетворяющие условию соединения первого (верхнего) входа со вторым (нижним) входом. Он также возвращает строки из первого входа, не имеющие соответствия строкам во втором входе. Строки, не имеющие соответствия строкам во втором входе, возвращаются как значения NULL. Если в `Argument` столбце нет предиката объединения, каждая строка будет соответствующей строкой. `Left Outer Join` является логическим оператором.|  
|Отсутствуют|`Left Semi Join`|Оператор `Left Semi Join` возвращает каждую строку из первого (верхнего) входа, для которой есть соответствующая строка во втором (нижнем) входе. Если в `Argument` столбце нет предиката объединения, каждая строка будет соответствующей строкой. `Left Semi Join` является логическим оператором.|  
|![Значок оператора Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Значок оператора Log Row Scan")|`Log Row Scan`|Оператор `Log Row Scan` просматривает журнал транзакций. `Log Row Scan` является логическим и физическим оператором.|  
|![Значок оператора Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Значок оператора Merge Interval")|`Merge Interval`|Оператор `Merge Interval` проводит слияние нескольких (возможно, пересекающихся) интервалов и возвращает минимальный, непересекающийся интервал, который затем используется для поиска записей индекса. Этот оператор обычно появляется над одним или несколькими `Compute Scalar` операторами `Constant Scan` над операторами, которые создают интервалы (представленные в виде столбцов в строке), объединяемые этим оператором. `Merge Interval` является логическим и физическим оператором.|  
|![Значок оператора Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Значок оператора Merge Join")|**Merge Join**|Оператор **Merge Join** выполняет внутреннее соединение, левое внешнее соединение, левое полусоединение, левое антиполусоединение, правое внешнее соединение, правое полусоединение, правое антиполусоединение, а также логические операции соединения.<br /><br /> В `Argument` столбце Оператор объединения **слиянием** содержит предикат MERGE:(), если операция выполняет соединение "один ко многим", или ПРЕДИКАТ Merge:() "многие ко многим", если операция выполняет соединение "многие ко многим". `Argument` Столбец также содержит список столбцов с разделителями-запятыми, используемых для выполнения операции. Оператор **Merge Join** требует наличия двух входных значений, отсортированных в соответствующих столбцах, что можно сделать с помощью вставки явных операций сортировки в план запроса. Соединение слиянием особенно эффективно в случаях, когда явной сортировки не требуется, например, когда в базе данных имеется подходящий индекс сбалансированного дерева или когда порядок сортировки может использоваться для нескольких операций вроде соединения слиянием или группирования со сведением. **Merge Join** является физическим.|  
|![Значок оператора Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Значок оператора Nested Loops")|`Nested Loops`|Оператор `Nested Loops` выполняет логические операции внутреннего соединения, левого внешнего соединения, левого полусоединения и антилевого полусоединения. При соединениях вложенными циклами выполняется поиск во внутренней таблице каждой строки внешней таблицы, обычно с помощью индекса. На основании предполагаемых затрат обработчик запросов определяет, сортировать ли внешние входные данные, чтобы улучшить сосредоточенность поиска по индексу во внутренней таблице. Все строки, которые соответствуют (необязательным) предикату `Argument` в столбце, возвращаются в зависимости от выполняемой логической операции. `Nested Loops` является физическим оператором.|  
|![Значок оператора Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Значок оператора Nonclustered Index Delete")|`Nonclustered Index Delete`|`Nonclustered Index Delete` Оператор удаляет входные строки из некластеризованного индекса, указанного в `Argument` столбце. `Nonclustered Index Delete` является физическим оператором.|  
|![Значок оператора Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Значок оператора Nonclustered Index Insert")|`Index Insert`|`Index Insert` Оператор вставляет строки из входных данных в некластеризованный индекс, указанный в `Argument` столбце. В столбце `Argument` также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. `Index Insert` является физическим оператором.|  
|![Значок оператора Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Значок оператора Nonclustered Index Scan")|`Index Scan`|`Index Scan` Оператор получает все строки из некластеризованного индекса, указанного в `Argument` столбце. Если в `Argument` столбце появляется необязательный предикат WHERE:(), возвращаются только те строки, которые соответствуют предикату. `Index Scan` является логическим и физическим оператором.|  
|![Значок оператора Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Значок оператора Nonclustered Index Seek")|`Index Seek`|Оператор `Index Seek` использует возможности поиска по индексам для получения строк из некластеризованного индекса. `Argument` Столбец содержит имя используемого некластеризованного индекса. Он также содержит предикат SEEK:(). Подсистема хранилища использует этот индекс для обработки только строк, удовлетворяющих предикату SEEK:(). При необходимости может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:() (при этом не используются индексы). Если `Argument` столбец содержит предложение ORDERED, обработчик запросов определил, что строки должны возвращаться в том порядке, в котором они были отсортированы в некластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища производит поиск индекса оптимальным способом (что не гарантирует сортировки выходных данных). Сохранение сортировки в выводе может оказаться менее эффективным, чем возврат неупорядоченного вывода. `Index Seek` является логическим и физическим оператором.|  
|![Значок оператора Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Значок оператора Nonclustered Index Spool")|**Index Spool**|Физический оператор **Index Spool** содержит предикат SEEK:() в `Argument` столбце. Оператор **Index Spool** сканирует свои входные строки, помещая копии каждой строки в скрытый файл очереди (хранящийся в `tempdb` базе данных и существующий только в течение времени существования запроса), и создает некластеризованный индекс для строк. Это позволяет использовать поддерживаемый индексами механизм поиска для вывода только строк, отвечающих требованиям предиката SEEK:(). Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь.|  
|![Значок оператора Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Значок оператора Nonclustered Index Update")|`Nonclustered Index Update`|`Nonclustered Index Update` Физический оператор обновляет строки входных данных в некластеризованном индексе, указанном в `Argument` столбце. При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. `Nonclustered Index Update` является физическим оператором.|  
|![Значок оператора Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Значок оператора Online Index Insert")|**Online Index Insert**|Физический оператор **Online Index Insert** указывает, что операции создания, изменения и удаления индекса выполняются в сети. То есть данные базовых таблиц по-прежнему доступны для пользователей во время операции с индексом.|  
|Отсутствуют|`Parallelism`|`Parallelism` Оператор выполняет логические операции потоков распределения, сбора потоков и повторного секционирования. `Argument` Столбцы могут содержать ПРЕДИКАТ PARTITION COLUMNS:() с разделенным запятыми списком столбцов, для которых выполняется секционирование. `Argument` Столбцы также могут содержать ПРЕДИКАТ Order By:(), в котором перечислены столбцы для сохранения порядка сортировки во время секционирования. `Parallelism` является физическим оператором.<br /><br /> Примечание. Если запрос был скомпилирован как параллельный, но во время выполнения он выполняется как последовательный, то выходные данные инструкции Showplan, формируемые SET STATISTICS XML или с помощью параметра **Включить действительный план выполнения** в [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , не будут содержать `RunTimeInformation` элемент для `Parallelism` оператора. В выходных данных «SET STATISTICS PROFILE» фактическое количество строк и фактическое число выполнений для `Parallelism` оператора отображаются нулями. При возникновении любого из этих условий это означает `Parallelism` , что оператор использовался только во время компиляции запроса, а не в плане запроса времени выполнения. Обратите внимание, что иногда планы параллельных запросов выполняются последовательно, если сервер выполняет большое количество параллельных запросов.|  
|![Значок оператора Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Значок оператора Parameter Table Scan")|`Parameter Table Scan`|Оператор `Parameter Table Scan` просматривает таблицу, переданную как параметр текущего запроса. Обычно он применяется для запросов INSERT из хранимой процедуры. `Parameter Table Scan` является логическим и физическим оператором.|  
|Отсутствуют|**Partial Aggregate**|Оператор**Partial Aggregate** используется в параллельных планах. Он применяется в статистической функции к максимальному числу входных строк, чтобы избежать записи на диск (сброса на диск). `Hash Match`является единственным физическим оператором (итератором), реализующим агрегирование секций. **Partial Aggregate** является логическим оператором.|  
|![Значок оператора курсора Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Значок оператора курсора Population Query")|`Population Query`|Оператор `Population Query` заполняет рабочую таблицу курсора при его открытии.|  
|![Значок оператора курсора Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Значок оператора курсора Refresh Query")|`Refresh Query`|Оператор `Refresh Query` выбирает текущие данные для строк из буфера выборки.|  
|![Значок оператора Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Значок оператора Remote Delete")|`Remote Delete`|Оператор `Remote Delete` удаляет входные строки удаленного объекта. `Remote Delete` является логическим и физическим оператором.|  
|![Оператор Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "Оператор Showplan Remote Index Seek")|**Remote Index Scan**|Оператор **Remote Index Scan** просматривает удаленный индекс, указанный в столбце Argument. **Remote Index Scan** является логическим и физическим оператором.|  
|![Оператор Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "Оператор Showplan Remote Index Seek")|**Remote Index Seek**|Оператор **Remote Index Seek** использует возможности поиска объекта удаленного индекса, чтобы получить строки. `Argument` Столбец содержит имя используемого удаленного индекса и предикат SEEK:(). **Remote Index Seek** является логическим физическим оператором.|  
|![Значок оператора Remote insert](../../2014/database-engine/media/remote-insert-32x.gif "Значок оператора Remote insert")|**Remote Insert**|Оператор **Remote Insert** вставляет входные строки в удаленный объект. **Remote Insert** является логическим и физическим оператором.|  
|![Значок оператора Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Значок оператора Remote Query")|`Remote Query`|Оператор `Remote Query` отправляет запрос удаленному источнику. Текст запроса, отправленного на удаленный сервер, отображается в `Argument` столбце. `Remote Query` является логическим и физическим оператором.|  
|![Значок оператора Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Значок оператора Remote Scan")|`Remote Scan`|Оператор `Remote Scan` позволяет удаленно просматривать необходимые объекты. Имя удаленного объекта отображается в `Argument` столбце. `Remote Scan` является логическим и физическим оператором.|  
|![Значок оператора Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Значок оператора Remote Update")|`Remote Update`|Оператор `Remote Update` обновляет входные строки удаленного объекта. `Remote Update` является логическим и физическим оператором.|  
|![Значок оператора параллелизма Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Значок оператора параллелизма Repartition Streams")|**Repartition Streams**|Оператор **Repartition Streams** собирает несколько потоков и создает несколько потоков записей. Формат и содержимое записей не меняются. Если оптимизатор запросов использует фильтр по битовым картам, то число строк в выходном потоке сокращается. Каждая запись из входного потока помещается в один выходной поток. Если оператор настроен для сохранения порядка, то все входные потоки упорядочиваются и сливаются в несколько упорядоченных выходных потоков. Если выходные данные секционированы, `Argument` столбец содержит ПРЕДИКАТ PARTITION COLUMNS:() и столбцы секционирования. Если выходные данные упорядочены, `Argument` столбец содержит ПРЕДИКАТ Order By:() и упорядоченные столбцы. **Repartition Streams** — это логический оператор. Он используется только в параллельных планах запроса.|  
|![Значок элемента языка Result](../../2014/database-engine/media/result-32x.gif "Значок элемента языка Result")|`Result`|Оператор `Result` представляет собой данные, возвращенные в конце плана запроса. Обычно он является корневым элементом инструкции Showplan. `Result` является элементом языка.|  
|![Значок оператора RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Значок оператора RID Lookup")|`RID Lookup`|Оператор `RID Lookup` осуществляет поиск закладки в куче при помощи заданного идентификатора строки. `Argument` Столбец содержит метку закладки, используемую для поиска строки в таблице, и имя таблицы, в которой выполняется поиск строки. Оператор `RID Lookup` всегда сопровождается оператором NESTED LOOP JOIN. `RID Lookup` является физическим оператором. Дополнительные сведения о поиске закладок см. в разделе[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)на веб-узле MSDN в блоге SQL Server.|  
|Отсутствуют|`Right Anti Semi Join`|Оператор `Right Anti Semi Join` выводит каждую строку второго (нижнего) входного множества, для которой не существует соответствующей строки в первом (верхнем) входном множестве. Соответствующая строка определяется как строка, удовлетворяющая предикату в `Argument` столбце (если предикат не существует, каждая строка является совпадающей строкой). `Right Anti Semi Join` является логическим оператором.|  
|Отсутствуют|`Right Outer Join`|Оператор `Right Outer Join` возвращает каждую строку, которая удовлетворяет соединению второго (нижнего) входа с первым (верхним). Она также возвращает все строки из второго входа, для которых нет совпадений в первом, соединяя их со значением NULL. Если в `Argument` столбце нет предиката объединения, каждая строка будет соответствующей строкой. `Right Outer Join` является логическим оператором.|  
|Отсутствуют|`Right Semi Join`|Оператор `Right Semi Join` возвращает каждую строку из второго (нижнего) потока входных данных, если имеется соответствующая строка в первом (нижнем) потоке входных данных. Если в `Argument` столбце нет предиката объединения, каждая строка будет соответствующей строкой. `Right Semi Join` является логическим оператором.|  
|![Значок оператора Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Значок оператора Row Count Spool")|**Row Count Spool**|Оператор **Row Count Spool** просматривает входные данные, подсчитывая число представленных строк и возвращая такое же количество строк, очищенных от данных. Этот оператор используется, когда необходимо проверить существование строк, а не наличие в них данных. Например, если `Nested Loops` оператор выполняет левую операцию объединения, а предикат Join применяется к внутренним входным данным, то в верхней части внутреннего ввода `Nested Loops` оператора может быть помещено количество строк в очереди. Затем `Nested Loops` оператор может определить, сколько строк выводится с помощью очереди строк Count (поскольку фактические данные с внутренней стороны не требуются), чтобы определить, следует ли возвращать внешнюю строку. Оператор**Row Count Spool** — это физический оператор.|  
|![Значок оператора Segment](../../2014/database-engine/media/segment-32x.gif "Значок оператора Segment")|**Segment**|**Segment** является физическим и логическим оператором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Эти столбцы отображаются в виде аргументов оператора **Segment** . Затем оператор выводит по одному сегменту за раз.|  
|Отсутствуют|`Segment Repartition`|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`. Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`. `Branch Repartition` и `Segment Repartition` являются логическими операторами.|  
|![Значок оператора Sequence](../../2014/database-engine/media/sequence-32x.gif "Значок оператора Sequence")|`Sequence`|Оператор `Sequence` выполняет планы широкого обновления. Практически он выполняет каждый вход по очереди (сверху вниз). Каждый вход обычно является обновлением отдельного объекта. Он возвращает лишь строки, полученные из последнего (нижнего) входа. `Sequence` является логическим и физическим оператором.|  
|![Значок оператора Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Значок оператора Sequence Project")|`Sequence Project`|Оператор `Sequence Project` добавляет столбцы для выполнения вычислений над упорядоченным набором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Затем оператор выводит по одному сегменту за раз. Эти столбцы отображаются как аргументы оператора `Sequence Project`. `Sequence Project` является логическим и физическим оператором.|  
|![Значок оператора курсора Snapshot](../../2014/database-engine/media/snapshot-32x.gif "Значок оператора курсора Snapshot")|**Моментальный снимок**|Оператор **Snapshot** создает курсор, который не видит изменений, сделанных другими курсорами.|  
|![Значок оператора Sort](../../2014/database-engine/media/sort-32x.gif "Значок оператора Sort")|`Sort`|`Sort` Оператор сортирует все входящие строки. `Argument` Столбец содержит ПРЕДИКАТ Order By:(), если в этой операции удаляются дубликаты, или ПРЕДИКАТ Order By:() с разделенным запятыми списком столбцов. Столбцы имеют префикс со значением ASC, если они сортируются по возрастанию, или значением DESC, если сортируются по убыванию. `Sort` является логическим и физическим оператором.|  
|![Значок оператора Split](../../2014/database-engine/media/split-32x.gif "Значок оператора Split")|`Split`|`Split` Оператор используется для оптимизации обработки обновлений. Он разбивает каждую операцию обновления на операции удаления и вставки. `Split` является логическим и физическим оператором.|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "Значок оператора Spool")|**Spool**|Оператор **spool** сохраняет промежуточный результат запроса в `tempdb` базе данных.|  
|![Значок оператора Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Значок оператора Stream Aggregate")|`Stream Aggregate`|Оператор `Stream Aggregate` группирует строки в один или несколько столбцов и вычисляет одно или несколько агрегатных выражений, возвращенных запросом. Выход этого оператора может быть использован последующими операторами запроса, возвращен клиенту или то и другое. Оператору `Stream Aggregate` необходимы входные данные, упорядоченные по группируемым столбцам. Оптимизатор использует перед этим оператором оператор `Sort`, если данные не были ранее отсортированы оператором `Sort` или используется упорядоченный поиск или просмотр в индексе. В инструкции SHOWPLAN_ALL или графическом плане выполнения в [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], столбцы в ПРЕДИКАТЕ Group By перечислены в `Argument` столбце, а статистические выражения перечислены в столбце **определенные значения** . `Stream Aggregate` является физическим оператором.|  
|![Значок оператора Switch](../../2014/database-engine/media/switch-32x.gif "Значок оператора Switch")|**Параметр**|Оператор**Switch** представляет собой особый тип итератора объединения, который имеет *n* входов. Выражение связывается с каждым оператором **Switch** . В зависимости от возвращаемого значения выражения (между 0 и *n*-1) оператор **Switch** копирует соответствующий входной поток в выходной поток. В частности, оператор **Switch** применяется при реализации планов запроса, содержащих быстрые курсоры прямого направления с такими операторами, как **TOP** . **Switch** является и логическим, и физическим оператором.|  
|![Значок оператора Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Значок оператора Table Delete")|`Table Delete`|`Table Delete` Физический оператор удаляет строки из таблицы, указанной в `Argument` столбце плана выполнения запроса.|  
|![Значок оператора Table insert](../../2014/database-engine/media/table-insert-32x.gif "Значок оператора Table Insert")|`Table Insert`|`Table Insert` Оператор вставляет строки из входных данных в таблицу, указанную в `Argument` столбце плана выполнения запроса. В столбце `Argument` также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. Если оператор `Table Insert` не имеет потомков для вставки значений, то вставленная строка берется из самого оператора вставки. `Table Insert` является физическим оператором.|  
|![Оператор Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Оператор Table Merge")|**Table Merge**|Оператор **Table Merge** применяет поток данных слияния к куче. Оператор удаляет, обновляет или вставляет строки в таблицу, указанную в `Argument` столбце оператора. Фактическая операция зависит от значения столбца **Action** во время выполнения, указанного в `Argument` столбце оператора. **Table Merge** является физическим оператором.|  
|![Значок оператора Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Значок оператора Table Scan")|`Table Scan`|`Table Scan` Оператор получает все строки из таблицы, указанной в `Argument` столбце плана выполнения запроса. Если в `Argument` столбце ПРИСУТСТВУЕТ предикат WHERE:(), возвращаются только те строки, которые соответствуют предикату. `Table Scan` является логическим и физическим оператором.|  
|![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Значок оператора Table Spool")|**Table Spool**|Оператор **Table Spool** просматривает входную таблицу и помещает копию каждой строки в скрытую буферную таблицу, которая находится в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) и существует только в течение времени жизни запроса. Если оператор перематывает (например, `Nested Loops` оператор), но не требуется повторная привязка, то вместо повторного сканирования входных данных используется очередь. **Table Spool** является физическим оператором.|  
|![Значок оператора Table Update](../../2014/database-engine/media/table-update-32x.gif "Значок оператора Table Update")|`Table Update`|`Table Update` Физический оператор обновляет входные строки в таблице, указанной в `Argument` столбце плана выполнения запроса. Предикат SET:() определяет значение для каждого обновляемого столбца. Эти значения могут быть упомянуты в предложении SET или в другом месте в этом операторе, а также в каком-либо другом месте в рамках запроса.|  
|![Значок оператора Table-Valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Значок оператора Table-Valued Function")|**Возвращающая табличное значение функция**|Оператор **Table-valued Function** вычисляет функцию с табличным значением (языка [!INCLUDE[tsql](../includes/tsql-md.md)] или среды CLR) и сохраняет строки результата в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) . Когда родительские итераторы запрашивают строки, возвращающая **табличное значение функция** возвращает `tempdb`строки из.<br /><br /> Запросы, вызывающие функции с табличным значением, формируют планы запросов с итератором **Table-valued Function** . **Функция с табличным значением** может вычисляться с различными значениями параметров:<br /><br /> **Модуль чтения функции с табличным значением XML** принимает большой двоичный объект XML как параметр и возвращает набор строк, представляющий узлы XML в том же порядке, что и в документе XML. Другие параметры могут ограничивать возвращаемые XML-узлы подмножеством XML-документа.<br /><br /> **Модуль чтения функции с табличным значением XML с фильтром XPath** — это специальный тип **модуля чтения функции с табличным значением XML** , ограничивающий результат узлами XML, соответствующими выражению XPath.<br /><br /> <br /><br /> Оператор**Table-valued Function** — это логический и физический оператор.|  
|![Значок оператора Top](../../2014/database-engine/media/top-32x.gif "Значок оператора Top")|**Вверх**|Оператор **Top** просматривает входные данные и возвращает только указанное число или процент строк, выбранных, возможно, на основе порядка сортировки. `Argument` Столбец может содержать список столбцов, которые проверяются на наличие связей. Планируется использовать оператор **Top** для соблюдения ограничений на число строк. **Top** — это логический и физический оператор. **Top** — это логический и физический оператор.|  
|Отсутствуют|**Top N Sort**|**Первые n сортировок** похожи на `Sort` итератор, за исключением того, что требуются только первые *n* строк, а не весь результирующий набор. Для небольших значений *N*ядро выполнения запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пытается выполнить операцию сортировки полностью в памяти. Для больших значений *N*ядро выполнения запросов использует более общий способ сортировки, в котором *N* не является параметром.|  
|![Значок расширенного оператора (UDX)](../../2014/database-engine/media/udx-32x.gif "Значок расширенного оператора (UDX)")|`UDX`|Расширенные операторы (UDX) реализуют часть операций XQuery и XPath в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Все операторы UDX являются и логическими, и физическими операторами.<br /><br /> Расширенный оператор (UDX) `FOR XML` используется для сериализации реляционных наборов строк, которые он получает на входе, в представление XML в одном столбце BLOB в единственной строке на выходе. Это статистический оператор XML, учитывающий порядок данных.<br /><br /> Расширенный оператор (UDX) `XML SERIALIZER` — это статистический оператор XML, учитывающий порядок данных. Он получает на входе строки, представляющие XML-узлы или скаляры XQuery в порядке, соответствующем XML-документу, и выдает сериализованный XML BLOB в единственном XML-столбце единственной строки вывода.<br /><br /> Расширенный оператор (UDX) `XML FRAGMENT SERIALIZER` является особым видом оператора `XML SERIALIZER`, использующимся для обработки входных строк, представляющих фрагменты XML, вставляемые в расширении вставки данных XQuery.<br /><br /> Расширенный оператор (UDX) `XQUERY STRING` вычисляет строковое значение XQuery из входных строк, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими скаляр XQuery, содержащий строковое значение входа.<br /><br /> Расширенный оператор (UDX) `XQUERY LIST DECOMPOSER` является оператором декомпозиции списка XQuery. Для каждой входной строки, представляющей собой узел XML, он создает одну или несколько строк, представляющих скаляр XQuery, содержащий значение элемента списка, если входные данные имеют тип списка XSD.<br /><br /> Расширенный оператор (UDX) `XQUERY DATA` определяет значение функции XQuery fn:data() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:data()**.<br /><br /> Расширенный оператор `XQUERY CONTAINS` определяет значение функции XQuery fn:contains() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:contains()**.<br /><br /> Расширенный оператор `UPDATE XML NODE` обновляет XML-узел в расширении изменения данных XQuery Replace в методе **Modify ()** для типа XML.|  
|Отсутствуют|**Union**|Оператор **Union** просматривает несколько входов, выводя каждую просмотренную строку и удаляя дубликаты. **Union** — это логический оператор.|  
|![Значок оператора Update (ядро СУБД)](../../2014/database-engine/media/update-32x.gif "Значок оператора Update (ядро СУБД)")|`Update`|`Update` Оператор обновляет каждую строку из входных данных в объекте, указанном в `Argument` столбце плана выполнения запроса. `Update` является логическим оператором. Операторы `Table Update`, `Index Update` или `Clustered Index Update` являются физическими.|  
|![Значок элемента языка While](../../2014/database-engine/media/while-32x.gif "Значок элемента языка While")|`While`|Оператор `While` реализует цикл while языка [!INCLUDE[tsql](../includes/tsql-md.md)]. `While` является элементом языка.|  
|![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Значок оператора Table Spool")|`Window Spool`|Оператор `Window Spool` расширяет каждую строку в набор строк, представляющий связанное с ним окно. В запросе предложение OVER определяет окно в наборе результатов запроса, а оконная функция затем вычисляет значения для каждой строки в окне. `Window Spool` является логическим и физическим оператором.|  
  
  
