---
title: Справочник по логическим и физическим операторам Showplan | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 99d305034989f0fdd2f9ca65dae9cef7d0881c2c
ms.sourcegitcommit: c18fadce27f330e1d4f36549414e5c84ba2f46c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/02/2018
ms.locfileid: "37160635"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Справочник по логическим и физическим операторам Showplan
  Операторы описывают, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет запрос или инструкцию языка DML. Оптимизатор запросов использует операторы для построения плана запроса, чтобы создать результат, заданный в запросе, или произвести операцию, указанную в инструкции DML. План запроса — это дерево физических операторов. Можно просмотреть план запроса с помощью инструкций SET SHOWPLAN, параметров графического плана выполнения в среде [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]и классов событий SQL Server Profiler Showplan.  
  
 Операторы классифицируются как логические и физические.  
  
 **Логические операторы**  
 Логические операторы описывают операции реляционной алгебры, используемые для обработки инструкции. Другими словами, логические операторы описывают на концептуальном уровне, какие действия следует совершить.  
  
 **Физические операторы**  
 Физические операторы реализуют действия, описанные логическими операторами. Каждый физический оператор является объектом или процедурой, выполняющей операцию. Например, некоторые физические операторы обращаются к столбцам и строкам таблицы, индекса или представления. Другие физические операторы выполняют другие операции, такие как вычисления, статистическая обработка, проверка целостности данных или соединения. Физическим операторам соответствует их стоимость.  
  
 Физические операторы производят инициализацию, собирают данные и закрываются. Если формулировать более конкретно, физический оператор может ответить на вызов трех следующих методов.  
  
-   **Init()**. Метод **Init()** заставляет физический оператор инициализировать себя и подготовить все необходимые структуры данных. Физический оператор может получать много вызовов **Init()** , хотя обычно получает лишь один.  
  
-   **GetNext()**. Метод **GetNext()** заставляет физический оператор получить первую или последующую строку данных. Физический оператор может получить много вызовов **GetNext()** или не получить ни одного.  
  
-   **Close()**. При вызове метода **Close()** физический оператор выполняет некоторые действия по очистке и завершает свою работу. Физический оператор получает только один вызов **Close()** .  
  
 Метод **GetNext()** возвращает одну строку данных, а число его вызовов отображается значением **ActualRows** в выводе инструкции Showplan, который формируется с использованием инструкций SET STATISTICS PROFILE ON или SET STATISTICS XML ON. Дополнительные сведения об этих параметрах SET см. в разделах [SET STATISTICS PROFILE (Transact-SQL)](/sql/t-sql/statements/set-statistics-profile-transact-sql) и [SET STATISTICS XML (Transact-SQL)](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Счетчики **ActualRebinds** и **ActualRewinds**, которые появляются в выводе инструкции Showplan, указывают на число вызовов метода **Init()**. Если оператор не находится внутри цикла соединения, **ActualRebinds** равняется одному, а **ActualRewinds** нулю. Если оператор находится внутри цикла соединения, сумма числа повторных привязок и сбросов на начало должна равняться количеству строк, обработанных снаружи цикла. Повторная привязка значит, что изменился один и более связанный параметр соединения, и внутреннюю часть нужно пересчитать. Сброс на начало значит, что не изменился ни один из связанных параметров и можно вновь использовать прежний внутренний результирующий набор.  
  
 Счетчики**ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, который произведен с использованием инструкции SET STATISTICS XML ON. Они заполнены только для **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, и  **Функция с табличным** операторы. **ActualRebinds** и **ActualRewinds** могут быть заполнены также для `Assert` и **фильтра** операторов при **StartupExpression** атрибут имеет значение TRUE.  
  
 Когда счетчики **ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, их значения сравнимы со значениями **EstimateRebinds** и **EstimateRewinds**. Когда они отсутствуют, оценочное число строк (**EstimateRows**) сравнимо с действительным числом строк (**ActualRows**). Обратите внимание, что действительный графический вывод Showplan отображает нули для действительных повторных привязок и сбросов на начало, когда те отсутствуют.  
  
 Связанный счетчик **ActualEndOfScans**доступен только в том случае, когда вывод инструкции Showplan производится с помощью инструкции SET STATISTICS XML ON. Всякий раз, когда физический оператор достигает конца потока данных, этот счетчик увеличивается на единицу. Физический оператор может достигать конца своего потока данных ни одного, один или несколько раз. Как и в случае с повторными привязками и сбросами на начало, число окончаний просмотров может превышать единицу только в том случае, если оператор находится внутри цикла соединения. Количество окончаний просмотров должно быть меньше или равно сумме количеств повторных привязок и сбросов на начало.  
  
## <a name="mapping-physical-and-logical-operators"></a>Сопоставление физических и логических операторов  
 Оптимизатор запросов создает план запроса в виде дерева логических операторов. После этого оптимизатор запросов выбирает наиболее эффективный физический оператор для каждого логического. Оптимизатор запросов использует подход, основанный на стоимости, чтобы определить, с помощью какого физического оператора будет реализован логический.  
  
 Обычно логическую операцию можно реализовать с помощью нескольких физических операторов. Однако в редких случаях физический оператор может реализовывать несколько логических операций.  
  
## <a name="operator-descriptions"></a>Описание оператора  
 Этот раздел содержит описания логических и физических операторов.  
  
|Значок графического плана выполнения|Оператор Showplan|Описание|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|Оператор `Aggregate` вычисляет выражения с функциями MIN, MAX, SUM, COUNT или AVG. Оператор `Aggregate` может быть логическим или физическим.|  
|![Значок оператора Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "значок оператора Arithmetic Expression")|`Arithmetic Expression`|Оператор `Arithmetic Expression` вычисляет новое значение на основе существующих значений в строке. `Arithmetic Expression` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Значок оператора Assert](../../2014/database-engine/media/assert-32x.gif "значок оператора Assert")|`Assert`|`Assert` Оператор проверяет условие. Например, этот оператор проверяет целостность ссылок или гарантирует, что скалярный вложенный запрос возвращает одну строку. Для каждой входной строки `Assert` оператор вычисляет выражение в `Argument` столбец плана выполнения. Если значением этого выражения является NULL, строка передается через оператор `Assert` и выполнение запроса продолжается. При значении этого выражения, отличном от NULL, будет выдана соответствующая ошибка. `Assert` Оператор является физическим оператором.|  
|![Значок элемента языка Assign](../../2014/database-engine/media/assign-32.gif "значок элемента языка Assign")|`Assign`|`Assign` Оператор присваивает переменной значение выражения или константы. `Assign` является элементом языка.|  
|None|`Asnyc Concat`|`Asnyc Concat` Оператор используется только в удаленных запросах (распределенных запросах). Он имеет *n* дочерних узлов и один родительский узел. Обычно некоторые дочерние узлы являются удаленными компьютерами, участвующими в распределенном запросе. `Asnyc Concat` проблемы `open()` вызовы все дочерние объекты одновременно, а затем применяет к каждому дочернему. Для каждого бита, равного 1 `Async Concat` отправляет выходные строки родительскому узлу по запросу.|  
|![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "значок оператора Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует `Bitmap` оператор для реализации битовой фильтрации в планах параллельных запросов. Фильтрация по битовым маскам повышает скорость выполнения запросов, исключая строки, которые не могут производить соединенные записи, до передачи строк другим операторам, например `Parallelism` оператор. Фильтр по битовым картам использует компактное представление набора значений из таблицы, находящейся в одной части дерева операторов, для фильтрации строк из другой таблицы, находящейся в другой части дерева. Если сразу удалять ненужные строки в запросе, последующие операторы работают с меньшим количеством строк, тем самым повышая общую производительность. Оптимизатор определяет, достаточно ли избирательна битовая маска, чтобы быть полезной, и в каких операторах применить фильтр. `Bitmap` является физическим оператором.|  
|![Значок оператора Bitmap](../../2014/database-engine/media/bitmap-32x.gif "значок оператора Bitmap")|`Bitmap Create`|Оператор `Bitmap Create` появляется на выходе инструкции Showplan, в которой строятся битовые маски. `Bitmap Create` является логическим оператором.|  
|![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "значок оператора Bookmark Lookup")|`Bookmark Lookup`|`Bookmark Lookup` Оператор производит по закладке (Идентификатору строки или ключу кластеризации), для поиска соответствующей строки в таблице или кластеризованном индексе. `Argument` Столбец содержит метку закладки, предназначенную для поиска строки в таблице или кластеризованном индексе. `Argument` Столбец также содержит имя таблицы или кластеризованного индекса, в котором производится поиск. Если присутствует предложение WITH PREFETCH в `Argument` столбца, обработчик запросов определяет, что он является оптимальным решением при поиске закладки в таблице или кластеризованном индексе будет применение асинхронной упреждающей выборки (упреждающего чтения).<br /><br /> `Bookmark Lookup` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. Вместо этого функцию поиска закладок обеспечивают операторы `Clustered Index Seek` и `RID Lookup`. Оператор `Key Lookup` также выполняет данные функции.|  
|None|`Branch Repartition`|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`. Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`. `Branch Repartition` и `Segment Repartition` являются логическими операторами.|  
|None|`Broadcast`|`Broadcast` имеет один дочерний и *n* родительских узлов. `Broadcast` рассылает входные строки нескольким получателям по требованию. Каждый пользователь получает полный набор строк. Например, если все получатели являются элементами хэш-соединения, то будет создано *n* копий хэш-таблиц.|  
|![Значок оператора Build Hash](../../2014/database-engine/media/build-hash.gif "значок оператора Build Hash")|`Build Hash`|Указывает сборку хэш-таблицы пакета для индекса columnstore, оптимизированного для памяти xVelocity.|  
|None|`Cache`|`Cache` — Это специализированная версия **Spool** оператор. Он сохраняет только одну строку данных. `Cache` является логическим оператором. `Cache` не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Значок оператора Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "значок оператора Clustered Index Delete")|`Clustered Index Delete`|Оператор `Clustered Index Delete` удаляет строки из кластеризованного индекса, заданного в столбце Argument плана выполнения запроса. Если предиката WHERE :() присутствует в столбце Argument затем только строки, удовлетворяющие предикату, удаляются.`Clustered Index Delete` является физическим оператором.|  
|![Значок оператора Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "значок оператора Clustered Index Insert")|`Clustered Index Insert`|Оператор `Clustered Index Insert` инструкции Showplan вставляет строки со своего входа в кластеризованный индекс, указанный в столбце Argument. В столбце Argument также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. Если `Clustered Index Insert` не имеет потомков для вставки значений, то вставленная строка берется из `Insert` самого оператора.`Clustered Index Insert` является физическим оператором.|  
|![Оператор Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "оператор Clustered Index Merge")|**Clustered Index Merge**|Оператор **Clustered Index Merge** применяет поток данных слияния к кластеризованному индексу. Оператор удаляет, обновляет или вставляет строки из кластеризованного индекса, заданного в `Argument` столбце оператора. Фактически выполненная операция зависит от значения среды выполнения из **действие** столбец, указанный в `Argument` столбце оператора. **Clustered Index Merge** является физическим.|  
|![Значок оператора Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "значок оператора Clustered Index Scan")|`Clustered Index Scan`|Оператор `Clustered Index Scan` сканирует кластеризованный индекс, заданный в столбце Argument плана выполнения запроса. При наличии необязательного предиката WHERE:() возвращаются только строки, удовлетворяющие предикату. Если столбец Argument содержит предложение ORDERED, обработчик запросов требует, чтобы выходные данные строк были возвращены в порядке, в соответствии с которым они были отсортированы в кластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск в индексе оптимальным способом, без обязательной сортировки выходных данных. `Clustered Index Scan` является логическим и физическим оператором.|  
|![Значок оператора Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "значок оператора Clustered Index Seek")|`Clustered Index Seek`|Оператор `Clustered Index Seek` использует возможности поиска по индексам для получения строк из кластеризованного индекса. `Argument` Столбец содержит имя используемого кластеризованного индекса и ПРЕДИКАТ :(). Подсистема хранилища использует этот индекс для обработки только тех строк, которые удовлетворяют данному предикату SEEK:(). Также может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:(), но это не является обязательным и не использует индексы для завершения процесса.<br /><br /> Если `Argument` столбца содержит предложение ORDERED, обработчик запросов определил, что строки необходимо возвращать в том порядке, в котором отсортировал кластеризованный индекс их. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск индекса оптимальным способом, без обязательной сортировки выходных данных. Сохранять порядок выходных данных является менее эффективным, чем формировать несортированные выходные данные. При указании ключевого слова LOOKUP выполняется поиск закладок. В [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях `Key Lookup` оператор обеспечивает функцию поиска закладок. `Clustered Index Seek` является логическим и физическим оператором.|  
|![Значок оператора Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "значок оператора Clustered Index Update")|`Clustered Index Update`|`Clustered Index Update` Оператор обновляет входные строки кластеризованного индекса, заданного в `Argument` столбца. Если предиката WHERE :() присутствует, только те строки, которые удовлетворяют данному предикату обновляются. При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. При наличии предиката DEFINE:() перечисляются значения, определенные данным оператором. Ссылки на эти значения могут присутствовать в предложении SET или в любом месте внутри данного оператора либо внутри данного запроса. `Clustered Index Update` является логическим и физическим оператором.|  
|![Значок оператора Collapse](../../2014/database-engine/media/collapse-32x.gif "значок оператора Collapse")|`Collapse`|Оператор `Collapse` оптимизирует процедуру обновления. При выполнении, она может быть разбита (с помощью `Split` оператор) на операции удаления и вставки. `Argument` Столбец содержит группы :() предложение, определяющее список ключевых столбцов. Если обработчик запросов встречает смежные строки, удаляющие и вставляющие одни и те же значения ключей, он заменяет эти отдельные операции на одну, более эффективную операцию обновления. `Collapse` является логическим и физическим оператором.|  
|![Просмотр индекса columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Просмотр индекса columnstore")|`Columnstore Index Scan`|`Columnstore Index Scan` Оператор просматривает индекс columnstore, заданный в `Argument` столбец плана выполнения запроса.|  
|![Значок оператора Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "значок оператора Compute Scalar")|`Compute Scalar`|`Compute Scalar` Оператор вычисляет выражение и выдает вычисляемую скалярную величину. Затем эту величину можно вернуть пользователю или сослаться на нее в каком-либо запросе, а также выполнить эти действия одновременно. Примерами одновременного использования этих возможностей являются предикаты фильтра или соединения. `Compute Scalar` является логическим и физическим оператором.<br /><br /> `Compute Scalar` операторы, которые отображаются в инструкциях Showplan, сформированных SET STATISTICS XML может не содержать `RunTimeInformation` элемент. (В графических инструкциях Showplan **Фактическое число строк**, **Фактическое число повторных привязок**и **Фактическое число сбросов на начало** могут отсутствовать в окне **Свойства** , если в среде **выбран параметр** Включить действительный план выполнения [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].) В данном случае это означает, что хотя эти операторы были использованы в скомпилированном плане запроса, их работа выполнялась другими операторами в исполняемом плане запроса. Кроме того, обратите внимание, что число запусков на выходе Showplan, сформированных SET STATISTICS PROFILE, равно сумме повторных привязок и сбросов на начало в инструкциях Showplan, сформированных XML SET STATISTICS.|  
|![Значок оператора Concatenation](../../2014/database-engine/media/concatenation-32x.gif "значок оператора Concatenation")|**Concatenation**|Оператор **Concatenation** просматривает несколько входов, возвращая каждую просмотренную строку. Оператор**Concatenation** обычно используется для реализации конструкции [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. Физический оператор **Concatenation** имеет два или более входов и один выход. Он копирует строки из первого входного потока в выходной поток и повторяет эту операцию для каждого дополнительного входного потока. **Concatenation** является как логическим, так и физическим оператором.|  
|![Значок оператора Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "значок оператора Constant Scan")|`Constant Scan`|`Constant Scan` Оператор вводит в запрос один или несколько константных строк. Объект `Compute Scalar` оператор часто используется после `Constant Scan` для добавления столбцов в строки, получаемой `Constant Scan` оператор.|  
|![Значок элемента языка Convert (ядро СУБД)](../../2014/database-engine/media/convert-32x.gif "значок элемента языка Convert (ядро СУБД)")|`Convert`|Оператор `Convert` автоматически преобразует скалярные данные из одного типа в другой. `Convert` является элементом языка.|  
|None|`Cross Join`|Оператор `Cross Join` соединяет каждую строку из первого (верхнего) входного параметра с каждой строкой второго (нижнего) входного параметра. `Cross Join` является логическим оператором.|  
|![Значок оператора Cursor Catchall](../../2014/database-engine/media/cursor-catch-all.gif "значок оператора Cursor Catchall")|`catchall`|Общий значок отображается в тех случаях, когда с помощью логики, управляющей графическими планами визуализации, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существует три общих значка захвата: синий (итераторы), оранжевый (курсоры) и зеленый (элементы языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Курсор**|Логический и физический операторы **Cursor** предназначены для описания того, каким образом выполняются операции запроса или обновления с участием курсора. Физические операторы описывают алгоритм физической реализации обработки курсора, например использование курсора, управляемого набором ключей. Каждый шаг выполнения курсора соответствует физическому оператору. Логические операторы описывают свойства курсора, например доступность курсора только для чтения.<br /><br /> Логические операторы включают в себя Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary и Synchronous.<br /><br /> Физические операторы включают в себя Dynamic, Fetch Query, Keyset, Population Query, Refresh Query и Snapshot.|  
|![Значок элемента языка Declare](../../2014/database-engine/media/declare-32x.gif "значок элемента языка Declare")|`Declare`|`Declare` Оператор выделяет локальную переменную в плане запроса. `Declare` является элементом языка.|  
|![Значок оператора Delete (ядро СУБД)](../../2014/database-engine/media/delete-32x.gif "значок оператора Delete (ядро СУБД)")|`Delete`|`Delete` Оператор удаляет строки из объекта, которые удовлетворяют необязательному предикату в `Argument` столбца.|  
|![Значок оператора Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "значок оператора Delete Scan")|`Deleted Scan`|Оператор `Deleted Scan` просматривает удаленную таблицу в триггере.|  
|None|`Distinct`|Оператор `Distinct` удаляет дубликаты из набора строк или из коллекции значений. `Distinct` является логическим оператором.|  
|None|`Distinct Sort`|`Distinct Sort` Логический оператор просматривает входные данные, удаляя дубликаты и сортируя данные по столбцам, указанным в DISTINCT ORDER BY :() предикате `Argument` столбца. `Distinct Sort` является логическим оператором.|  
|![Значок оператора параллелизма Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "значок оператора параллелизма Distribute Streams")|**Distribute Streams**|Оператор **Distribute Streams** используется только в параллельных планах запросов. Оператор **Distribute Streams** преобразует один входящий поток записей в несколько выходящих потоков. Формат и содержимое записей не меняются. Каждая запись из входящего потока направляется в один из выходящих потоков. Данный оператор автоматически сохраняет в выходящих потоках относительный порядок входящих записей. Чтобы определить выходящий поток, в который попадет запись из входящего потока, обычно используется хэширование.<br /><br /> Если выход является секционированным, а затем `Argument` столбец содержит предикат PARTITION COLUMNS :() и столбцы секционирования. Оператор**Distribute Streams** является логическим оператором.|  
|![Значок оператора Dynamic Cursor](../../2014/database-engine/media/dynamic-32x.gif "значок оператора Dynamic Cursor")|`Dynamic`|`Dynamic` Оператор используется курсор, который можно увидеть все изменения, выполненные другими пользователями.|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "значок оператора Spool")|**Eager Spool**|**Eager Spool** оператор принимает весь ввод, сохраняя каждую строку в скрытый временный объект в `tempdb` базы данных. Если оператор сбрасывается на начало (например, с `Nested Loops` оператор), но не требуется повторная привязка, буферизованные данные используется вместо буферизованные данные. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Eager Spool** выполняет построение своего буферного файла «жадным» способом: когда родительский оператор буфера запрашивает первую строку, оператор буферизации принимает все строки из своего входного оператора и сохраняет ее в буфер. **Eager Spool** — логический оператор.|  
|![Значок оператора Fetch Query Cursor](../../2014/database-engine/media/fetch-query-32x.gif "значок оператора Fetch Query Cursor")|`Fetch Query`|`Fetch Query` Оператор извлекает строки, если выборка выполняется курсоре.|  
|![Значок оператора Filter (ядро СУБД)](../../2014/database-engine/media/filter-32x.gif "значок оператора Filter (ядро СУБД)")|**Filter**|**Фильтра** оператор просматривает входные данные и возвращает только те строки, которые удовлетворяют критерию фильтрации (предикату), которое отображается в `Argument` столбца.|  
|None|`Flow Distinct`|`Flow Distinct` Логический оператор просматривает входные данные и удаляет дубликаты. Тогда как `Distinct` оператор использует все входные данные, прежде чем выдать выходные данные, **FlowDistinct** оператор возвращает каждую строку, полученную из входных данных (если строка не является дубликатом, в противном случае она не возвращается).|  
|None|`Full Outer Join`|`Full Outer Join` Логический оператор возвращает каждую строку, удовлетворяющую предикату соединения из первого (верхнего) входа и соединенную с каждой строкой из второго (нижнего) входа. Он также возвращает строки из:<br /><br /> первых входных данных, не имеющих соответствий во вторых входных данных;<br /><br /> вторых входных данных, не имеющих соответствий в первых входных данных.<br /><br /> <br /><br /> Вход, не содержащий совпадающих значений, возвращается как значение NULL. `Full Outer Join` является логическим оператором.|  
|![Значок оператора параллелизма Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "значок оператора параллелизма Gather Streams")|**Gather Streams**|Оператор **Gather Streams** используется только в планах параллельных запросов. Оператор **Gather Streams** считывает несколько входных потоков и создает один выходной поток записей, комбинируя все входные потоки. Формат и содержимое записей не меняются. Если этот оператор сохраняет порядок, все входные потоки должны быть упорядочены. Если в случае упорядоченного выхода, `Argument` столбец содержит предикат ORDER BY :() предиката и имена столбцов упорядочены. **Gather Streams** — логический оператор.|  
|![Значок оператора Hash Match](../../2014/database-engine/media/hash-match-32x.gif "значок оператора Hash Match")|`Hash Match`|Оператор `Hash Match` строит хэш-таблицу при помощи вычисления хэш-значения для каждой строки из своих входных данных. HASH предикат :() со списком столбцов, используемых для создания хэш-значение отображается в `Argument` столбца. Затем для каждой тестовой строки (если возможно) он вычисляет хэш-значение (с использованием той же хэш-функции) и осуществляет поиск совпадений по хэш-таблице. Если наличествует остаточный предикат (определенный посредством RESIDUAL :() в `Argument` столбца), также должны удовлетворять этому предикату для строк, чтобы считаться совпадающими. Поведение зависит от выполняемой логической операции.<br /><br /> Для любых соединений используйте первую (верхнюю) входную строку с целью построения хэш-таблицы, а вторую (нижнюю) входную строку — для тестирования хэш-таблицы. Выходные данные совпадают (или не совпадают) в зависимости от типа соединения. Если несколько операций соединения используют один и тот же столбец соединения, эти операции группируются в хэш-группу.<br /><br /> Для операторов Distinct и Aggregate используйте входные данные с целью построения хэш-таблицы (удаляя дубликаты и вычисляя любые статистические выражения). Когда хэш-таблица будет построена, просмотрите таблицу и выведите все записи.<br /><br /> Для оператора Union используйте первую входную строку с целью построения хэш-таблицы (с удалением дубликатов). Используйте вторую входную строку (в которой не должно быть дубликатов) с целью тестирования хэш-таблицы, возвращения всех строк, не имеющих совпадений, затем просмотрите хэш-таблицу для возвращения всех записей.<br /><br /> <br /><br /> `Hash Match` является физическим оператором.|  
|![Значок элемента языка If](../../2014/database-engine/media/if-32x.gif "значок элемента языка If")|`If`|`If` Оператор выполняет условную обработку в зависимости от выражения. `If` является элементом языка.|  
|None|`Inner Join`|`Inner Join` Логический оператор возвращает каждую строку, которая удовлетворяет соединению первого (верхнего) входа со вторым (нижним) входа.|  
|![Значок оператора Insert (ядро СУБД)](../../2014/database-engine/media/insert-32x.gif "значок оператора Insert (ядро СУБД)")|`Insert`|`Insert` Логический оператор вставляет строки из входного потока в объект, указанный в `Argument` столбца. Физическим оператором является `Table Insert`, `Index Insert`, или `Clustered Index Insert` оператор.|  
|![Значок оператора Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "значок оператора Inserted Scan")|**Inserted Scan**|Оператор **Inserted Scan** просматривает таблицу **inserted** . **Inserted Scan** является логическим и физическим оператором.|  
|![Значок элемента языка Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "значок элемента языка Intrinsic")|`Intrinsic`|`Intrinsic` Оператор вызывает внутреннюю [!INCLUDE[tsql](../includes/tsql-md.md)] функции. `Intrinsic` является элементом языка.|  
|![Значок оператора Iterator Catchall](../../2014/database-engine/media/iterator-catch-all.gif "значок оператора Iterator Catchall")|`Iterator`|Общий значок `Iterator` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Значок оператора Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "значок оператора Bookmark Lookup")|`Key Lookup`|`Key Lookup` Оператор осуществляет поиск закладки в таблице с кластеризованным индексом. `Argument` Столбец содержит имя кластеризованного индекса и ключ кластеризации, используемый для поиска строки в кластеризованном индексе. `Key Lookup` всегда сопровождается оператором `Nested Loops` оператор. Если присутствует предложение WITH PREFETCH в `Argument` столбца, обработчик запросов определяет, что он является оптимальным решением при поиске закладки в кластеризованном индексе будет применение асинхронной упреждающей выборки (упреждающего чтения).<br /><br /> Использование `Key Lookup` оператора в плане запроса указывает, что запрос может выиграть от настройки производительности. Например, производительность запроса можно повысить, добавив покрывающий индекс.|  
|![Значок оператора Keyset Cursor](../../2014/database-engine/media/keyset-32x.gif "значок оператора Keyset Cursor")|`Keyset`|Оператор `Keyset` использует курсор, для которого видимыми являются обновления, но не вставки, выполненные другими.|  
|![Значок элемента языка Catchall](../../2014/database-engine/media/language-construct-catch-all.gif "значок элемента языка Catchall")|`Language Element`|Общий значок `Language Element` отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "значок оператора Spool")|**Lazy Spool**|**Lazy Spool** логический оператор сохраняет все строки из входного потока в скрытом временном объекте, хранящиеся в `tempdb` базы данных. Если оператор сбрасывается на начало (например, с `Nested Loops` оператор), но не требуется повторная привязка, буферизованные данные используется вместо буферизованные данные. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Lazy Spool** производит отложенное построение своего буферного файла: каждый раз, когда родительский оператор буфера запрашивает строку, оператор буферизации получает строку из своего входного оператора и сохраняет ее в буфер, а не обрабатывает все строки сразу. Lazy Spool — это логический оператор.|  
|None|`Left Anti Semi Join`|Оператор `Left Anti Semi Join` возвращает каждую строку первого (верхнего) входа, для которой нет соответствующей строки во втором (нижнем) входе. Если присутствует предикат соединения отсутствует в `Argument` столбца, каждая строка является строкой соответствия. `Left Anti Semi Join` является логическим оператором.|  
|None|`Left Outer Join`|Оператор `Left Outer Join` возвращает строки, удовлетворяющие условию соединения первого (верхнего) входа со вторым (нижним) входом. Он также возвращает строки из первого входа, не имеющие соответствия строкам во втором входе. Строки, не имеющие соответствия строкам во втором входе, возвращаются как значения NULL. Если присутствует предикат соединения отсутствует в `Argument` столбца, каждая строка является строкой соответствия. `Left Outer Join` является логическим оператором.|  
|None|`Left Semi Join`|`Left Semi Join` Оператор возвращает каждую строку из первого (верхнего) входа, если имеется соответствующая строка во втором (нижнем) входе. Если присутствует предикат соединения отсутствует в `Argument` столбца, каждая строка является строкой соответствия. `Left Semi Join` является логическим оператором.|  
|![Значок оператора Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "значок оператора Log Row Scan")|`Log Row Scan`|`Log Row Scan` Оператор просматривает журнал транзакций. `Log Row Scan` является логическим и физическим оператором.|  
|![Значок оператора Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "значок оператора Merge Interval")|`Merge Interval`|`Merge Interval` Слияние нескольких (возможно, пересекающихся) интервалов и возвращает минимальный, непересекающийся интервал, который затем используется для поиска записей индекса. Этот оператор обычно проводит одного или нескольких `Compute Scalar` операторов относительно `Constant Scan` сформированных интервалов (представленных в виде столбцов в строке), этот оператор выполняет слияние. `Merge Interval` является логическим и физическим оператором.|  
|![Значок оператора Merge Join](../../2014/database-engine/media/merge-join-32x.gif "значок оператора Merge Join")|**Merge Join**|Оператор **Merge Join** выполняет внутреннее соединение, левое внешнее соединение, левое полусоединение, левое антиполусоединение, правое внешнее соединение, правое полусоединение, правое антиполусоединение, а также логические операции соединения.<br /><br /> В `Argument` столбце **Merge Join** оператор содержит предикат :() СЛИЯНИЯ, если операция исполняет соединение один ко многим, или МНОГИЕ-ко-МНОГИМ :() СЛИЯНИЯ предиката, если операция исполняет соединение многие ко многим. `Argument` Столбца также включает в себя разделенный запятыми список столбцов, используемых для выполнения операции. Оператор **Merge Join** требует наличия двух входных значений, отсортированных в соответствующих столбцах, что можно сделать с помощью вставки явных операций сортировки в план запроса. Соединение слиянием особенно эффективно в случаях, когда явной сортировки не требуется, например, когда в базе данных имеется подходящий индекс сбалансированного дерева или когда порядок сортировки может использоваться для нескольких операций вроде соединения слиянием или группирования со сведением. **Merge Join** является физическим.|  
|![Значок оператора Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "значок оператора Nested Loops")|`Nested Loops`|Оператор `Nested Loops` выполняет логические операции внутреннего соединения, левого внешнего соединения, левого полусоединения и антилевого полусоединения. При соединениях вложенными циклами выполняется поиск во внутренней таблице каждой строки внешней таблицы, обычно с помощью индекса. На основании предполагаемых затрат обработчик запросов определяет, сортировать ли внешние входные данные, чтобы улучшить сосредоточенность поиска по индексу во внутренней таблице. Любыми строками, удовлетворяющими необязательному предикату в `Argument` столбца возвращаются это возможно, в зависимости от выполняемой логической операции. `Nested Loops` является физическим оператором.|  
|![Значок оператора Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "значок оператора Nonclustered Index Delete")|`Nonclustered Index Delete`|`Nonclustered Index Delete` Оператор удаляет входные строки из некластеризованного индекса, указанного в `Argument` столбца. `Nonclustered Index Delete` является физическим оператором.|  
|![Значок оператора Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "значок оператора Nonclustered Index Insert")|`Index Insert`|`Index Insert` Оператор вставляет строки из входного потока в некластеризованный индекс, заданный в `Argument` столбца. `Argument` Столбец также содержит предиката SET :(), который указывает значение, задаваемое для каждого столбца. `Index Insert` является физическим оператором.|  
|![Значок оператора Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "значок оператора Nonclustered Index Scan")|`Index Scan`|`Index Scan` Оператор извлекает все строки из некластеризованного индекса, указанного в `Argument` столбца. Если необязательный :() предикат нахождение в `Argument` столбца, возвращаются только те строки, удовлетворяющие условиям предиката. `Index Scan` является логическим и физическим оператором.|  
|![Значок оператора Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "значок оператора Nonclustered Index Seek")|`Index Seek`|`Index Seek` Оператор использует поисковые возможности индексов для получения строк из некластеризованного индекса. `Argument` Столбец содержит имя используемого некластеризованного индекса. Он также содержит предикат SEEK:(). Подсистема хранилища использует этот индекс для обработки только строк, удовлетворяющих предикату SEEK:(). При необходимости может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:() (при этом не используются индексы). Если `Argument` столбца содержит предложение ORDERED, обработчик запросов определил, что строки должны возвращаться в порядке, в котором отсортированы в некластеризованном индексе их. Если предложение ORDERED отсутствует, подсистема хранилища производит поиск индекса оптимальным способом (что не гарантирует сортировки выходных данных). Сохранение сортировки в выводе может оказаться менее эффективным, чем возврат неупорядоченного вывода. `Index Seek` является логическим и физическим оператором.|  
|![Значок оператора Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "значок оператора Nonclustered Index Spool")|**Index Spool**|**Index Spool** физический оператор содержит предикат SEEK :() предиката в `Argument` столбца. **Index Spool** оператор сканирует входные строки, помещая каждую строку в скрытый файл буфера (хранящиеся в `tempdb` базы данных и существует только в течение времени жизни запроса) и создает для строк некластеризованный индекс. Это позволяет использовать поддерживаемый индексами механизм поиска для вывода только строк, отвечающих требованиям предиката SEEK:(). Если оператор сбрасывается на начало (например, с `Nested Loops` оператор), но не требуется повторная привязка, буферизованные данные используется вместо буферизованные данные.|  
|![Значок оператора Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "значок оператора Nonclustered Index Update")|`Nonclustered Index Update`|`Nonclustered Index Update` Физический оператор обновляет строки из входного потока в некластеризованный индекс, заданный в `Argument` столбца. При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. `Nonclustered Index Update` является физическим оператором.|  
|![Значок оператора Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "значок оператора Online Index Insert")|**Online Index Insert**|Физический оператор **Online Index Insert** указывает, что операции создания, изменения и удаления индекса выполняются в сети. То есть данные базовых таблиц по-прежнему доступны для пользователей во время операции с индексом.|  
|None|`Parallelism`|`Parallelism` Оператор выполняет потоков распространения, сбора и повторного секционирования логические операции. `Argument` Столбцы могут содержать предикат PARTITION COLUMNS :() предиката со списком секционируемых столбцов с разделителями запятыми. `Argument` Столбцы могут также содержать предикат ORDER BY :() предикат, содержащий список столбцов для сохранения порядка сортировки во время секционирования. `Parallelism` является физическим оператором.<br /><br /> Примечание: Если запрос был скомпилирован как параллельный, но во время выполнения запускается как последовательный, выходные данные Showplan, сформированные SET STATISTICS XML или с помощью **Включить действительный план выполнения** в диалоговом окне [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] не будет содержать `RunTimeInformation` элемент для `Parallelism` оператор. В выходных данных инструкции SET STATISTICS PROFILE подсчет действительного числа строк и фактическое количество выполнений будут равны нулю для `Parallelism` оператор. Любое из этих условий означает, что `Parallelism` оператор используется только во время компиляции запроса, а не в плане выполнения запроса. Обратите внимание, что иногда планы параллельных запросов выполняются последовательно, если сервер выполняет большое количество параллельных запросов.|  
|![Значок оператора Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "значок оператора Parameter Table Scan")|`Parameter Table Scan`|`Parameter Table Scan` Оператор просматривает таблицу, переданную как параметр текущего запроса. Обычно он применяется для запросов INSERT из хранимой процедуры. `Parameter Table Scan` является логическим и физическим оператором.|  
|None|**Partial Aggregate**|Оператор**Partial Aggregate** используется в параллельных планах. Он применяется в статистической функции к максимальному числу входных строк, чтобы избежать записи на диск (сброса на диск). `Hash Match` — Это единственный физический оператор (итератор), реализующий статистическую обработку секций. **Partial Aggregate** является логическим оператором.|  
|![Значок оператора Population Query Cursor](../../2014/database-engine/media/poulation-query-32x.gif "значок оператора Population Query Cursor")|`Population Query`|Оператор `Population Query` заполняет рабочую таблицу курсора при его открытии.|  
|![Значок оператора Refresh Query Cursor](../../2014/database-engine/media/refresh-query-32x.gif "значок оператора Refresh Query Cursor")|`Refresh Query`|Оператор `Refresh Query` выбирает текущие данные для строк из буфера выборки.|  
|![Значок оператора Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "значок оператора Remote Delete")|`Remote Delete`|`Remote Delete` Оператор удаляет входные строки удаленного объекта. `Remote Delete` является логическим и физическим оператором.|  
|![Оператор Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "оператор Showplan Remote Index Seek")|**Remote Index Scan**|Оператор **Remote Index Scan** просматривает удаленный индекс, указанный в столбце Argument. **Remote Index Scan** является логическим и физическим оператором.|  
|![Оператор Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "оператор Showplan Remote Index Seek")|**Remote Index Seek**|Оператор **Remote Index Seek** использует возможности поиска объекта удаленного индекса, чтобы получить строки. `Argument` Столбец содержит имя используемого удаленного индекса и ПРЕДИКАТ :(). **Remote Index Seek** является логическим физическим оператором.|  
|![Значок оператора Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "значок оператора Remote Insert")|**Remote Insert**|Оператор **Remote Insert** вставляет входные строки в удаленный объект. **Remote Insert** является логическим и физическим оператором.|  
|![Значок оператора Remote Query](../../2014/database-engine/media/remote-query-32x.gif "значок оператора Remote Query")|`Remote Query`|`Remote Query` Оператор отправляет запрос удаленному источнику. Текст запроса, отправленного удаленному серверу, выводится в `Argument` столбца. `Remote Query` является логическим и физическим оператором.|  
|![Значок оператора Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "значок оператора Remote Scan")|`Remote Scan`|`Remote Scan` Оператор просматривает удаленного объекта. Имя удаленного объекта появляется в `Argument` столбца. `Remote Scan` является логическим и физическим оператором.|  
|![Значок оператора Remote Update](../../2014/database-engine/media/remote-update-32x.gif "значок оператора Remote Update")|`Remote Update`|`Remote Update` Оператор обновляет входные строки удаленного объекта. `Remote Update` является логическим и физическим оператором.|  
|![Значок оператора параллелизма Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "значок оператора параллелизма Repartition Streams")|**Repartition Streams**|Оператор **Repartition Streams** собирает несколько потоков и создает несколько потоков записей. Формат и содержимое записей не меняются. Если оптимизатор запросов использует фильтр по битовым картам, то число строк в выходном потоке сокращается. Каждая запись из входного потока помещается в один выходной поток. Если оператор настроен для сохранения порядка, то все входные потоки упорядочиваются и сливаются в несколько упорядоченных выходных потоков. Если выход является секционированным, `Argument` столбец содержит предикат PARTITION COLUMNS :() и столбцы секционирования. Если в случае упорядоченного выхода, `Argument` столбец содержит предикате ORDER BY :() и упорядочиваемые столбцы. **Repartition Streams** — это логический оператор. Он используется только в параллельных планах запроса.|  
|![Значок элемента языка Result](../../2014/database-engine/media/result-32x.gif "значок элемента языка Result")|`Result`|`Result` Оператор — это данные, возвращенные в конце плана запроса. Обычно он является корневым элементом инструкции Showplan. `Result` является элементом языка.|  
|![Значок оператора RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "значок оператора RID Lookup")|`RID Lookup`|`RID Lookup` выполняет поиск закладок в куче с использованием заданного идентификатора строки (RID). `Argument` Столбец содержит метку закладки, предназначенную для поиска строки в таблице и имя таблицы, в котором производится поиск. Оператор `RID Lookup` всегда сопровождается оператором NESTED LOOP JOIN. `RID Lookup` является физическим оператором. Дополнительные сведения о поиске закладок см. в разделе[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)на веб-узле MSDN в блоге SQL Server.|  
|None|`Right Anti Semi Join`|`Right Anti Semi Join` Оператор выводит каждую строку второго (нижнего) входного соответствующей строки в первом (верхнем) входном не существует. Соответствующая строка определяется как строка, которая удовлетворяет предикату в `Argument` столбца (если предиката не существует, каждая строка является строкой соответствия). `Right Anti Semi Join` является логическим оператором.|  
|None|`Right Outer Join`|`Right Outer Join` Оператор возвращает каждую строку, которая удовлетворяет соединению второго (нижнего) входного параметра с каждой совпадающей строки из первого (верхнего) входного. Она также возвращает все строки из второго входа, для которых нет совпадений в первом, соединяя их со значением NULL. Если присутствует предикат соединения отсутствует в `Argument` столбца, каждая строка является строкой соответствия. `Right Outer Join` является логическим оператором.|  
|None|`Right Semi Join`|Оператор `Right Semi Join` возвращает каждую строку из второго (нижнего) потока входных данных, если имеется соответствующая строка в первом (нижнем) потоке входных данных. Если присутствует предикат соединения отсутствует в `Argument` столбца, каждая строка является строкой соответствия. `Right Semi Join` является логическим оператором.|  
|![Значок оператора Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "значок оператора Row Count Spool")|**Row Count Spool**|Оператор **Row Count Spool** просматривает входные данные, подсчитывая число представленных строк и возвращая такое же количество строк, очищенных от данных. Этот оператор используется, когда необходимо проверить существование строк, а не наличие в них данных. Например если `Nested Loops` оператор выполняет операцию левого полусоединения, а также предикат соединения применяется к внутренним входным данным, row count spool можно разместить выше внутреннего ввода из `Nested Loops` оператор. Затем `Nested Loops` оператор можно определить количество выходных строк оператора row count Spool (поскольку реальные данные с внутренней стороны не требуются) для определения, следует ли возвращать внешние строки. Оператор**Row Count Spool** — это физический оператор.|  
|![Значок оператора Segment](../../2014/database-engine/media/segment-32x.gif "значок оператора Segment")|**Segment**|**Segment** является физическим и логическим оператором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Эти столбцы отображаются в виде аргументов оператора **Segment** . Затем оператор выводит по одному сегменту за раз.|  
|None|`Segment Repartition`|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора `Parallelism` внутри отдельной области называются `Branch Repartition`. Итератор оператора `Parallelism` на границе двух таких областей называется `Segment Repartition`. `Branch Repartition` и `Segment Repartition` являются логическими операторами.|  
|![Значок оператора Sequence](../../2014/database-engine/media/sequence-32x.gif "значок оператора Sequence")|`Sequence`|`Sequence` Оператор выполняет планы широкого обновления. Практически он выполняет каждый вход по очереди (сверху вниз). Каждый вход обычно является обновлением отдельного объекта. Он возвращает лишь строки, полученные из последнего (нижнего) входа. `Sequence` является логическим и физическим оператором.|  
|![Значок оператора Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "значок оператора Sequence Project")|`Sequence Project`|`Sequence Project` Оператор добавляет столбцы для выполнения вычислений над упорядоченным набором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Затем оператор выводит по одному сегменту за раз. Эти столбцы отображаются как аргументы оператора `Sequence Project`. `Sequence Project` является логическим и физическим оператором.|  
|![Значок оператора Snapshot Cursor](../../2014/database-engine/media/snapshot-32x.gif "значок оператора Snapshot Cursor")|**Моментальный снимок**|Оператор **Snapshot** создает курсор, который не видит изменений, сделанных другими курсорами.|  
|![Значок оператора Sort](../../2014/database-engine/media/sort-32x.gif "значок оператора Sort")|`Sort`|`Sort` Оператор сортирует Входящие строки. `Argument` Столбец содержит DISTINCT ORDER BY :() предиката, если этой операции удаляются дубликаты, или предикат ORDER BY :() предиката, разделенных запятыми списком сортируемых столбцов. Столбцы имеют префикс со значением ASC, если они сортируются по возрастанию, или значением DESC, если сортируются по убыванию. `Sort` является логическим и физическим оператором.|  
|![Значок оператора Split](../../2014/database-engine/media/split-32x.gif "значок оператора Split")|`Split`|`Split` Оператор используется для оптимизации процесса обновления. Он разбивает каждую операцию обновления на операции удаления и вставки. `Split` является логическим и физическим оператором.|  
|![Значок оператора Spool](../../2014/database-engine/media/spool-32x.gif "значок оператора Spool")|**Spool**|**Spool** оператор сохраняет промежуточные результаты запроса к `tempdb` базы данных.|  
|![Значок оператора Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "значок оператора Stream Aggregate")|`Stream Aggregate`|`Stream Aggregate` Оператор группирует строки в один или несколько столбцов и вычисляет одно или несколько статистических выражений, возвращенных запросом. Выход этого оператора может быть использован последующими операторами запроса, возвращен клиенту или то и другое. Оператору `Stream Aggregate` необходимы входные данные, упорядоченные по группируемым столбцам. Оптимизатор использует перед этим оператором оператор `Sort`, если данные не были ранее отсортированы оператором `Sort` или используется упорядоченный поиск или просмотр в индексе. В инструкции SHOWPLAN_ALL или графическом плане выполнения в [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], столбцы в предикате GROUP BY перечисляются в `Argument` столбца и статистические выражения, перечислены в **Defined Values** столбца. `Stream Aggregate` является физическим оператором.|  
|![Значок оператора Switch](../../2014/database-engine/media/switch-32x.gif "значок оператора Switch")|**Параметр**|Оператор**Switch** представляет собой особый тип итератора объединения, который имеет *n* входов. Выражение связывается с каждым оператором **Switch** . В зависимости от возвращаемого значения выражения (между 0 и *n*-1) оператор **Switch** копирует соответствующий входной поток в выходной поток. В частности, оператор **Switch** применяется при реализации планов запроса, содержащих быстрые курсоры прямого направления с такими операторами, как **TOP** . **Switch** является и логическим, и физическим оператором.|  
|![Значок оператора Table Delete](../../2014/database-engine/media/table-delete-32x.gif "значок оператора Table Delete")|`Table Delete`|`Table Delete` Физический оператор удаляет строки из таблицы, указанной в `Argument` столбец плана выполнения запроса.|  
|![Значок оператора Table Insert](../../2014/database-engine/media/table-insert-32x.gif "значок оператора Table Insert")|`Table Insert`|`Table Insert` Оператор вставляет строки из входного потока в таблице, указанной в `Argument` столбец плана выполнения запроса. `Argument` Столбец также содержит предиката SET :(), который указывает значение, задаваемое для каждого столбца. Если `Table Insert` не имеет потомков для вставки значений, то вставленная строка берется из самого оператора вставки. `Table Insert` является физическим оператором.|  
|![Оператор Table Merge](../../2014/database-engine/media/table-merge-32x.gif "оператор Table Merge")|**Table Merge**|Оператор **Table Merge** применяет поток данных слияния к куче. Оператор удаляет, обновляет или вставляет строки в таблице, указанной в `Argument` столбце оператора. Фактически выполненная операция зависит от значения времени выполнения **действие** столбец, указанный в `Argument` столбце оператора. **Table Merge** является физическим оператором.|  
|![Значок оператора Table Scan](../../2014/database-engine/media/table-scan-32x.gif "значок оператора Table Scan")|`Table Scan`|`Table Scan` Оператор извлекает все строки из таблицы, указанной в `Argument` столбец плана выполнения запроса. Если предиката WHERE :() отображается в `Argument` столбца, возвращаются только те строки, удовлетворяющие условиям предиката. `Table Scan` является логическим и физическим оператором.|  
|![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "значок оператора Table Spool")|**Table Spool**|Оператор **Table Spool** просматривает входную таблицу и помещает копию каждой строки в скрытую буферную таблицу, которая находится в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) и существует только в течение времени жизни запроса. Если оператор сбрасывается на начало (например, с `Nested Loops` оператор), но не требуется повторная привязка, буферизованные данные используется вместо буферизованные данные. **Table Spool** является физическим оператором.|  
|![Значок оператора Table Update](../../2014/database-engine/media/table-update-32x.gif "значок оператора Table Update")|`Table Update`|`Table Update` Физический оператор обновляет входные строки в таблице, указанной в `Argument` столбец плана выполнения запроса. Предикат SET:() определяет значение для каждого обновляемого столбца. Эти значения могут быть упомянуты в предложении SET или в другом месте в этом операторе, а также в каком-либо другом месте в рамках запроса.|  
|![Значок оператора Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "значок оператора Table-valued Function")|**Table-valued Function**|Оператор **Table-valued Function** вычисляет функцию с табличным значением (языка [!INCLUDE[tsql](../includes/tsql-md.md)] или среды CLR) и сохраняет строки результата в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) . Когда родительские итераторы запрашивают эти строки **Table-valued Function** возвращает эти строки из `tempdb`.<br /><br /> Запросы, вызывающие функции с табличным значением, формируют планы запросов с итератором **Table-valued Function** . **Функция с табличным значением** может вычисляться с различными значениями параметров:<br /><br /> **Модуль чтения функции с табличным значением XML** принимает большой двоичный объект XML как параметр и возвращает набор строк, представляющий узлы XML в том же порядке, что и в документе XML. Другие параметры могут ограничивать возвращаемые XML-узлы подмножеством XML-документа.<br /><br /> **Модуль чтения функции с табличным значением XML с фильтром XPath** — это специальный тип **модуля чтения функции с табличным значением XML** , ограничивающий результат узлами XML, соответствующими выражению XPath.<br /><br /> <br /><br /> Оператор**Table-valued Function** — это логический и физический оператор.|  
|![Значок оператора Top](../../2014/database-engine/media/top-32x.gif "значок оператора Top")|**Top**|Оператор **Top** просматривает входные данные и возвращает только указанное число или процент строк, выбранных, возможно, на основе порядка сортировки. `Argument` Столбец может содержать список столбцов, которые проверяются на наличие связей. Планируется использовать оператор **Top** для соблюдения ограничений на число строк. **Top** — это логический и физический оператор. **Top** — это логический и физический оператор.|  
|None|**Top N Sort**|**TOP N Sort** аналогичен `Sort` итератора, за исключением того, что только первые *N* строк, а не весь результирующий набор. Для небольших значений *N*ядро выполнения запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пытается выполнить операцию сортировки полностью в памяти. Для больших значений *N*ядро выполнения запросов использует более общий способ сортировки, в котором *N* не является параметром.|  
|![Значок оператора Extended (UDX)](../../2014/database-engine/media/udx-32x.gif "значок оператора Extended (UDX)")|`UDX`|Расширенные операторы (UDX) реализуют часть операций XQuery и XPath в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Все операторы UDX являются и логическими, и физическими операторами.<br /><br /> Расширенный оператор (UDX) `FOR XML` используется для сериализации реляционных наборов строк его в представление XML в одном столбце BLOB в единственной строке на выходе. Это статистический оператор XML, учитывающий порядок данных.<br /><br /> Расширенный оператор (UDX) `XML SERIALIZER` — это статистический оператор XML, учитывающий порядок данных. Он получает на входе строки, представляющие XML-узлы или скаляры XQuery в порядке, соответствующем XML-документу, и выдает сериализованный XML BLOB в единственном XML-столбце единственной строки вывода.<br /><br /> Расширенный оператор (UDX) `XML FRAGMENT SERIALIZER` является особым видом оператора `XML SERIALIZER`, использующимся для обработки входных строк, представляющих фрагменты XML, вставляемые в расширении вставки данных XQuery.<br /><br /> Расширенный оператор (UDX) `XQUERY STRING` вычисляет строковое значение XQuery из входных строк, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими скаляр XQuery, содержащий строковое значение входа.<br /><br /> Расширенный оператор (UDX) `XQUERY LIST DECOMPOSER` является оператором декомпозиции списка XQuery. Для каждой входной строки, представляющей собой узел XML, он создает одну или несколько строк, представляющих скаляр XQuery, содержащий значение элемента списка, если входные данные имеют тип списка XSD.<br /><br /> Расширенный оператор (UDX) `XQUERY DATA` определяет значение функции XQuery fn:data() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:data()**.<br /><br /> Расширенный оператор `XQUERY CONTAINS` определяет значение функции XQuery fn:contains() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:contains()**.<br /><br /> Расширенный оператор `UPDATE XML NODE` обновляет узел XML в XQuery расширении замены модификации данных в **modify()** метод типа XML.|  
|None|**Union**|Оператор **Union** просматривает несколько входов, выводя каждую просмотренную строку и удаляя дубликаты. **Union** — это логический оператор.|  
|![Значок оператора Update (ядро СУБД)](../../2014/database-engine/media/update-32x.gif "значок оператора Update (ядро СУБД)")|`Update`|`Update` Оператор обновляет каждую строку из входного потока в объект, указанный в `Argument` столбец плана выполнения запроса. `Update` является логическим оператором. Операторы `Table Update`, `Index Update` или `Clustered Index Update` являются физическими.|  
|![Значок элемента языка While](../../2014/database-engine/media/while-32x.gif "значок элемента языка While")|`While`|`While` Реализует оператор [!INCLUDE[tsql](../includes/tsql-md.md)] цикла while. `While` является элементом языка|  
|![Значок оператора Table Spool](../../2014/database-engine/media/table-spool-32x.gif "значок оператора Table Spool")|`Window Spool`|Оператор `Window Spool` расширяет каждую строку в набор строк, представляющий связанное с ним окно. В запросе предложение OVER определяет окно в наборе результатов запроса, а оконная функция затем вычисляет значения для каждой строки в окне. `Window Spool` является логическим и физическим оператором.|  
  
  
