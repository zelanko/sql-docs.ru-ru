---
title: Регистрация определяемых пользователем типов в SQL Server | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
dev_langs:
- TSQL
helpviewer_keywords:
- UDTs [CLR integration], maintaining
- user-defined types [CLR integration], maintaining
- dependencies [CLR integration]
- deploying user-defined types [CLR integration]
- CurrencyConversion function
- user-defined types [CLR integration], deploying
- Transact-SQL deploying UDTs
- assemblies [CLR integration], user-defined types
- cross-database UDT support
- CREATE ASSEMBLY statement
- DROP TYPE statement
- Currency UDT
- CREATE TYPE statement
- registering user-defined types
- UDTs [CLR integration], deploying
- removing user-defined types
- user-defined types [CLR integration], registering
- ALTER ASSEMBLY statement
- UDTs [CLR integration], registering
- ADD FILE clause
ms.assetid: f7da3e92-e407-4f0b-b3a3-f214e442b37d
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 158f71abbe82a3b15b497ea8cbd6e74aec2ed6ae
ms.sourcegitcommit: 3da2edf82763852cff6772a1a282ace3034b4936
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/02/2018
ms.locfileid: "48216194"
---
# <a name="registering-user-defined-types-in-sql-server"></a>Регистрация определяемых пользователем типов в SQL Server
  Для использования определяемого пользователем типа (UDT) в [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], необходимо зарегистрировать его. Регистрация определяемого пользователем типа включает регистрацию сборки и создание типа в базе данных, в которой его нужно использовать. Определяемые пользователем типы находятся в одной базе данных и не могут использоваться в нескольких базах данных, пока идентичная сборка и определяемый пользователем тип не будут зарегистрированы в каждой базе данных. После регистрации сборки определяемого пользователем типа и создания типа этот тип можно использовать в [!INCLUDE[tsql](../../includes/tsql-md.md)] и клиентском коде. Дополнительные сведения об определяемых пользователем типах данных CLR см. в разделе [Определяемые пользователем типы данных CLR](clr-user-defined-types.md).  
  
## <a name="using-visual-studio-to-deploy-udts"></a>Использование среды Visual Studio для развертывания определяемых пользователем типов  
 Самым простым способом развертывания определяемого пользователем типа является использование среды [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Studio. Однако для более сложных сценариев развертывания и большей гибкости используется язык [!INCLUDE[tsql](../../includes/tsql-md.md)], как описано далее в этом разделе.  
  
 Для создания и развертывания определяемых пользователем типов с помощью среды Visual Studio выполните следующие шаги.  
  
1.  Создайте новый **базы данных** в проекте **Visual Basic** или **Visual C#** узлов языков программирования.  
  
2.  Добавьте ссылку на базу данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], содержащую определяемый пользователем тип.  
  
3.  Добавить **определяемого пользователем типа** класса.  
  
4.  Напишите код для реализации определяемого пользователем типа.  
  
5.  Из **построения** меню, выберите **развернуть**. Эта команда регистрирует сборку и создает тип в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
## <a name="using-transact-sql-to-deploy-udts"></a>Использование Transact-SQL для развертывания определяемых пользователем типов  
 Синтаксис CREATE ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] используется для регистрации сборки в базе данных, в которой требуется использование определяемого пользователем типа. Он хранится внутри системных таблиц базы данных, а во внешней файловой системе. Если определяемый пользователем тип зависит от внешних сборок, их тоже необходимо загрузить в базу данных. Инструкция CREATE TYPE используется для создания определяемого пользователем типа в базе данных, в которой он будет использоваться. Дополнительные сведения см. в разделе [CREATE ASSEMBLY &#40;Transact-SQL&#41; ](/sql/t-sql/statements/create-assembly-transact-sql) и [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).  
  
### <a name="using-create-assembly"></a>Использование инструкции CREATE ASSEMBLY  
 Инструкция CREATE ASSEMBLY регистрирует сборку в базе данных, в которой требуется использование определяемого пользователем типа. После регистрации сборки она не имеет зависимостей.  
  
 Создание нескольких версий одной сборки в одной базе данных не допускается. Однако возможно создание нескольких версий одной сборки, зависящих от культуры данной базы данных. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] разделяет несколько культурных версий сборки по разным именам, зарегистрированным в экземпляре [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе «Создание и использование сборок со строгими именами» пакета .NET Framework SDK.  
  
 Если инструкция CREATE ASSEMBLY выполняется с наборами разрешений SAFE или EXTERNAL_ACCESS, сборка проверяется на совместимость и безопасность типа. Если набор разрешений не указан, предполагается набор разрешений SAFE. Код с набором разрешений UNSAFE не проверяется. Дополнительные сведения о наборах разрешений сборки см. в разделе [Проектирование сборок](../../relational-databases/clr-integration/assemblies-designing.md).  
  
#### <a name="example"></a>Пример  
 Следующие [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку Point в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в **AdventureWorks** базы данных с набором разрешений SAFE. Если предложение WITH PERMISSION_SET не указано, сборка регистрируется с набором разрешений SAFE.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM '\\ShareName\Projects\Point\bin\Point.dll'   
WITH PERMISSION_SET = SAFE;  
```  
  
 Следующие [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкция регистрирует сборку с помощью *< assembly_bits >* аргумент в предложении FROM. Данное значение типа `varbinary` представляет файл в виде потока байтов.  
  
```  
USE AdventureWorks;  
CREATE ASSEMBLY Point  
FROM 0xfeac4 … 21ac78  
```  
  
### <a name="using-create-type"></a>Использование инструкции CREATE TYPE  
 После загрузки сборки в базу данных можно создать тип с помощью инструкции CREATE TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)]. Она добавляет тип в список доступных типов для этой базы данных. Тип имеет область базы данных и может использоваться только в той базе данных, в которой он был создан. Если определяемый пользователем тип уже существует в базе данных, то инструкция CREATE TYPE завершится с ошибкой.  
  
> [!NOTE]  
>  Синтаксис CREATE TYPE также используется для создания собственных псевдонимов типов данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и предназначен для замены процедуры `sp_addtype` при создании псевдонимов типов данных. Некоторые из дополнительных аргументов в синтаксисе CREATE TYPE служат для создания определяемых пользователем типов и неприменимы для создания псевдонимов типов данных (например базового типа).  
  
 Дополнительные сведения см. в разделе [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).  
  
#### <a name="example"></a>Пример  
 Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] создает тип `Point`. EXTERNAL NAME указывается с помощью двух частей синтаксиса именования *AssemblyName*. *UDTName*.  
  
```  
CREATE TYPE dbo.Point   
EXTERNAL NAME Point.[Point];  
```  
  
## <a name="removing-a-udt-from-the-database"></a>Удаление определяемого пользователем типа из базы данных  
 Инструкция DROP TYPE удаляет определяемый пользователем тип из текущей базы данных. После удаления определяемого пользователем типа можно инструкцией DROP ASSEMBLY удалить сборку из базы данных.  
  
 Инструкция DROP TYPE не выполняется в следующих ситуациях.  
  
-   Таблицы в базе данных, которые содержат столбцы, определенные с помощью определяемого пользователем типа.  
  
-   Функции, хранимые процедуры или триггеры, которые используют переменные или параметры определяемого пользователем типа и созданы в базе данных с помощью предложения WITH SCHEMABINDING.  
  
### <a name="example"></a>Пример  
 Следующая инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)] должна выполняться в следующем порядке. Сначала необходимо удалить таблицу, которая обращается к определяемому пользователем типу `Point`, затем тип, и, наконец, сборку.  
  
```  
DROP TABLE dbo.Points;  
DROP TYPE dbo.Point;  
DROP ASSEMBLY Point;  
```  
  
### <a name="finding-udt-dependencies"></a>Поиск зависимостей определяемого пользователем типа  
 Если есть зависимые объекты, например таблицы с определениями столбцов определяемых пользователем типов, то инструкция DROP TYPE завершится с ошибкой. Также она завершится с ошибкой, если есть функции, хранимые процедуры или триггеры, созданные в базе данных с помощью предложения WITH SCHEMABINDING, или эти процедуры используют переменные и параметры определяемого пользователем типа. Сначала необходимо удалить все зависимые объекты, а затем выполнить инструкцию DROP TYPE.  
  
 Следующие [!INCLUDE[tsql](../../includes/tsql-md.md)] запрос находит все столбцы и параметров, которые используют определяемый пользователем тип в **AdventureWorks** базы данных.  
  
```  
USE Adventureworks;  
SELECT o.name AS major_name, o.type_desc AS major_type_desc  
     , c.name AS minor_name, c.type_desc AS minor_type_desc  
     , at.assembly_class  
  FROM (  
        SELECT object_id, name, user_type_id, 'SQL_COLUMN' AS type_desc  
          FROM sys.columns  
     UNION ALL  
        SELECT object_id, name, user_type_id, 'SQL_PROCEDURE_PARAMETER'  
          FROM sys.parameters  
     ) AS c  
  JOIN sys.objects AS o  
    ON o.object_id = c.object_id  
  JOIN sys.assembly_types AS at  
    ON at.user_type_id = c.user_type_id;  
```  
  
## <a name="maintaining-udts"></a>Обслуживание определяемых пользователем типов  
 После создания определяемого пользователем типа в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] вы не можете его изменить, хотя можно изменить сборку, на которой основан этот тип. В большинстве случаев необходимо удалить из базы данных определяемый пользователем тип с помощью инструкции DROP TYPE языка [!INCLUDE[tsql](../../includes/tsql-md.md)], внести изменения в базовую сборку и загрузить ее повторно с помощью инструкции ALTER ASSEMBLY. Затем необходимо повторно создать определяемый пользователем тип и зависимые объекты.  
  
### <a name="example"></a>Пример  
 Инструкция ALTER ASSEMBLY используется после внесения изменений в исходный код сборки определяемого пользователем типа и ее повторной компиляции. Она копирует DLL-файл на сервер и выполняет повторную привязку к новой сборке. Полный синтаксис см. в разделе [ALTER ASSEMBLY &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-assembly-transact-sql).  
  
 Следующая инструкция ALTER ASSEMBLY языка [!INCLUDE[tsql](../../includes/tsql-md.md)] повторно загружает сборку Point.dll из указанного места на диске.  
  
```  
ALTER ASSEMBLY Point  
FROM '\\Projects\Point\bin\Point.dll'  
```  
  
### <a name="using-alter-assembly-to-add-source-code"></a>Использование инструкции ALTER ASSEMBLY для добавления исходного кода  
 Предложение ADD FILE в синтаксисе инструкции ALTER ASSEMBLY отсутствует в инструкции CREATE ASSEMBLY. Оно обеспечивает возможность добавления исходного кода или любых других файлов, связанных со сборкой. Файлы копируются из исходных расположений и сохраняются в системных таблицах базы данных. Это обеспечивает постоянную доступность исходного кода или других файлов на тот случай, если возникнет необходимость повторного создания или документирования текущей версии определяемого пользователем типа.  
  
 Следующие [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкции ALTER ASSEMBLY добавляет исходный код класса Point.cs для `Point` определяемого пользователем ТИПА. В результате этого текст, содержащийся в файле Point.cs, будет скопирован и сохранен в базе данных с именем PointSource.  
  
```  
ALTER ASSEMBLY Point  
ADD FILE FROM '\\Projects\Point\Point.cs' AS PointSource;  
```  
  
 Сведения о сборке хранится в **sys.assembly_files** таблицы в базе данных, где установлена сборка. **Sys.assembly_files** таблица содержит следующие столбцы.  
  
 **assembly_id**  
 Идентификатор, определенный для сборки. Это число назначается всем объектам, относящимся к одной сборке.  
  
 **name**  
 Имя объекта.  
  
 **file_id**  
 Число, определяющее каждого объекта, первый объект, связанный с данной **assembly_id** присваивается значение 1. Если существует несколько объектов, связанных с тем же **assembly_id**, то каждое последующее **file_id** значение увеличивается на 1.  
  
 **Содержимое**  
 Шестнадцатеричное представление сборки или файла.  
  
 Можно использовать функции CAST или CONVERT для преобразования содержимого **содержимого** столбца для чтения текст. Следующий запрос преобразует содержимое файла Point.cs в доступный для чтения текст, используя для ограничения результирующего набора до одной строки имя в предложении WHERE.  
  
```  
SELECT CAST(content AS varchar(8000))   
  FROM sys.assembly_files   
  WHERE name='PointSource';  
```  
  
 При копировании и вставке результатов в текстовый редактор видно, что разделители строк и пробелы, существовавшие в исходном тексте, сохранились.  
  
## <a name="managing-udts-and-assemblies"></a>Управление определяемыми пользователем типами и сборками  
 При планировании реализации определяемых пользователем типов обдумайте, какие методы нужны в самой сборке определяемого пользователем типа, а какие нужно создать в отдельных сборках и реализовать в виде определяемых пользователем функций или хранимых процедур. Выделение методов в отдельные сборки позволяет обновлять код, не затрагивая данные, которые могут храниться в столбце определяемого пользователем типа таблицы. Сборки определяемого пользователем типа можно изменять без удаления столбцов и других зависимых объектов только в случае, если новое определение может считывать предыдущие значения, а подпись типа не изменена.  
  
 Выделение процедурного кода, который может отличаться от кода, требуемого для реализации определяемого пользователем типа, значительно упрощает обслуживание. Включение кода, необходимого для функционирования определяемого пользователем типа, и максимально возможное упрощение определений определяемого пользователем типа снижает риск необходимости удаления этого типа из базы данных для изменения кода или исправления ошибок.  
  
### <a name="the-currency-udt-and-currency-conversion-function"></a>Определяемый пользователем тип Currency и функция конвертации валюты  
 **Валюты** определяемого пользователем ТИПА в **AdventureWorks** образца базы данных предоставляет полезный пример рекомендуемого способа структурирования определяемого пользователем ТИПА и связанных с ним функций. **Валюты** определяемого пользователем ТИПА используется для обработки денег на основе денежной системы определенной культуры и позволяет хранить различные типы валют, например, доллары, евро и т. д. Класс определяемого пользователем типа содержит культуру в виде строки, а количество денег — в виде типа данных `decimal`. Все необходимые методы сериализации содержатся внутри сборки, определяющей класс. Функция, реализующая конверсию валюты одной культуры в другую реализован в виде внешней функции с именем **ConvertCurrency**, и эта функция находится в отдельной сборке. **ConvertCurrency** функция выполняет свою работу, получая курс конверсии из таблицы в **AdventureWorks** базы данных. Если изменен источник конверсии, или если должен быть либо другие изменения в существующий код, ее можно легко изменить без влияния на **валюты** определяемого пользователем ТИПА.  
  
 Листинг кода для **валюты** определяемого пользователем ТИПА и **ConvertCurrency** функции можно найти, установив образцы общих языковой среды выполнения (CLR).  
  
### <a name="using-udts-across-databases"></a>Использование определяемых пользователем типов в нескольких базах данных  
 Определяемые пользователем типы по определению находятся в одной базе данных. Таким образом, определяемый пользователем тип, созданный в одной базе данных, нельзя использовать в определении столбца другой базы данных. Чтобы использовать определяемые пользователем типы в нескольких базах данных, в каждой базе данных необходимо выполнить инструкции CREATE ASSEMBLY и CREATE TYPE для тех же сборок. Сборки считаются одинаковыми, если имеют одинаковое имя, строгое имя, культуру, версию, набор разрешений и двоичное содержимое.  
  
 После того как определяемый пользователем тип зарегистрирован и доступен в обеих базах данных, можно преобразовать значение данного типа из одной базы данных для использования в другой. Одинаковые определяемые пользователем типы могут использоваться в нескольких базах данных в следующих сценариях.  
  
-   Вызываемые хранимые процедуры определены в различных базах данных.  
  
-   Запрашиваемые таблицы определены в различных базах данных.  
  
-   Выбор данных определяемого пользователем типа из столбца одной базы данных и вставка в столбец такого же типа другой базы данных.  
  
 В этих ситуациях любое преобразование, требуемое сервером, происходит автоматически. Эти преобразования нельзя выполнить явным образом с помощью функций CAST или CONVERT языка [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
 Обратите внимание, что не нужно предпринимать никаких действий по использованию определяемых пользователем типов при [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] создает рабочих таблиц в **tempdb** системной базы данных. Это включает обработку курсоров, табличные переменные и определяемые пользователем возвращающие табличные значения функции, которые включают определяемые пользователем типы и, прозрачным образом сделать использование **tempdb**. Тем не менее если вы явно создать временную таблицу в **tempdb** , определяющий столбец определяемого пользователем ТИПА, то определяемый пользователем тип должен быть зарегистрирован в **tempdb** так же, как и для пользовательской базы данных.  
  
## <a name="see-also"></a>См. также  
 [Определяемые пользователем типы в CLR](clr-user-defined-types.md)  
  
  
