---
title: Требования к определяемому пользователем типу | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- UDTs [CLR integration], requirements
- serialization
- Native serialization format [CLR integration]
- attributes [CLR integration]
- XML serialization [CLR integration]
- user-defined types [CLR integration], requirements
- user-defined serialization [CLR integration]
- user-defined types [CLR integration], Native serialization
- UDTs [CLR integration], Native serialization
ms.assetid: bedc3372-50eb-40f2-bcf2-d6db6a63b7e6
author: rothja
ms.author: jroth
ms.openlocfilehash: 8cf45c7c108f522f894f97c25ed51bd4dd3c4fbf
ms.sourcegitcommit: f71e523da72019de81a8bd5a0394a62f7f76ea20
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2020
ms.locfileid: "84970727"
---
# <a name="user-defined-type-requirements"></a>Требования определяемого пользователем типа данных
  При создании определяемого пользователем типа (UDT) для установки в необходимо принять несколько важных решений по проектированию [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . В большинстве случаев рекомендуется создавать определяемый пользователем тип как структуру, хотя можно создавать его и в виде класса. Чтобы определяемый пользователем тип можно было зарегистрировать в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно соответствовать спецификациям на создание определяемого пользователем типа.  
  
## <a name="requirements-for-implementing-udts"></a>Требования к реализации определяемого пользователем типа  
 Чтобы определяемый пользователем тип работал в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], его определение должно удовлетворять следующим условиям.  
  
 Определяемый пользователем тип должен задавать атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`. Использование `System.SerializableAttribute` необязательно, но рекомендуется.  
  
-   Структура или класс определяемого пользователем типа должны реализовать интерфейс `System.Data.SqlTypes.INullable` посредством создания метода `static` типа `Shared` (`Null` в [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic). [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию может работать со значениями NULL. Это необходимо, чтобы программный код, принадлежащий определяемому пользователем типу, умел распознавать значения NULL.  
  
-   Определяемый пользователем тип должен содержать общедоступный метод типа `static` (или `Shared`) `Parse`, поддерживающий создание объекта из строки с помощью синтаксического анализа, и общедоступный метод `ToString` для преобразования объекта в строку.  
  
-   Определяемый пользователем тип, имеющий заданный пользователем формат сериализации, должен реализовать интерфейс `System.Data.IBinarySerialize` и предоставлять методы `Read` и `Write`.  
  
-   Определяемый пользователем тип должен реализовать интерфейс `System.Xml.Serialization.IXmlSerializable`, либо все его общедоступные поля и свойства должны быть XML-сериализуемы или содержать атрибут `XmlIgnore`, если требуется переопределить стандартную сериализацию.  
  
-   У объекта определяемого пользователем типа может быть только одна сериализация. Если программы сериализации или десериализации обнаружат несколько различных представлений конкретного объекта, проверка закончится ошибкой.  
  
-   Для сравнения данных по порядку байтов атрибут `SqlUserDefinedTypeAttribute.IsByteOrdered` должен иметь значение `true`. Если интерфейс IComparable не реализован, а атрибут `SqlUserDefinedTypeAttribute.IsByteOrdered` имеет значение `false`, сравнение по порядку байтов будут завершаться неудачей.  
  
-   Определяемый пользователем тип, заданный в виде класса, должен иметь общедоступный конструктор без аргументов. Дополнительно можно создать перегруженные конструкторы класса.  
  
-   Определяемый пользователем тип должен предоставлять доступ к элементам данных как к общедоступным полям или процедурам свойств.  
  
-   Общедоступные имена не могут быть длиннее 128 символов и должны соответствовать [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] правилам именования идентификаторов, определенным в [идентификаторах баз данных](../databases/database-identifiers.md).  
  
-   Столбцы `sql_variant` не могут содержать экземпляры определяемого пользователем типа.  
  
-   Унаследованные элементы недоступны из [!INCLUDE[tsql](../../includes/tsql-md.md)], потому что система типов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ничего не знает об иерархии наследования среди определяемых пользователем типов. Однако можно использовать наследование при определении структуры классов и можно вызывать такие методы в реализации этих типов с помощью управляемого кода.  
  
-   Элементы структуры или класса нельзя перегружать, кроме конструктора класса. Если создан перегруженный метод, при регистрации сборки или создании типа в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ошибка не возникает. Определение наличия перегруженного метода происходит во время выполнения, а не при создании типа. Класс может иметь перегруженные методы при условии, что они не вызываются. При вызове перегруженного метода возникает ошибка.  
  
-   Любые элементы, объявленные как `static` (или `Shared`) должны быть объявлены константами или данными только для чтения. Элементы, объявленные как статические, нельзя изменять.  
  
-   Если для поля `SqlUserDefinedTypeAttribute.MaxByteSize` задано значение -1, ограничение на размер сериализованного определяемого пользователем типа такое же, как и для объектов LOB (в настоящее время — 2 ГБ). Размер определяемого пользователем типа не может превышать величины, заданной в поле `MaxByteSized`.  
  
> [!NOTE]  
>  По желанию можно реализовать интерфейс `System.IComparable`, предоставляющий единственный метод `CompareTo`, хотя сервер не использует этот метод для сравнения. Он используется на клиенте в ситуациях, когда нужно провести точное сравнение или сортировку значений определяемого пользователем типа.  
  
## <a name="native-serialization"></a>Собственная сериализация  
 Выбор атрибутов сериализации при создании определяемого пользователем типа зависит от его типа. Формат сериализации `Native` использует очень простую структуру, позволяющую [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранить определяемый пользователем тип на диске в эффективном собственном формате. Формат `Native` рекомендуется для простых определяемых пользователем типов, содержащих только поля следующих типов:  
  
 **bool**, **Byte**, **SByte**, **Short**, **UShort**, **int**, **uint**, **Long**, **ulong**, **float**, **Double**, **склбите**, **SqlInt16**, **SqlInt32**, **SqlInt64**, **SqlDateTime**, **склсингле**, **SqlDouble**, **SqlMoney**, **SqlBoolean**  
  
 Типы значений, состоящие из полей приведенных выше типов, являются хорошим кандидатом для `Native` формата, например `structs` в Visual C# (или в том случае, если `Structures` они известны в Visual Basic). Например, определяемый пользователем тип, для которого указан формат сериализации `Native`, может содержать в качестве поля другой определяемый пользователем тип, для которого также указан формат сериализации `Native`. Для более сложных определяемых пользователем типов, содержащих типы данных, которые не вошли в приведенный список, нужно вместо этого задать формат сериализации `UserDefined`.  
  
 Формат `Native` накладывает следующие ограничения.  
  
-   Параметру `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.MaxByteSize` не должно быть задано значение.  
  
-   Все поля должны быть сериализуемыми.  
  
-   Если определяемый пользователем тип задан в виде класса, а не структуры, нужно задать для атрибута `System.Runtime.InteropServices.StructLayoutAttribute` значение `StructLayout.LayoutKindSequential`. Этот атрибут управляет физической компоновкой полей данных. Он заставляет члены структуры располагаться в памяти в том порядке, в каком они описаны. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует этот атрибут для задания порядка полей в определяемых пользователем типах с несколькими значениями.  
  
 Пример определяемого пользователем типа, определяемого с помощью `Native` сериализации, см. в разделе [определение определяемых пользователем типов](creating-user-defined-types-coding.md)данных.  
  
## <a name="userdefined-serialization"></a>Сериализация, заданная пользователем  
 Настройка формата `UserDefined` у атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` предоставляет разработчику полный доступ к двоичным форматам. При задании для свойства атрибута `Format` значения `UserDefined` нужно проделать с программным кодом следующее.  
  
-   Указать необязательное свойство атрибута `IsByteOrdered`. Значение по умолчанию — `false`.  
  
-   Задать свойство `MaxByteSize` атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute`.  
  
-   Написать программный код, реализующий методы `Read` и `Write` данного определяемого пользователем типа, реализовав интерфейс `System.Data.Sql.IBinarySerialize`.  
  
 Пример определяемого пользователем типа, определяемого с помощью `UserDefined` сериализации, см. в разделе Определение типа валюты в [коде определяемых пользователем типов](creating-user-defined-types-coding.md).  
  
> [!NOTE]  
>  Чтобы поля определяемого пользователем типа можно было использовать в индексе, они должны иметь собственную сериализацию или быть сохраняемыми.  
  
## <a name="serialization-attributes"></a>Атрибуты сериализации  
 Атрибуты определяют, каким образом сериализация используется для создания хранимых представлений определяемых пользователем типов, а также для передачи таких типов клиенту по значению. Задание атрибута `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` обязательно при создании определяемого пользователем типа. Атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` указывает, что класс является определяемым пользователем типом, и задает тип хранения для определяемого пользователем типа. По желанию можно задать атрибут `Serializable`, хотя [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] этого не требует.  
  
 Атрибут `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute` имеет следующие свойства.  
  
 `Format`  
 Задает формат сериализации — `Native` или `UserDefined`, в зависимости от типов данных, содержащихся в определяемом пользователем типе.  
  
 `IsByteOrdered`  
 Значение типа `Boolean`, определяющее, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит двоичные сравнения значений данного типа.  
  
 `IsFixedLength`  
 Указывает, имеют ли все экземпляры данного определяемого пользователем типа одинаковую длину.  
  
 `MaxByteSize`  
 Максимальный размер экземпляра в байтах. Необходимо указать `MaxByteSize` с форматом сериализации `UserDefined`. Для определяемого пользователем типа, для которого задана определяемая пользователем сериализация, `MaxByteSize` означает общий размер этого определяемого пользователем типа в сериализованном виде, как указано пользователем. Значение `MaxByteSize` должно лежать в диапазоне от 1 до 8000; можно установить для него значение -1, чтобы указать, что размер определяемого пользователем типа больше 8000 байтов (общий размер не может превышать максимального размера LOB). Рассмотрим определяемый пользователем тип со свойством строкового типа длиной 10 символов (`System.Char`). Когда определяемый пользователем тип сериализуется с помощью BinaryWriter, общий размер сериализованной строки составляет 22 байта: 2 байта на символ Юникода UTF-16, умноженный на максимальное число символов, плюс 2 контрольные байта, вызванные сериализацией двоичного потока. Поэтому при определении значения параметра `MaxByteSize` следует учитывать общий размер сериализованного, определяемого пользователем типа: размер данных, сериализованных в двоичной форме, плюс издержки от сериализации.  
  
 `ValidationMethodName`  
 Имя метода, используемого для проверки экземпляров определяемого пользователем типа.  
  
### <a name="setting-isbyteordered"></a>Свойство IsByteOrdered  
 Когда свойство `Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute.IsByteOrdered` имеет значение `true`, это дает гарантию, что сериализованные двоичные данные можно использовать для семантического упорядочивания информации. Таким образом, каждый экземпляр объекта побайтно упорядоченного определяемого пользователем типа может иметь лишь одно сериализованное представление. Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] проводит операцию сравнения на сериализованных байтах, ее результаты должны быть такими же, как если бы та же операция сравнения проводилась в управляемом коде. Если параметру `IsByteOrdered` присвоено значение `true`, поддерживаются также следующие функции.  
  
-   Создание индексов для столбцов этого типа.  
  
-   Создание первичных и внешних ключей, а также ограничений CHECK и UNIQUE для столбцов этого типа.  
  
-   Использование предложений [!INCLUDE[tsql](../../includes/tsql-md.md)] ORDER BY, GROUP BY и PARTITION BY. В этих случаях для определения порядка используется двоичное представление типа.  
  
-   Использование операторов сравнения в инструкциях [!INCLUDE[tsql](../../includes/tsql-md.md)].  
  
-   Сохранение вычисляемых столбцов этого типа.  
  
 Следует заметить, что, когда для свойства `Native` задано значение `UserDefined`, форматы сериализации `IsByteOrdered` и `true` поддерживают следующие операции сравнения:  
  
-   Равно (=)  
  
-   Не равно (!=)  
  
-   Знак «больше» >)  
  
-   Знак "меньше" (\<)  
  
-   Больше или равно (>=)  
  
-   Оператор «Меньше или равно» (<=)  
  
### <a name="implementing-nullability"></a>Реализация допустимости значений NULL  
 Помимо задания нужных атрибутов для сборок, создаваемый класс должен также поддерживать допустимость значений NULL. Определяемые пользователем типы, загружаемые в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], могут работать со значениями NULL, но, чтобы определяемый пользователем тип узнавал значение NULL, класс должен реализовать интерфейс `INullable`. Дополнительные сведения и пример реализации допустимости значений NULL в определяемом пользователем типе см. в разделе [написание определяемых пользователем типов](creating-user-defined-types-coding.md).  
  
### <a name="string-conversions"></a>Преобразование строк  
 Для поддержки преобразования определяемого пользователем типа в строку и восстановления из строки нужно реализовать в классе методы `Parse` и `ToString`. Метод `Parse` позволяет преобразовывать строку в определяемый пользователем тип. Он должен быть объявлен как `static` (или `Shared` в Visual Basic) и принимать параметр типа `System.Data.SqlTypes.SqlString`. Дополнительные сведения и пример реализации `Parse` `ToString` методов и см. в разделе [кодирование определяемых пользователем типов](creating-user-defined-types-coding.md).  
  
## <a name="xml-serialization"></a>XML-сериализация  
 Определяемые пользователем типы должны поддерживать преобразование из типа данных `xml` и в этот тип данных, подчиняясь соглашению для XML-сериализации. Пространство имен `System.Xml.Serialization` содержит классы, которые используются для сериализации объектов в документы или потоки формата XML. По желанию можно реализовать сериализацию `xml` с помощью интерфейса `IXmlSerializable`, предоставляющего настраиваемую XML-сериализацию и десериализацию.  
  
 Помимо явных преобразований определяемого пользователем типа в `xml`, XML-сериализация позволяет.  
  
-   Применять `Xquery` к значениям экземпляров определяемого пользователем типа после преобразования в тип данных `xml`.  
  
-   Использование определяемых пользователем типов в параметризованных запросах и веб-методах с собственными XML-веб-службами в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
-   Использовать определяемые пользователем типы для получения массовой загрузки XML-данных.  
  
-   Сериализовать объекты DataSets, содержащие таблицы со столбцами определяемого пользователем типа.  
  
 Определяемые пользователем типы не сериализуются в запросах FOR XML. Для выполнения запроса FOR XML, показывающего XML-сериализацию определяемого пользователем типа, нужно явно преобразовать каждый столбец определяемого пользователем типа в тип данных `xml` в предложении SELECT. Можно явно преобразовать столбцы в типы `varbinary`, `varchar` или `nvarchar`.  
  
## <a name="see-also"></a>См. также:  
 [Создание определяемого пользователем типа](creating-user-defined-types.md)  
  
  
