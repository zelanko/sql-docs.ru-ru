---
title: Введение в таблицы, оптимизированные для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: ff434efd0a9f4fcb3316143e598e636bff85f487
ms.sourcegitcommit: 6fd8c1914de4c7ac24900fe388ecc7883c740077
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2020
ms.locfileid: "63157835"
---
# <a name="introduction-to-memory-optimized-tables"></a>Введение в таблицы, оптимизированные для памяти
  Оптимизированные для памяти таблицы, созданные с помощью инструкции [CREATE TABLE (Transact-SQL)](/sql/t-sql/statements/create-table-transact-sql).  
  
 Оптимизированные для памяти таблицы находятся в памяти. Строки из таблицы считываются и записываются в память. Вся таблица находится в памяти. Вторая копия табличных данных хранится на диске, но только с целью увеличения устойчивости.  
  
 OLTP-операции в памяти интегрированы с [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] для эффективной работы в любых областях, таких как разработка, развертывание, управление и поддержка. База данных может содержать как объекты в памяти, так и объекты на диске.  
  
 Строки в оптимизированных для памяти таблицах имеют версии. То есть каждая строка в таблице потенциально имеет несколько версий. Все версии строк сохраняются в одной структуре данных таблицы. Управление версиями строк используется, чтобы разрешить параллельный режим чтения и записи для одной строки. Дополнительные сведения о параллельном режиме чтения и записи для одной строки см. в разделе [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).  
  
 На следующем рисунке показана работа с несколькими версиями строк. На схеме показана таблица с тремя строками, у каждой строки своя версия.  
  
 ![Управление версиями.](../../database-engine/media/hekaton-tables-1.gif "Управление версиями.")  
  
 Таблица содержит три строки: r1, r2 и r3. r1 содержит три версии, r2 — 2 версии, и r3 — 4 версии. Обратите внимание, что разные версии одной и той же строки не обязательно занимают последовательные области памяти. Различные версии строк могут быть распределены по всей структуре данных таблицы.  
  
 Структуру данных таблицы, оптимизированной для памяти, можно рассматривать как коллекцию версий строк. Строки в таблицах, сохраняемых на диске, разбиты по страницам и расширениям, при этом доступ к отдельным строкам осуществляется через номер страницы и смещение. Доступ к версиям строк в таблицах с оптимизацией для памяти осуществляется посредством указателей памяти, занимающих 8 байт.  
  
## <a name="durability"></a>Длительность  
 Таблицы, оптимизированные для памяти, по умолчанию полностью устойчивы, и подобно транзакциям в обычных таблицах на диске полностью устойчивые транзакции на оптимизированных для памяти таблицах полностью соответствуют классификации ACID (atomic, consistent, isolated, durable — атомарные, целостные, изолированные, устойчивые). Оптимизированные для памяти таблицы и скомпилированные в собственном коде хранимые процедуры поддерживают подмножество [!INCLUDE[tsql](../../../includes/tsql-md.md)].  
  
 OLTP в памяти поддерживает устойчивые таблицы с отложенной устойчивостью транзакций. Отложенные устойчивые транзакции сохраняются на диск сразу после совершения транзакции. Платой за повышение производительности является то, что зафиксированные транзакции, не сохраненные на диск, теряются при сбое или отработке отказа сервера.  
  
 Помимо устойчивых оптимизированных для памяти таблиц [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] также поддерживает неустойчивые таблицы в памяти, которые не заносятся в журнал, а их данные не сохраняются на диске. Это означает, что транзакции на этих таблицах не требуют каких-либо дисковых операций ввода-вывода, но их данные не будут восстановлены при сбое или отработке отказа сервера.  
  
## <a name="accessing-data-in-memory-optimized-tables"></a>Доступ к данным в оптимизированных для памяти таблицах  
 Доступ к данным в таблицах, оптимизированных для памяти, можно получить двумя способами:  
  
-   С помощью интерпретированного [!INCLUDE[tsql](../../../includes/tsql-md.md)] (вне компилированной в собственном коде хранимой процедуры). Эти инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] могут находиться в интерпретируемых хранимых процедурах или представлять собой специализированные инструкции [!INCLUDE[tsql](../../../includes/tsql-md.md)] .  
  
-   Использование хранимых процедур, скомпилированных в собственном коде.  
  
 Доступ к оптимизированным для памяти таблицам наиболее эффективным образом можно осуществлять из скомпилированных в собственном коде хранимых процедур ([Скомпилированные в собственном коде хранимые процедуры](natively-compiled-stored-procedures.md)). К оптимизированным для памяти таблицам можно обращаться через обычный интерпретируемый [!INCLUDE[tsql](../../../includes/tsql-md.md)]. Термин «интерпретируемый [!INCLUDE[tsql](../../../includes/tsql-md.md)] » означает доступ к оптимизированным для памяти таблицам без использования скомпилированной хранимой процедуры. Примеры интерпретируемого доступа [!INCLUDE[tsql](../../../includes/tsql-md.md)] — доступ к оптимизированной для памяти таблице из триггера DML или специального пакета [!INCLUDE[tsql](../../../includes/tsql-md.md)] , представления и функции с табличным значением.  
  
 В следующей таблице представлены средства собственного и интерпретируемого доступа [!INCLUDE[tsql](../../../includes/tsql-md.md)] для различных объектов.  
  
|Функция|Доступ с помощью хранимой процедуры, скомпилированной в собственном коде|Интерпретируемый доступ [!INCLUDE[tsql](../../../includes/tsql-md.md)]|Доступ по CLR-адресу|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|Таблицы, оптимизированные для памяти|Да|Да|Нет <sup>1</sup>|  
|[Переменные оптимизированной для памяти таблицы](../../database-engine/memory-optimized-table-variables.md)|Да|Да|Нет|  
|[скомпилированные в собственном коде хранимые процедуры](https://msdn.microsoft.com/library/dn133184.aspx)|Нельзя выполнить любую хранимую процедуру из хранимой процедуры, скомпилированной в собственном коде, путем копирования инструкции EXECUTE.|Да|Нет <sup>1</sup>|  
  
 <sup>1</sup> невозможно получить доступ к оптимизированной для памяти таблице или хранимой процедуре, скомпилированной в собственном [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] режиме, из контекстного соединения (соединение выполняется при выполнении модуля CLR). Однако можно создать и открыть другое соединение, из которого можно получить доступ к оптимизированным для памяти таблицам и хранимым процедурам, скомпилированным в собственном коде. Дополнительные сведения см. в разделе [регулярные и контекстные соединения](../clr-integration/data-access/context-connections-vs-regular-connections.md).  
  
## <a name="performance-and-scalability"></a>Производительность и масштабируемость  
 Следующие факторы влияют на повышение производительности при использовании OLTP в памяти:  
  
 Обмен данными  
 Выигрыш в производительности приложения с множеством вызовов коротких хранимых процедур может быть меньше, чем у приложения с меньшим числом вызовов и более функциональными хранимыми процедурами.  
  
 Выполнение [!INCLUDE[tsql](../../../includes/tsql-md.md)]  
 OLTP в памяти достигает наивысшей производительности при использовании хранимых процедур, скомпилированных в собственном коде, вместо интерпретированных хранимых процедур или выполнения запроса. Хранимые процедуры, выполняющие другие хранимые процедуры, не могут быть скомпилированы в собственном коде, но из таких хранимых процедур иногда бывает нужен доступ к оптимизированным для памяти таблицам.  
  
 Просмотр диапазона или поиск точек  
 Некластеризованные, оптимизированные для памяти индексы поддерживают просмотр диапазона и упорядоченные просмотры. С уточняющими запросами оптимизированные для памяти хэш-индексы более производительны, чем оптимизированные для памяти некластеризованные индексы. Оптимизированные для памяти некластеризованные индексы имеют более высокую производительность, чем дисковые индексы.  
  
 Операции с индексами не регистрируются и находятся только в памяти.  
  
 Параллелизм  
 Производительность приложений, которая зависит от параллелизма компонента уровня СУБД, например от конфликтов кратковременной блокировки, значительно повышается при переходе на OLTP в памяти.  
  
 В следующей таблице перечислены проблемы с производительностью и масштабируемостью, которые часто встречаются в реляционных базах данных, и описывается, как OLTP в памяти может улучшить производительность.  
  
|Проблема|Влияние OLTP в памяти|  
|-----------|----------------------------|  
|Производительность<br /><br /> Высокая интенсивность использования ресурсов (ЦП, ввода-вывода, сети или памяти).|ЦП<br /> Скомпилированные в собственном коде хранимые процедуры могут значительно снизить уровень загрузки ЦП, так как им требуется значительно меньше инструкций на выполнение команды [!INCLUDE[tsql](../../../includes/tsql-md.md)] , чем интерпретированным хранимым процедурам.<br /><br /> In-Memory OLTP может снизить затраты на оборудование для масштабированных рабочих нагрузок, поскольку один сервер потенциально может обеспечить пропускную способность 5–10 серверов.<br /><br /> Ввод-вывод<br /> OLTP в памяти может уменьшить влияние узких мест в операциях ввода-вывода при обработке страниц данных или индекса. Кроме того, назначение контрольных точек для объектов OLTP в памяти происходит непрерывно и не приводит к неожиданному увеличению количества операций ввода-вывода. Однако если рабочее множество важных для производительности таблиц не помещается в памяти, то OLTP в памяти не улучшит производительность, поскольку данные должны быть резидентными. Если возникает задержка в операциях ввода-вывода при ведении журнала, то OLTP в памяти может снизить эту задержку, так как в журнал записывается меньше данных. Если одна или несколько таблиц, оптимизированных для памяти, настроены как устойчивые, журналирование данных можно исключить.<br /><br /> Память<br /> OLTP в памяти не повышает производительность. OLTP в памяти может вызывать дополнительную нагрузку на память, так как объекты должны быть резидентными.<br /><br /> Сеть<br /> OLTP в памяти не повышает производительность. Данные нужно передавать с уровня данных на уровень приложения.|  
|Масштабируемость<br /><br /> Большинство проблем с масштабированием в приложениях [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] вызываются проблемами параллелизма, такими как конфликт в блокировках, кратковременных блокировках и спин-блокировках.|Конфликты кратковременных блокировок<br /> Типичный сценарий — конфликт на последней странице индекса при параллельной вставке строк в порядке значений ключей. OLTP в памяти не использует кратковременные блокировки при доступе к данным, поэтому проблемы масштабируемости, связанные с конфликтом за кратковременные блокировки, полностью устраняются.<br /><br /> Конфликт спин-блокировок<br /> OLTP в памяти не использует кратковременные блокировки при доступе к данным, поэтому проблемы масштабируемости, связанные с состязанием за спин-блокировки, полностью устраняются.<br /><br /> Конфликты, связанные с блокировкой<br /> OLTP в памяти устраняет критические препятствия между операциями чтения и записи в приложении базы данных, поскольку используется новая форма управления оптимистической конкуренцией для реализации всех уровней изоляции транзакций. OLTP в памяти не использует базу данных TempDB для хранения версий строк.<br /><br /> Если ошибка масштабирования вызвана конфликтом между двумя операциями записи, например двумя параллельными транзакциями, которые пытаются обновить одну и ту же строку, OLTP в памяти позволяет завершить одну транзакцию и отклоняет другую. Поврежденную транзакцию необходимо представить повторно явно или неявно. В любом случае необходимо внести изменения в приложение.<br /><br /> Если в приложении часто возникают конфликты между двумя операциями записи, значимость оптимистической блокировки уменьшается. Приложение не подходит для работы с OLTP в памяти. В большинстве OLTP-приложений отсутствуют конфликты записи, если конфликт не вызывается укрупнением блокировки.|  
  
## <a name="see-also"></a>См. также  
 [Выполняющаяся в памяти OLTP (оптимизация в памяти)](in-memory-oltp-in-memory-optimization.md)  
  
  
