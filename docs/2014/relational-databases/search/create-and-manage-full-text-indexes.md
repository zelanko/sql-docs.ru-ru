---
title: Создание полнотекстовых индексов и управление ими | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
helpviewer_keywords:
- full-text indexes [SQL Server], about
ms.assetid: f8a98486-5438-44a8-b454-9e6ecbc74f83
author: douglaslMS
ms.author: douglasl
manager: craigg
ms.openlocfilehash: 164ddc7f11b37ce7b6325f177713e6d3eca8635b
ms.sourcegitcommit: 3da2edf82763852cff6772a1a282ace3034b4936
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/02/2018
ms.locfileid: "48054744"
---
# <a name="create-and-manage-full-text-indexes"></a>Создание и управление полнотекстовыми индексами
  Данные полнотекстовых индексов используются средством полнотекстового поиска для компиляции полнотекстовых запросов, способных быстро находить таблицу с теми или иными словами или словосочетаниями. В полнотекстовом индексе хранятся данные о значимых для поиска словах и их расположении в одном или нескольких столбцах таблицы базы данных. Полнотекстовый индекс — это специальный тип функционального индекса на основе токенов, создаваемый и используемый средством полнотекстового поиска для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Процесс создания полнотекстового индекса отличается от создания индексов других типов. Вместо создания сбалансированного дерева на основе значения, хранящегося в конкретной строке, служба полнотекстового поиска создает инвертированную стековую сжатую структуру индекса на основе отдельных токенов индексируемого текста.  Размер полнотекстового индекса ограничен только доступными ресурсами памяти компьютера, на котором запущен экземпляр [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .  
  
 Начиная с [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)]полнотекстовые индексы встроены в ядро СУБД, а не размещены в файловой системе, как в предыдущих версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В новой базе данных полнотекстовый каталог является виртуальным объектом, не принадлежащим ни к одной файловой группе. Он является лишь логическим понятием, связанным с группой полнотекстовых индексов. Однако обратите внимание, что при обновлении базы данных [!INCLUDE[ssVersion2005](../../includes/ssversion2005-md.md)] (любого полнотекстового каталога с файлами данных) создается новая файловая группа. Дополнительные сведения см. в разделе [Обновление полнотекстового поиска](upgrade-full-text-search.md).  
  
> [!NOTE]  
>  В [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] и более поздних версиях средство полнотекстового поиска находится в процессе [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , а не в отдельной службе. Интеграция средства полнотекстового поиска в компонент Database Engine повышает управляемость, оптимизацию смешанных запросов и общую производительность.  
  
 На одну таблицу может приходиться только один полнотекстовый индекс. Чтобы в таблице можно было создать полнотекстовый индекс, она должна содержать один уникальный столбец, значением которого не является NULL. Вы можете создать полнотекстовый индекс на столбцах типа `char`, `varchar`, `nchar`, `nvarchar`, `text`, `ntext`, `image`, `xml`, `varbinary`, и `varbinary(max)` могут быть проиндексированы для Компонент Full-text search. Создание полнотекстового индекса для столбца, данные которого является тип `varbinary`, `varbinary(max)`, `image`, или `xml` необходимо указать столбец типов. *Столбец типов* — это столбец таблицы, в каждой строке которого хранятся расширения файлов (DOC, PDF, XLS и т. д.) документа.  
  
 Процесс создания и сопровождения полнотекстового индекса называется *заполнением* (а также *сканированием*). Существует три типа заполнения полнотекстового индекса: полное заполнение, заполнение на основе отслеживания изменений и добавочное заполнение с использованием меток времени. Дополнительные сведения см. в разделе [Заполнение полнотекстовых индексов](populate-full-text-indexes.md).  
  
##  <a name="tasks"></a> Общие задачи  
 **Для создания полнотекстового индекса**  
  
-   [CREATE FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/create-fulltext-index-transact-sql)  
  
 **Изменение полнотекстового индекса**  
  
-   [ALTER FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/alter-fulltext-index-transact-sql)  
  
 **Удаление полнотекстового индекса**  
  
-   [DROP FULLTEXT INDEX (Transact-SQL)](/sql/t-sql/statements/drop-fulltext-index-transact-sql)  
  
 [В этом разделе](#top)  
  
##  <a name="structure"></a> Структура полнотекстового индекса  
 Чтобы понять, как работает средство полнотекстового поиска, необходимо разобраться в структуре полнотекстового индекса. В данном разделе в качестве примера таблицы используется следующий фрагмент таблицы **Document** в [!INCLUDE[ssSampleDBCoShort](../../includes/sssampledbcoshort-md.md)] . В данном фрагменте показываются только два столбца: **DocumentID** и **Title** , а также три строки из таблицы.  
  
 В этом примере подразумевается, что полнотекстовый индекс был создан по столбцу **Title** .  
  
|DocumentID|Title|  
|----------------|-----------|  
|1|Crank Arm and Tire Maintenance|  
|2|Front Reflector Bracket and Reflector Assembly 3|  
|3|Front Reflector Bracket Installation|  
  
 Например, в следующей таблице, в которой приведен фрагмент 1, показано содержимое полнотекстового индекса, созданного по столбцу **Title** таблицы **Document** . Полнотекстовые индексы содержат больше данных, чем представлено в этой таблице. Таблица является логическим представлением полнотекстового индекса, она предоставляется только с целью демонстрации. Строки хранятся в сжатом формате для оптимизации использования диска.  
  
 Обратите внимание, что данные были инвертированы по сравнению с оригинальными документами. Инверсия происходит, поскольку ключевые слова сопоставлены с идентификаторами документов. По этой причине полнотекстовый индекс часто называют инвертированным индексом.  
  
 Обратите также внимание, что ключевое слово «and» было удалено из полнотекстового индекса. Это было сделано, поскольку «and» является стоп-словом. Удаление стоп-слов из полнотекстового индекса может привести к значительной экономии дискового пространства, тем самым увеличивая производительность запросов. Дополнительные сведения о стоп-словах см. в разделе [Настройка и управление стоп-словами и списками стоп-слов для полнотекстового поиска](configure-and-manage-stopwords-and-stoplists-for-full-text-search.md).  
  
 **Фрагмент 1**  
  
|Ключевое слово|ColId|DocId|Наличие|  
|-------------|-----------|-----------|----------------|  
|Crank|1|1|1|  
|Arm|1|1|2|  
|Tire|1|1|4|  
|Обслуживание|1|1|5|  
|Front|1|2|1|  
|Front|1|3|1|  
|Reflector|1|2|2|  
|Reflector|1|2|5|  
|Reflector|1|3|2|  
|Bracket|1|2|3|  
|Bracket|1|3|3|  
|Сборка|1|2|6|  
|3|1|2|7|  
|Установка|1|3|4|  
  
 Столбец **Keyword** содержит представление одного токена, извлеченного при индексировании. Токены определяются средствами разбиения по словам.  
  
 Столбец **ColId** содержит значение, соответствующее столбцу, по которому выполняется полнотекстовое индексирование.  
  
 `DocId` Столбец содержит значения для 8 байтовое целое число, которое соответствует определенному значению полнотекстового ключа в таблице индексированного полнотекстового поиска. Данное поведение необходимо, если полнотекстовый ключ имеет тип данных, отличный от целого. В таких случаях сопоставления между полнотекстового поиска значениями ключа и `DocId` значения сохраняются в отдельной таблице, называемой таблицей сопоставления DocId. Для создания запросов к этим сопоставлениям следует использовать системную хранимую процедуру [sp_fulltext_keymappings](/sql/relational-databases/system-stored-procedures/sp-fulltext-keymappings-transact-sql) . Для удовлетворения условия поиска необходимо соединить значения DocId из приведенной выше таблицы с таблицей сопоставления DocId. Это позволит возвращать строки из запрашиваемой базовой таблицы. Если значение полнотекстового ключа из базовой таблицы имеет целочисленный тип, то само значение служит в качестве значения DocId и дополнительного сопоставления не требуется. Следовательно, использование целочисленных значений полнотекстового ключа может оптимизировать выполнение полнотекстовых запросов.  
  
 Столбец **Occurrence** содержит целочисленное значение. Каждому значению DocId соответствует список значений частотности, которые соответствуют относительным смещениям слов для определенного ключевого слова в документе с этим значением DocId. С помощью значений частотности удобно определять фразовое или близкое совпадение; например, для фраз значения частотности находятся рядом. Кроме того, их удобно использовать при вычислении коэффициента релевантности. Например, они дают возможность подсчитать частоту употребления ключевого слова в документе DocId.  
  
 [В этом разделе](#top)  
  
##  <a name="fragments"></a> Фрагменты полнотекстового индекса  
 Логический полнотекстовый индекс обычно разбивается по нескольким внутренним таблицам. Каждая из внутренних таблиц называется фрагментом полнотекстового индекса. Некоторые из данных фрагментов могут содержать более свежие данные. Например, если пользователь обновляет следующую строку с DocId, равным 3, а в таблице выполняется автоматическое отслеживание изменений, то будет создан новый фрагмент.  
  
|DocumentID|Title|  
|----------------|-----------|  
|3|Rear Reflector|  
  
 В следующем примере, в котором показан фрагмент 2, содержатся более новые данные о DocId 3, чем во фрагменте 1. Следовательно, если пользователь запрашивает «задний отражатель», то для DocId 3 будут использованы данные из фрагмента 2. Каждый из фрагментов имеет отметку времени создания, которую можно использовать в запросах с помощью представления каталога [sys.fulltext_index_fragments](/sql/relational-databases/system-catalog-views/sys-fulltext-index-fragments-transact-sql) .  
  
 **Фрагмент 2**  
  
|Ключевое слово|ColId|DocId|Occ|  
|-------------|-----------|-----------|---------|  
|Rear|1|3|1|  
|Reflector|1|3|2|  
  
 Как можно увидеть во фрагменте 2, полнотекстовым запросам необходимо осуществить внутреннее обращение к каждому фрагменту. Более старые записи не учитываются. Следовательно, наличие слишком большого количества полнотекстовых фрагментов индекса в полнотекстовом индексе может привести к существенному уменьшению производительности запросов. Для уменьшения количества фрагментов выполните переорганизацию полнотекстового каталога, используя параметр REORGANIZE инструкции [ALTER FULLTEXT CATALOG](/sql/t-sql/statements/alter-fulltext-catalog-transact-sql)[!INCLUDE[tsql](../../includes/tsql-md.md)] . Данная инструкция выполняет *слияние в единый файл*, объединяя все фрагменты в единый большой фрагмент, и удаляет все устаревшие записи из полнотекстового индекса.  
  
 После выполнения реорганизации в образце индекса будут содержаться следующие строки.  
  
|Ключевое слово|ColId|DocId|Occ|  
|-------------|-----------|-----------|---------|  
|Crank|1|1|1|  
|Arm|1|1|2|  
|Tire|1|1|4|  
|Обслуживание|1|1|5|  
|Front|1|2|1|  
|Rear|1|3|1|  
|Reflector|1|2|2|  
|Reflector|1|2|5|  
|Reflector|1|3|2|  
|Bracket|1|2|3|  
|Сборка|1|2|6|  
|3|1|2|7|  
  
 [В этом разделе](#top)  
  
  
