---
title: Улучшение производительности полнотекстовых индексов | Документация Майкрософт
ms.custom: ''
ms.date: 04/26/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: search
ms.topic: conceptual
helpviewer_keywords:
- performance [SQL Server], full-text search
- full-text queries [SQL Server], performance
- crawls [full-text search]
- full-text indexes [SQL Server], performance
- full-text search [SQL Server], performance
- batches [SQL Server], full-text search
ms.assetid: ef39ef1f-f0b7-4582-8e9c-31d4bd0ad35d
author: MikeRayMSFT
ms.author: mikeray
manager: craigg
ms.openlocfilehash: 42aa89a111697f17f23613761eeeb462494bdd27
ms.sourcegitcommit: 45a9d7ffc99502c73f08cb937cbe9e89d9412397
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/22/2019
ms.locfileid: "66011263"
---
# <a name="improve-the-performance-of-full-text-indexes"></a>Улучшение производительности полнотекстовых индексов
  Производительность полнотекстового индекса и полнотекстовых запросов зависит от архитектуры компьютера, а также от объема памяти, скорости работы ЦП и жесткого диска и других ресурсов оборудования.  
  
##  <a name="causes"></a> Распространенные причины проблем с производительностью  
 Основной причиной снижения производительности полнотекстового индексирования являются ограничения ресурсов оборудования.  
  
-   Если загрузка ЦП узлом управляющей программы полнотекстовой фильтрации (fdhost.exe) или процессом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] (sqlservr.exe) приближается к 100 %, то самым узким местом системы является процессор.  
  
-   Если средняя длина очереди ожидания обращения к жесткому диску в два или больше раз превышает количество головок диска, то узким местом является жесткий диск. Как правило, эта проблема решается путем создания полнотекстовых каталогов, размещенных отдельно от файлов баз данных и журналов [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Разместите журналы, файлы баз данных и полнотекстовые каталоги на разных дисках. Кроме того, для повышения производительности индексирования можно приобрести более быстрый жесткий диск или диск с поддержкой RAID.  
  
-   Если не хватает физической памяти (пороговое значение в 3 ГБ), то наиболее узким местом может оказаться память. Ограничения, связанные с физической памятью, могут возникнуть на любых системах. На 32-разрядных системах к замедлению полнотекстового индексирования может привести нехватка виртуальной памяти.  
  
    > [!NOTE]  
    >  Начиная с версии [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)], механизм полнотекстового поиска может использовать память AWE, поскольку механизм является частью sqlservr.exe.  
  
 Если в системе нет узких мест, связанных с оборудованием, то производительность индексирования полнотекстового поиска в большей степени будет зависеть от следующих аспектов.  
  
-   Время, необходимое [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для создания полнотекстовых пакетов.  
  
-   Скорость, с которой управляющая программа фильтрации может обрабатывать эти пакеты.  
  
> [!NOTE]  
>  Добавочное, ручное и автоматическое заполнение отслеживания изменений (в отличие от полного заполнения) не рассчитаны на максимальную загрузку ресурсов оборудования ради повышения скорости работы. Поэтому данные предложения по настройке могут не дать результата в виде повышения производительности полнотекстового индексирования.  
  
 После завершения операции заполнения инициируется заключительный процесс слияния фрагментов индекса в один главный полнотекстовый индекс. Это повышает производительность запросов за счет использования одного главного индекса вместо нескольких фрагментов индексов и позволяет использовать более точные количественные оценки для ранжирования данных по релевантности. Обратите внимание, что слияние в единый файл может сильно нагружать подсистему ввода-вывода вследствие записи и чтения больших объемов данных, но не приводит к блокировке входящих запросов.  
  
> [!IMPORTANT]  
>  При слиянии больших объемов данных в единый файл может создаваться транзакция с большим временем выполнения, в результате чего усечение журнала транзакций по достижении контрольной точки будет отложено. В этом случае размер журнала транзакций в модели полного восстановления может значительно увеличиться. Перед реорганизацией большого полнотекстового индекса в базе данных, использующей модель полного восстановления, убедитесь, что в журнале транзакций достаточно свободного места для транзакций с большим временем выполнения. Дополнительные сведения см. в разделе [Управление размером файла журнала транзакций](../logs/manage-the-size-of-the-transaction-log-file.md).  
  
  
  
##  <a name="tuning"></a> Настройка производительности полнотекстовых индексов  
 Чтобы получить максимальную производительность полнотекстовых индексов, воспользуйтесь следующими рекомендациями.  
  
-   Чтобы использовать все процессоры или ядра до максимального, задайте [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql)"`max full-text crawl ranges`" числу процессоров в системе. Сведения об этом параметре конфигурации см. в разделе [Параметр конфигурации сервера max full-text crawl range](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md).  
  
-   Убедитесь, что для базовой таблицы установлен кластеризованный индекс. Первый столбец кластеризованного индекса должен иметь целочисленный тип данных. Старайтесь не использовать идентификатор GUID в качестве первого столбца кластеризованного индекса. Многодиапазонное заполнение кластеризованного индекса может обеспечить наивысшую скорость заполнения. Рекомендуется, чтобы столбец, служащий в качестве полнотекстового ключа, имел целочисленный тип данных.  
  
-   Обновите статистику базовой таблицы с помощью инструкции [UPDATE STATISTICS](/sql/t-sql/statements/update-statistics-transact-sql) . Еще важнее обновить статистику кластеризованного индекса или полнотекстового ключа для полного заполнения. Это позволит при многодиапазонном заполнении сформировать для таблицы хорошие секции.  
  
-   Создайте вторичный индекс по столбцу `timestamp`, если нужно повысить производительность добавочного заполнения.  
  
-   Перед выполнением полного заполнения на мощном многопроцессорном компьютере рекомендуется временно ограничить размер буферного пула, задав для параметра `max server memory` значение, оставляющее достаточно памяти для процесса fdhost.exe и для использования операционной системой. Дополнительные сведения см. в подразделе «Оценка требований к памяти для хост-процесса управляющей программы полнотекстовой фильтрации (fdhost.exe)» далее в этом разделе.  
  
  
  
##  <a name="full"></a> Устранение неполадок с производительностью полного заполнения  
 Для диагностики проблем производительности следует изучить журналы полнотекстового сканирования. Сведения о журналах сканирования см. в разделе [Заполнение полнотекстовых индексов](../indexes/indexes.md).  
  
 Если производительность полного заполнения неудовлетворительна, то следует выполнить следующие шаги по устранению неполадок.  
  
### <a name="physical-memory-usage"></a>Использование физической памяти  
 Во время полнотекстового заполнения существует вероятность того, что у процесса fdhost.exe или sqlservr.exe произойдет нехватка или переполнение памяти. Если журнал полнотекстового сканирования показывает, что fdhost.exe часто перезапускается или возвращает код ошибки 8007008, то это значит, что одному из этих процессов не хватает памяти. Если процесс fdhost.exe создает дампы (особенно на мощных, многопроцессорных компьютерах), то ему может не хватать памяти.  
  
> [!NOTE]  
>  Сведения о буферах памяти, используемых полнотекстовым сканированием, см. в разделе [sys.dm_fts_memory_buffers (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql).  
  
 Возможны следующие причины.  
  
-   Если объем физической памяти, доступный во время полного заполнения, равен нулю, то большая часть физической памяти системы может использоваться буферным пулом [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .  
  
     Процесс sqlservr.exe пытается захватить всю доступную память для буферного пула, ограничиваясь установленным максимумом памяти сервера. Если для `max server memory` выделено слишком много памяти, в процессе fdhost.exe process могут возникнуть проблемы с недостатком памяти и сбои при выделении общей памяти.  
  
    > [!NOTE]  
    >  Во время проведения полнотекстового заполнения на многопроцессорном компьютере может возникнуть конфликт между процессами fdhost.exe и sqlservr.exe за память буферного пула. Возникающая в результате этого нехватка общей памяти вызывает повторы пакетов, пробуксовку памяти и создание дампов процессом fdhost.exe.  
  
     Эти проблемы можно устранить, задав для параметра `max server memory` значение, приблизительно равное размеру буферного пула в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в подразделе «Оценка требований к памяти для хост-процесса управляющей программы полнотекстовой фильтрации (fdhost.exe)» далее в этом разделе. Разрешить проблему можно, уменьшив размер пакета, используемого для полнотекстового индексирования.  
  
-   Проблема с подкачкой.  
  
     Недостаточный размер файла подкачки (например, если в системе задан небольшой файл подкачки с ограниченным ростом) также может вызвать переполнение памяти для процессов fdhost.exe и sqlservr.exe.  
  
     Если в журналах сканирования не зарегистрированы сбои, связанные с памятью, то, скорее всего, проблемы с производительностью вызваны излишней подкачкой.  
  
  
  
### <a name="estimating-the-memory-requirements-of-the-filter-daemon-host-process-fdhostexe"></a>Оценка требований к памяти процесса узла управляющей программы фильтрации (fdhost.exe)  
 Объем памяти, необходимый процессу fdhost.exe для заполнения, зависит в основном от числа используемых диапазонов полнотекстового сканирования, размера входящей общей памяти (ISM) и максимального числа экземпляров ISM.  
  
 Объем памяти (в байтах), занимаемый узлом управляющей программы фильтрации, может быть примерно рассчитан с использованием следующей формулы:  
  
 *number_of_crawl_ranges* \`ism_size "*max_outstanding_isms* \* 2  
  
 Ниже приводятся значения по умолчанию для переменных в приведенной выше формуле.  
  
|**Переменная**|**Значение по умолчанию**|  
|------------------|-----------------------|  
|*number_of_crawl_ranges*|Число процессоров|  
|*ism_size*|1 МБ для компьютеров x86<br /><br /> 4, 8 и 16 МБ для компьютеров для компьютеров x64 (в зависимости от общего объема физической памяти)|  
|*max_outstanding_isms*|25 МБ для компьютеров x86<br /><br /> 5 для компьютеров x64|  
  
 В следующей таблице представлены рекомендации по оценке требований к памяти fdhost.exe. В формулах данной таблицы используются следующие значения.  
  
-   *F*: оценка объема памяти, необходимого для fdhost.exe (в МБ).  
  
-   *T*: общий объем физической памяти, доступной в системе (в МБ).  
  
-   *M*, что является оптимальным `max server memory` параметр.  
  
> [!IMPORTANT]  
>  Основные сведения о формулах см. в разделе <sup>1</sup>, <sup>2</sup>, и <sup>3</sup>ниже.  
  
|Платформа|Оценка требований к памяти fdhost.exe в МБ -*F*<sup>1</sup>|Формула для вычисления значения max server памяти -*M*<sup>2</sup>|  
|--------------|---------------------------------------------------------------------|---------------------------------------------------------------|  
|x86|_F_ **=** _число диапазонов сканирования_ **&#42;** 50|_M_ **= минимальное (** _T_ **,** 2000 **)-*`F`* -**  500|  
|x64|_F_ **=** _число диапазонов сканирования_ **&#42;** 10 **&#42;** 8|_M_ **=** _T_ **-** _F_ **-** 500|  
  
 <sup>1</sup> Если выполняется несколько полных заполнений, вычислять требования к памяти fdhost.exe для каждого из них отдельно, как *F1*, *F2*, и т. д. Затем вычислить *M* как _T_**-** sigma **(**_F_i **)**.  
  
 <sup>2</sup> 500 МБ: ориентировочный объем памяти, необходимый другим процессам в системе. Если система выполняет дополнительную работу, то это значение следует соответствующим образом увеличить.  
  
 <sup>3</sup> . *ism_size* полагается равным 8 МБ для x64 платформ.  
  
 **Пример. Оценка требований к памяти fdhost.exe**  
  
 В данном примере используется компьютер AMD64 с 8 ГБ ОЗУ и четырьмя двухъядерными процессорами. Первое вычисление оценивает объем памяти, необходимый для fdhost.exe, — *F*. Число диапазонов сканирования: `8`.  
  
 `F = 8*10*8=640`  
  
 Следующем вычислении получается оптимальное значение для `max server memory` - *M*. *T*бщий объем физической памяти, доступной в системе в МБ -*T*-является `8192`.  
  
 `M = 8192-640-500=7052`  
  
 **Пример. Параметр Макс. памяти сервера**  
  
 В этом примере используется [sp_configure](/sql/relational-databases/system-stored-procedures/sp-configure-transact-sql) и [ПЕРЕНАСТРОИТЬ](/sql/t-sql/language-elements/reconfigure-transact-sql) [!INCLUDE[tsql](../../../includes/tsql-md.md)] инструкции для установки `max server memory` для значения, вычисленные для *M* в предыдущем примере , `7052`:  
  
```  
USE master;  
GO  
EXEC sp_configure 'max server memory', 7052;  
GO  
RECONFIGURE;  
GO  
```  
  
 **Чтобы задать max server memory, параметр конфигурации**  
  
-   [Параметры конфигурации сервера «Server Memory»](../../database-engine/configure-windows/server-memory-server-configuration-options.md)  
  
  
  
### <a name="factors-that-can-reduce-cpu-consumption"></a>Факторы, которые могут снизить нагрузку на ЦП  
 Производительность полного заполнения считается неоптимальной, если уровень загруженности ЦП ниже 30%. В данном разделе обсуждаются некоторые факторы, которые влияют на уровень загруженности ЦП.  
  
-   Высокие значения ожиданий для страниц.  
  
     Чтобы определить, является ли значение времени ожидания страницы высоким, выполните следующую инструкцию [!INCLUDE[tsql](../../../includes/tsql-md.md)] .  
  
    ```  
    Execute SELECT TOP 10 * FROM sys.dm_os_wait_stats ORDER BY wait_time_ms DESC;  
    ```  
  
     В следующей таблице описаны типы значений ожидания, представляющие интерес.  
  
    |Тип ожидания|Описание|Возможное решение|  
    |---------------|-----------------|-------------------------|  
    |PAGEIO_LATCH_SH (_EX или _UP)|Это может свидетельствовать о наличии узкого места в подсистеме ввода-вывода. В этом случае средняя длина очереди диска обычно велика.|Перемещение полнотекстового индекса в другую файловую группу на другом диске может помочь снизить влияние узкого места в операциях ввода-вывода.|  
    |PAGELATCH_EX (или _UP)|Это может свидетельствовать о высокой конкуренции между потоками, которые пытаются выполнить запись в один и тот же файл базы данных.|Уровень конкуренции можно снизить, добавив файлы в файловую группу, в которой расположен полнотекстовый индекс.|  
  
     Дополнительные сведения см. в разделе [sys.dm_os_wait_stats (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql).  
  
-   Неэффективное сканирование базовой таблицы.  
  
     Во время создания пакетов при полном заполнении производится просмотр базовой таблицы. Ее сканирование может оказаться неэффективным в следующих случаях.  
  
    -   Если в базовой таблице присутствует высокий процент столбцов, значения в которых хранятся вне строк, для которых выполняется полнотекстовое индексирование, то узким местом может оказаться сканирование базовой таблицы для создания пакетов. В этом случае можно попробовать решить проблему, переместив значения данных с небольшими длинами в строки, используя типы `varchar(max)` и `nvarchar(max)`.  
  
    -   Сканирование может выполняться неэффективно в том случае, если базовая таблица имеет высокую степень фрагментации. Сведения о вычислении данных вне строк и фрагментации индекса см. в разделах [sys.dm_db_partition_stats (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-partition-stats-transact-sql) и [sys.dm_db_index_physical_stats (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).  
  
         Чтобы снизить уровень фрагментации, можно выполнить реорганизацию или перестроение кластеризованного индекса. Дополнительные сведения см. в статье [Реорганизация и перестроение индексов](../indexes/reorganize-and-rebuild-indexes.md).  
  
  
  
##  <a name="filters"></a> Устранение неполадок снижением производительности индексации фильтры  
 При заполнении полнотекстового индекса инструмент полнотекстового поиска использует два типа фильтров: многопоточные и однопоточные. Некоторые документы, например документы [!INCLUDE[msCoName](../../includes/msconame-md.md)] Word, фильтруются с помощью многопоточного фильтра. Другие, например документы формата Adobe Acrobat Portable Document Format (PDF), фильтруются с помощью однопоточного фильтра.  
  
 Из соображений безопасности фильтры загружаются процессами узла управляющей программы фильтрации. Экземпляр сервера использует многопоточный процесс для всех многопоточных фильтров и однопоточный процесс для однопоточных фильтров. Если документ, использующий многопоточный фильтр, содержит внедренный документ, использующий однопоточный фильтр, средство полнотекстового поиска запускает однопоточный процесс для внедренного документа. Например, если документ Word содержит PDF-документ, средство полнотекстового поиска использует многопоточный процесс для содержимого Word и запускает однопоточный процесс для PDF-содержимого. Однако однопоточный фильтр может неправильно работать в такой среде, дестабилизируя процесс фильтрации. В некоторых обстоятельствах, когда часто встречаются такие внедрения, дестабилизация может привести к сбою процесса фильтрации. В этом случае средство полнотекстового поиска перенаправляет сбойный документ (например, документ Word, содержащий внедренный PDF-документ) в однопоточный процесс фильтрации. Если перенаправление происходит достаточно часто, производительность полнотекстового индексирования снижается.  
  
 Для устранения этой проблемы необходимо пометить фильтр для документа-контейнера (в данном случае Microsoft Word) как однопоточный фильтр. Чтобы пометить фильтр как однопоточный, можно изменить значение для этого фильтра в реестре. Чтобы пометить фильтр как однопоточный фильтр, необходимо задать **ThreadingModel** значение реестра для этого фильтра `Apartment Threaded`. Сведения об однопоточных подразделениях см. в техническом документе [Общие сведения о моделях потоков COM и их использовании](https://go.microsoft.com/fwlink/?LinkId=209159).  
  
  
  
## <a name="see-also"></a>См. также:  
 [Параметры конфигурации сервера «Server Memory»](../../database-engine/configure-windows/server-memory-server-configuration-options.md)   
 [Параметр конфигурации сервера max full-text crawl range](../../database-engine/configure-windows/max-full-text-crawl-range-server-configuration-option.md)   
 [Заполнение полнотекстовых индексов](populate-full-text-indexes.md)   
 [Создание и управление полнотекстовыми индексами](create-and-manage-full-text-indexes.md)   
 [sys.dm_fts_memory_buffers (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-buffers-transact-sql)   
 [sys.dm_fts_memory_pools (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/sys-dm-fts-memory-pools-transact-sql)   
 [Устранение неполадок полнотекстового индексирования](troubleshoot-full-text-indexing.md)  
  
  
