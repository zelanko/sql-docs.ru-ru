---
title: Оптимизация трассировки SQL | Документация Майкрософт
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- time [SQL Server], traces
- SQL Trace, performance
- traces [SQL Server], performance
- performance [SQL Server], trace
ms.assetid: 50944218-925f-4576-aec8-4379846d7681
caps.latest.revision: 24
author: JennieHubbard
ms.author: jhubbard
manager: jhubbard
ms.openlocfilehash: 4948fc77e023bfc8ce63c45f38013886fae4e889
ms.sourcegitcommit: 5dd5cad0c1bbd308471d6c885f516948ad67dfcf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/19/2018
ms.locfileid: "36095893"
---
# <a name="optimize-sql-trace"></a>Оптимизация трассировки SQL
  Выполнение трассировки SQL негативно сказывается на производительности, поскольку этот процесс использует системные ресурсы для сбора данных, однако существует несколько способов минимизировать потери производительности. Чтобы минимизировать потери производительности, вызванные трассировкой:  
  
-   Рассмотрите возможность использования командной строки для запуска трассировок. Использование графического пользовательского интерфейса уменьшает производительность. Дополнительные сведения см. в разделе [sp_trace_create (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-trace-create-transact-sql).  
  
-   Избегайте включения часто возникающих событий. По возможности сократите трассировку посредством особых классов событий и фильтров. Чем меньше собирается событий трассировки, тем меньше требуется ресурсов для ее поддержания.  
  
-   Настройте трассировку на сбор только тех событий, которые содержат нужные данные. Например, если трассировка должна определить взаимоблокировки, включите в нее класс событий **Lock:Deadlock** , а не **Lock:Acquired** . Если включить в трассировку оба класса событий, она будет отвечать на каждую полученную блокировку и производительность снизится в два раза.  
  
-   Старайтесь не собирать дублирующиеся данные. Например, собирая **SQL:BatchStarted** и **SQL:BatchCompleted**, можно минимизировать размер результирующего набора, выбрав только текстовые данные для класса событий **SQL:BatchStarted** .  
  
-   Используйте фильтры в определении трассировки. Например, если известно, что определенный пользователь страдает от низкой производительности во время нерегламентированных запросов, создайте фильтр для **LoginName**. Настройте фильтр так, чтобы включались только события, в которых **LoginName** совпадает с именем пользователя.  
  
 Если необходимо запустить трассировку для событий, которая повлечет за собой серьезное снижение производительности, попробуйте следующие способы ограничения влияния на производительность сервера:  
  
-   Запускайте трассировки на более короткие промежутки времени. Время выполнения трассировки можно контролировать, включив время остановки. Это особенно важно, если нет возможности ограничить классы событий или установить фильтры. Время остановки гарантирует, что потери производительности не будут бесконечными.  
  
-   Ограничьте размер результатов трассировки. Можно ограничить размер результатов трассировки до максимального размера файла. Такая стратегия гарантирует, что потери производительности прекратятся, когда будет достигнуто ограничение по размеру файла (если не включена операция переключения на файл продолжения).  
  
-   Ограничьте число возвращаемых событий. В [!INCLUDE[ssSqlProfiler](../../../includes/sssqlprofiler-md.md)] можно ограничить число возвращаемых событий, сохранив трассировку в таблицу с установленным максимальным числом строк. Результаты трассировки продолжают возвращаться на экран [!INCLUDE[ssSqlProfiler](../../../includes/sssqlprofiler-md.md)] после достижения максимального числа строк, но при этом можно избежать затрат производительности на запись результатов.  
  
## <a name="see-also"></a>См. также  
 [Фильтрация трассировки](../sql-trace/filter-a-trace.md)  
  
  
