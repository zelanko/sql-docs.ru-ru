---
title: Основные сведения о типах курсоров | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: 4f4d3db7-4f76-450d-ab63-141237a4f034
author: MightyPen
ms.author: genemi
ms.openlocfilehash: dbd7e3622df44d6b696b56745495b684d6100eb1
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MTE75
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2019
ms.locfileid: "68004184"
---
# <a name="understanding-cursor-types"></a>Основные сведения о типах курсоров
[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

  Операции в реляционной базе данных выполняются над множеством строк. Набор строк, возвращаемый инструкцией SELECT, содержит все строки, которые удовлетворяют условиям, указанным в предложении WHERE инструкции. Такой полный набор строк, возвращаемых инструкцией, называется результирующим набором. Приложения не всегда могут эффективно работать с результирующим набором, представляющим единое целое. Им нужен механизм, позволяющий обрабатывать одну строку или небольшое их число за один раз. Курсоры являются расширением результирующих наборов, которые предоставляют такой механизм.  
  
 Курсоры расширяют возможности обработки результирующего набора, выполняя следующие функции:  
  
-   позиционируясь на отдельные строки результирующего набора;  
  
-   получая одну или несколько строк от текущей позиции в результирующем наборе;  
  
-   поддерживая изменение данных в строке, находящейся в текущей позиции в результирующем наборе;  
  
-   поддерживая разные уровни видимости изменений, сделанных другими пользователями для данных, представленных в результирующем наборе;  
  
> [!NOTE]  
>  Полное описание типов курсоров [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] см. в разделе "Типы курсоров (ядро СУБД)" электронной документации по [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
 Спецификация JDBC обеспечивает поддержку однопроходных курсоров и прокручиваемых курсоров, которые могут учитывать или не учитывать изменения, выполненные другими заданиями, а также быть доступными только для чтения или допускать обновление. Эта функциональность обеспечивается классом [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)][SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md).  
  
## <a name="remarks"></a>Remarks  
 Драйвер JDBC поддерживает следующие типы курсоров.  
  
|Результирующий набор<br /><br /> результирующего набора|Тип курсора SQL Server|Характеристики|select<br /><br /> Метод|Буферизация<br /><br /> ответов|Описание|  
|------------------------------------|----------------------------|---------------------|-----------------------|----------------------------|-----------------|  
|TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)|Недоступно|Однонаправленный, только для чтения|direct|переполненные|Приложение выполняет один (однонаправленный) проход по результирующему набору. Этот режим активен по умолчанию и действует аналогично курсору TYPE_SS_DIRECT_FORWARD_ONLY. Драйвер считывает весь результирующий набор с сервера в память во время выполнения инструкции.|  
|TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)|Недоступно|Однонаправленный, только для чтения|direct|adaptive|Приложение выполняет один (однонаправленный) проход по результирующему набору. Работает аналогично курсору TYPE_SS_DIRECT_FORWARD_ONLY. Драйвер считывает строки с сервера по мере того как приложение запрашивает строки. Это позволяет снизить загрузку памяти на стороне клиента.|  
|TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)|Быстрый однопроходный|Однонаправленный, только для чтения|курсор|Недоступно|Приложение должно выполнить один (однонаправленный) проход по результирующему набору, используя серверный курсор. Работает аналогично курсору TYPE_SS_SERVER_CURSOR_FORWARD_ONLY.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)|Динамический (однопроходный)|Однопроходный, обновляемый|Недоступно|Недоступно|Приложение должно выполнить один (однонаправленный) проход по результирующему набору, чтобы обновить одну или несколько строк.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.<br /><br /> По умолчанию размер выборки фиксируется, когда приложение вызывает метод [setFetchSize](../../connect/jdbc/reference/setfetchsize-method-sqlserverresultset.md) объекта [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md).<br /><br /> **Примечание**. Драйвер JDBC предоставляет функцию адаптивной буферизации, которая позволяет получать результаты выполнения инструкций от [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по запросу приложения, а не все сразу. Например, если приложение должно получить данные, которые не могут полностью разместиться в памяти приложения, адаптивная буферизация позволяет клиентскому приложению получать значения в виде потока. По умолчанию в драйвере применяется режим "**adaptive**". Однако, чтобы включить адаптивную буферизацию для однопроходных обновляемых результирующих наборов, приложение должно явно вызвать метод [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md) объекта [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md), предоставив значение типа **String** ("**adaptive"** ). Пример кода см. в разделе [Пример обновления больших данных](../../connect/jdbc/updating-large-data-sample.md).|  
|TYPE_SCROLL_INSENSITIVE|Статические|Прокручиваемый, без поддержки обновления.<br /><br /> Внешние операции обновления, вставки и удаления строк не видимы.|Недоступно|Недоступно|Приложению требуется моментальный снимок базы данных. Результирующий набор не поддерживает обновление. Поддерживается только CONCUR_READ_ONLY.  Все остальные типы параллелизмы в случае использования с этим типом курсора вызывают исключение.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SCROLL_SENSITIVE<br /><br /> (CONCUR_READ_ONLY)|Keyset|Прокручиваемый, только для чтения. Внешние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные.<br /><br /> Внешние операции вставки невидимы.|Недоступно|Недоступно|Приложению должны быть видимы только измененные данные для существующих строк.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SCROLL_SENSITIVE<br /><br /> (CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)|Keyset|Прокручиваемый, обновляемый.<br /><br /> Внешние и внутренние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные; операции вставки невидимы.|Недоступно|Недоступно|Приложение может изменять данные в существующих строках с помощью объекта ResultSet. Приложению также должны быть видимы изменения в строках, выполненные другими пользователями вне объекта ResultSet.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SS_DIRECT_FORWARD_ONLY|Недоступно|Однонаправленный, только для чтения|Недоступно|Полная или адаптивная|Целое значение = 2003. Предоставляет клиентский курсор, доступный только для чтения, с полной буферизацией. Серверный курсор не создается.<br /><br /> Поддерживается только тип параллелизма CONCUR_READ_ONLY. Все остальные типы параллелизмы в случае использования с этим типом курсора вызывают исключение.|  
|TYPE_SS_SERVER_CURSOR_FORWARD_ONLY|Быстрый однопроходный|Однонаправленный|Недоступно|Недоступно|Целое значение = 2004. Быстрый режим, доступ ко всем данным выполняется с помощью серверного курсора. В случае использования с типом параллелизма CONCUR_UPDATABLE возможно обновление.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.<br /><br /> Чтобы включить адаптивную буферизацию в этом случае, приложение должно явно вызвать метод [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md) объекта [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md), указав значение типа **String** ("**adaptive"** ). Пример кода см. в разделе [Пример обновления больших данных](../../connect/jdbc/updating-large-data-sample.md).|  
|TYPE_SS_SCROLL_STATIC|Статические|Не отражает обновления, выполненные другими пользователями.|Недоступно|Недоступно|Целое значение = 1004. Приложению требуется моментальный снимок базы данных. Это синоним [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для типа JDBC TYPE_SCROLL_INSENSITIVE, который имеет те же параметры параллелизма по умолчанию.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SS_SCROLL_KEYSET<br /><br /> (CONCUR_READ_ONLY)|Keyset|Прокручиваемый, только для чтения. Внешние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные.<br /><br /> Внешние операции вставки невидимы.|Недоступно|Недоступно|Целое значение = 1005. Приложению должны быть видимы только измененные данные для существующих строк. Это синоним [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для типа JDBC TYPE_SCROLL_SENSITIVE, который имеет те же параметры параллелизма по умолчанию.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SS_SCROLL_KEYSET<br /><br /> (CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)|Keyset|Прокручиваемый, обновляемый.<br /><br /> Внешние и внутренние обновления строки являются видимыми, а операции удаления отображаются как отсутствующие данные; операции вставки невидимы.|Недоступно|Недоступно|Целое значение = 1005. Приложение должно изменять данные, или для него должны быть видимыми измененные данные для существующих строк. Это синоним [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для типа JDBC TYPE_SCROLL_SENSITIVE, который имеет те же параметры параллелизма по умолчанию.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SS_SCROLL_DYNAMIC<br /><br /> (CONCUR_READ_ONLY)|Динамический|Прокручиваемый, только для чтения.<br /><br /> Внешние операции обновления и вставки строк являются видимыми, а операции удаления представляются как временно отсутствующие данные в текущем буфере выборки.|Недоступно|Недоступно|Целое значение = 1006. Приложению должны быть видимы измененные данные для существующих строк, а также вставленные и обновленные строки за время существования курсора.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
|TYPE_SS_SCROLL_DYNAMIC<br /><br /> (CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)|Динамический|Прокручиваемый, обновляемый.<br /><br /> Внешние и внутренние операции обновления и вставки строк являются видимыми, а операции удаления представляются как временно отсутствующие данные в текущем буфере выборки.|Недоступно|Недоступно|Целое значение = 1006. Приложение может изменять данные для существующих строк, а также вставлять и удалять строки с помощью объекта ResultSet. Приложению также должны быть видимы изменения в строках, операции вставки и удаления, выполненные другими пользователями вне объекта ResultSet.<br /><br /> Строки извлекаются с сервера блоками, размер которых определяется размером выборки.|  
  
## <a name="cursor-positioning"></a>Позиционирование курсоров  
 Курсоры TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY и TYPE_SS_SERVER_CURSOR_FORWARD_ONLY поддерживают только метод позиционирования [next](../../connect/jdbc/reference/next-method-sqlserverresultset.md).  
  
 Курсор TYPE_SS_SCROLL_DYNAMIC не поддерживает методы [absolute](../../connect/jdbc/reference/absolute-method-sqlserverresultset.md) и [getRow](../../connect/jdbc/reference/getrow-method-sqlserverresultset.md). Действие метода absolute можно приблизительно заменить сочетанием вызова методов [first](../../connect/jdbc/reference/first-method-sqlserverresultset.md) и [relative](../../connect/jdbc/reference/relative-method-sqlserverresultset.md) для динамических курсоров.  
  
 Метод getRow поддерживается только курсорами TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET и TYPE_SS_SCROLL_STATIC. Метод getRow для всех типов однопроходных курсоров возвращает количество строк, считанных в курсоре на данный момент.  
  
> [!NOTE]  
>  Если приложение выполняет неподдерживаемый вызов позиционирования курсора или неподдерживаемый вызов метода getRow, возникает исключение с сообщением "Запрошенная операция не поддерживается с этим типом курсора".  
  
 Доступ к удаленным строкам предоставляется только курсорами TYPE_SS_SCROLL_KEYSET и эквивалентными курсорами TYPE_SCROLL_SENSITIVE. Если курсор позиционируется в удаленной строке, то значения столбцов недоступны, а метод [rowDeleted](../../connect/jdbc/reference/rowdeleted-method-sqlserverresultset.md) возвращает значение True. Вызовы метода get\<Type> приводят к созданию исключения с сообщением "Не удается получить значение из удаленной строки". Удаленные строки нельзя обновлять. Если вызвать метод update\<Type> для удаленной строки, создается исключение с сообщением "Не удается обновить удаленную строку". Курсор TYPE_SS_SCROLL_DYNAMIC работает аналогичным образом, пока не выходит за пределы текущего буфера выборки.  
  
 Однопроходные и динамические курсоры предоставляют доступ к удаленным строкам аналогичным образом, но только при условии, что курсоры остаются доступными в буфере выборки. Для однопроходных курсоров это реализуется довольно очевидным образом. Для динамических курсоров ситуация усложняется в случае, когда размер выборки превышает 1. Приложение может перемещать курсор в обоих направлениях в пределах окна, заданного буфером выборки, однако удаленная строка будет исчезать, когда курсор будет покидать исходный буфер выборки, в котором была обновлена строка. Если временно удаленные строки не должны отображаться приложению, использующему динамические курсоры, следует использовать относительную выборку (0).  
  
 Если значения ключа для строки курсора TYPE_SS_SCROLL_KEYSET или TYPE_SCROLL_SENSITIVE обновляются с помощью курсора, то строка сохраняет исходную позицию в результирующем наборе независимо от того, отвечает ли обновленная строка условиям выборки курсора. Если строка обновляется вне курсора, то удаленная строка будет выводиться в исходной позиции строки, однако будет видна в курсоре только в том случае, если там ранее присутствовала другая строка с новыми значениями ключа, но затем была удалена.  
  
 Для динамических курсоров обновленные строки будут сохранять свои позиции в буфере выборки, пока курсор не покинет окно, определенное буфером выборки. Обновленные строки могут вновь появляться в других позициях в результирующем наборе или полностью исчезать. Приложения, которые должны избегать временной потери согласованности в результирующем наборе, должны использовать размер выборки 1 (по умолчанию используется 8 строк для параллелизма CONCUR_SS_SCROLL_LOCKS и 128 строк для остальных режимов параллелизма).  
  
## <a name="cursor-conversion"></a>Преобразование курсоров  
 Иногда [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может реализовать тип курсора, отличный от запрошенного. Это называется неявным преобразованием курсора (или ухудшением курсора). Дополнительные сведения о неявных преобразованиях курсоров см. в разделе "Использование неявных преобразований курсоров" электронной документации по [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
 В [!INCLUDE[ssVersion2000](../../includes/ssversion2000-md.md)]при обновлении данных с помощью результирующего набора ResultSet. TYPE_SCROLL_SENSITIVE и ResultSet. CONCUR_UPDATABLE создается исключение с сообщением "курсор доступен только для чтения". Это исключение создается, так как [!INCLUDE[ssVersion2000](../../includes/ssversion2000-md.md)] выполнил неявное преобразование курсора для этого результирующего набора и не вернул запрошенный обновляемый курсор.  
  
 Для этой проблемы существует два возможных решения.  
  
-   Убедитесь, что базовая таблица содержит первичный ключ.  
  
-   Используйте [SQLServerResultSet. TYPE_SS_SCROLL_DYNAMIC](../../connect/jdbc/reference/type-ss-scroll-dynamic-field-sqlserverresultset.md) вместо RESULTSET. TYPE_SCROLL_SENSITIVE при создании инструкции.  
  
## <a name="cursor-updating"></a>Обновление курсоров  
 Обновления на месте поддерживаются для курсоров, если тип курсора и тип параллелизма поддерживают обновления. Если курсор не располагается в обновляемой строке в результирующем наборе (метод get\<Type> не завершился успешно), то вызов метода update\<Type> приведет к созданию исключения с сообщением "Результирующий набор не содержит текущую строку". В спецификации JDBC утверждается, что если метод обновления вызывается для столбца курсора, имеющего тип CONCUR_READ_ONLY, то создается исключение. В ситуациях, когда строка недоступна для обновления, например из-за конфликта оптимистичного параллелизма в случае конкурирующих операций обновления или удаления, исключение может не создаваться до вызова метода [insertRow](../../connect/jdbc/reference/insertrow-method-sqlserverresultset.md), [updateRow](../../connect/jdbc/reference/updaterow-method-sqlserverresultset.md) или [deleteRow](../../connect/jdbc/reference/deleterow-method-sqlserverresultset.md).  
  
 После вызова метода Update\<Type > к затронутому столбцу нельзя получить доступ с помощью Get\<Type > до вызова updateRow или [cancelRowUpdates](../../connect/jdbc/reference/cancelrowupdates-method-sqlserverresultset.md) . Это позволяет избежать проблем, когда столбец обновляется с использованием типа, который отличается от типа, возвращенного сервером, а последующие вызовы метода считывания могут привести к преобразованиям типа на клиентской стороне, которые дают неточные результаты. Вызовы get\<Type> создают исключение с сообщением "Доступ к обновляемым столбцам невозможен до вызова метода updateRow() или cancelRowUpdates()".  
  
> [!NOTE]  
>  Если метод updateRow вызван, когда столбцы не обновлены, драйвер JDBC вызывает исключение с сообщением "Метод updateRow() вызван, когда столбцы не обновлены".  
  
 После вызова метода [moveToInsertRow](../../connect/jdbc/reference/movetoinsertrow-method-sqlserverresultset.md) исключение будет создаваться в случае вызова для результирующего набора любого метода, кроме методов get\<Type>, update\<Type>, insertRow и методов позиционирования курсора (включая [moveToCurrentRow](../../connect/jdbc/reference/movetocurrentrow-method-sqlserverresultset.md)). Метод moveToInsertRow фактически переводит результирующий набор в режим вставки, а методы позиционирования курсора отменяют режим вставки. Вызовы относительного позиционирования курсора перемещают курсор относительно позиции, в которой он находился перед вызовом moveToInsertRow. После вызова позиционирования курсора ожидаемая позиция назначения становится новой позицией курсора.  
  
 Если вызов позиционирования курсора, выполненный в режиме вставки, не завершается успешно, то позицией курсора после сбоя вызова будет исходная позиция курсора до вызова метода moveToInsetRow. Если метод insertRow завершается сбоем, то курсор остается в строке вставки в режиме вставки.  
  
 Столбцы в строке вставке первоначально находятся в неинициализированном состоянии. Вызовы метода update\<Type> устанавливают инициализированное состояние столбца. Вызов метода get\<Type> для неинициализированного столбца приводит к созданию исключения. Вызов метода insertRow возвращает все столбцы в строке вставки в неинициализированное состояние.  
  
 Если в момент вызова метода insertRow какие-либо столбцы не инициализированы, то вставляется значение по умолчанию для столбца. Если значение по умолчанию отсутствует, но столбец допускает значение NULL, то вставляется значение NULL. Если отсутствует значение по умолчанию, и столбец не допускает значения NULL, то сервер возвращает ошибку, и создается исключение.  
  
> [!NOTE]  
>  Вызовы метода getRow в режиме вставки возвращают значение 0.  
>   
>  Драйвер JDBC не поддерживает позиционированные операции обновления и удаления. В соответствии со спецификацией JDBC метод [setCursorName](../../connect/jdbc/reference/setcursorname-method-sqlserverstatement.md) не имеет эффекта, и в случае вызова метода [getCursorName](../../connect/jdbc/reference/getcursorname-method-sqlserverresultset.md) создается исключение.  
>   
>  Статические курсоры и курсоры, доступные только для чтения, никогда не поддерживают обновление.  
>   
>  SQL Server ограничивает использование серверных курсоров единственным результирующим набором. Если пакет или хранимая процедура содержит несколько инструкций, то необходимо использовать клиентский однопроходный курсор, доступный только для чтения.  
  
## <a name="see-also"></a>См. также:  
 [Управление результирующими наборами с помощью драйвера JDBC](../../connect/jdbc/managing-result-sets-with-the-jdbc-driver.md)  
  
  
