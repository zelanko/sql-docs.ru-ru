---
title: Общие сведения о данных преобразования типов | Документация Майкрософт
ms.custom: ''
ms.date: 07/11/2018
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
ms.assetid: 98fa7488-aac3-45b4-8aa4-83ed6ab638b4
caps.latest.revision: 34
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 0164fdcfebdf0fb92aac1f37820495ad8e591a41
ms.sourcegitcommit: 2f9cafc1d7a3773a121bdb78a095018c8b7c149f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/08/2018
ms.locfileid: "39662206"
---
# <a name="understanding-data-type-conversions"></a>Общие сведения о преобразованиях типов данных

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

Чтобы упростить преобразование типов данных языка программирования Java в типы данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)], драйвер [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] реализует преобразование типов данных в соответствии с требованиями спецификации JDBC. Повышенная гибкость обеспечивается тем, могут преобразовываться в строки и из любого типа **объект**, **строка**, и **byte []** типов данных.

## <a name="getter-method-conversions"></a>Преобразование метода считывания

Исходя из типов данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)], на следующей диаграмме показана схема преобразования для драйвера JDBC для методов get\<Type>() класса [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md), а также поддерживаемое преобразование для методов get\<Type> класса [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md).

![JDBCGetterConversions](../../connect/jdbc/media/jdbcgetterconversions.gif "JDBCGetterConversions")

Преобразования, поддерживаемые методами считывания драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для случаев, когда тип метода считывания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода getBigDecimal для базового десятичного столбца сервера преобразование не потребуется.

- **С преобразованием (y)**. Преобразования из числовых типов сервера в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точность всегда усекается (никогда не округляется), а переполнение обрабатывается как остаток от деления на целевой тип, который меньше по размеру. Например, вызов getInt для базового **десятичное** столбец, содержащий значение «1,9999» возвращает «1», или, если базовый **десятичное** значение равно «3000000000» то **int** значение выходит за результат будет равен «1294967296».

- **В зависимости от данных (z)**. Для преобразования из базовых символьных типов в числовые типы требуется, чтобы символьные типы содержали значения, которые могут быть преобразованы в данный тип. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если вызывается метод getInt относительно столбца varchar(50), который содержит значение "53", значение возвращается в виде **int**, однако, если базовое значение ― "xyz" или "3000000000", возникает ошибка.

Если вызывается getString **двоичных**, **varbinary**, **varbinary(max)**, или **изображение** тип данных столбца, значение возвращается в виде шестнадцатеричное значение строки.

## <a name="updater-method-conversions"></a>Преобразование метода обновления

Для данных на языке Java, передаваемых методам update\<Type>() класса [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md), применяются следующие виды преобразования.

![JDBCUpdaterConversions](../../connect/jdbc/media/jdbc_jdbcupdatterconversions.gif "JDBCUpdaterConversions")

Преобразования, поддерживаемые методами обновления драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для случаев, когда тип обновления является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода updateBidDecimal для базового десятичного столбца сервера преобразование не потребуется.

- **С преобразованием (y)**. Преобразования из числовых типов сервера в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точные значения всегда усекаются (и никогда не округляются), а при переполнении значение сокращается по модулю размера типа назначения (меньшего). Например, вызов updateDecimal для базового **int** столбец, содержащий значение «1,9999» возвращает «1», или, если базовый **десятичное** значение равно «3000000000» то **int**переполнение значения, результат будет равен «1294967296».

- **В зависимости от данных (z)**. Для преобразования из типов данных базового источника в типы данных назначения требуется, чтобы содержащиеся значения могли быть преобразованы в типы назначения. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если вызывается метод updateString с аргументом «53» относительно столбца int, обновление завершается успешно; однако если базовое значение строки ― «foo» или «3000000000», возникает ошибка.

При вызове updateString на **двоичных**, **varbinary**, **varbinary(max)**, или **изображение** тип данных столбца, его значение строки обрабатывается как шестнадцатеричное значение строки.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов updateBlob, updateBinaryStream или updateBytes, значение данных должно быть шестнадцатеричное строковое представление XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="setter-method-conversions"></a>Преобразование метода задания

Для данных на языке Javа, передаваемых методам set\<Type>() класса [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) и класса [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md), применяются следующие виды преобразования.

![JDBCSetterConversions](../../connect/jdbc/media/jdbc_jdbcsetterconversions_v2.gif "JDBCSetterConversions")

Сервер проверяет любые виды преобразования и возвращает ошибку при неудачном завершении.

В случае использования **строка** тип данных, если значение превышает длину **VARCHAR**, он сопоставляется **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется **LONGNVARCHAR** если его длина превышает поддерживаемую длину **NVARCHAR**. То же относится и к **byte[]**. Значения длиннее **VARBINARY** становятся **LONGVARBINARY**.

Преобразования, поддерживаемые методами задания драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода setBigDecimal для базового **десятичного** столбца сервера преобразование не потребуется. В случае преобразования числовых данных в символьные тип данных Java **numeric** преобразуется в **String**. Например, вызов метода setDouble со значением "53" относительно столбца varchar(50) формирует символьное значение "53" в целевом столбце.

- **С преобразованием (y)**. Преобразования из типа Java **numeric** в базовый тип сервера **numeric**, меньший по размеру. Такое преобразование выполняется обычным образом и следует соглашениям о преобразованиях в [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)]. Точные значения всегда усекаются (никогда не округляются), а переполнение выводит ошибку неподдерживаемого преобразования. Например, вызов метода updateDecimal со значением "1,9999" для базового целочисленного столбца приводит к сохранению в целевом столбце значения "1", но, если будет передано значение "3000000000", драйвер вызовет исключение.

- **В зависимости от данных (z)**. Преобразования из типа Java **String** в базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] зависят от следующих условий. Драйвер отправляет значение **String** на [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)], а [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] при необходимости выполняет преобразование. Если sendStringParametersAsUnicode имеет значение true, а базовым типом данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] является **image**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] не выполнит преобразование **nvarchar** в **image** и вызовет исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] — **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразование **varchar** в **image**, а исключение не вызывается.

[!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразования и передает ошибки обратно драйверу JDBC, если возникают проблемы.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов updateBlob, updateBinaryStream или updateBytes, значение данных должно быть шестнадцатеричное строковое представление XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="conversions-on-setobject"></a>Преобразование относительно setObject

> [!NOTE]  
> Microsoft JDBC Driver 4.2 (и более поздней версии) для SQL Server поддерживает JDBC 4.1 и 4.2. Дополнительные сведения о версии 4.1 и 4.2 сопоставлениях типов данных и преобразования см. в разделе [соответствие JDBC 4.1 для драйвера JDBC](../../connect/jdbc/jdbc-4-1-compliance-for-the-jdbc-driver.md) и [соответствие JDBC 4.2 для драйвера JDBC](../../connect/jdbc/jdbc-4-2-compliance-for-the-jdbc-driver.md), помимо приведенные ниже сведения.

Для данных на языке Java, передаваемых методам setObject(\<Type>) класса [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md), применяются следующие виды преобразования.

![JDBCSetObjectConversions](../../connect/jdbc/media/jdbc_jdbcsetobjectconversions.gif "JDBCSetObjectConversions")

Метод setObject с неуказанным целевым типом использует сопоставление по умолчанию. В случае использования **строка** тип данных, если значение превышает длину **VARCHAR**, он сопоставляется **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется **LONGNVARCHAR** если его длина превышает поддерживаемую длину **NVARCHAR**. То же относится и к **byte[]**. Значения длиннее **VARBINARY** становятся **LONGVARBINARY**.

Преобразования, поддерживаемые методами setObject драйвера JDBC, делятся на три категории.

- **Без потерь (x)**. Преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода setBigDecimal для базового **десятичного** столбца сервера преобразование не потребуется. В случае преобразования числовых данных в символьные тип данных Java **numeric** преобразуется в **String**. Например, вызов метода setDouble со значением "53" относительно столбца varchar(50) формирует символьное значение "53" в целевом столбце.

- **С преобразованием (y)**. Преобразования из типа Java **numeric** в базовый тип сервера **numeric**, меньший по размеру. Такое преобразование выполняется обычным образом и следует соглашениям о преобразованиях в [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)]. Точные значения всегда усекаются и никогда не округляются, а при переполнении возникает ошибка неподдерживаемого преобразования. Например, вызов метода updateDecimal со значением "1,9999" для базового целочисленного столбца приводит к сохранению в целевом столбце значения "1", но, если будет передано значение "3000000000", драйвер вызовет исключение.

- **В зависимости от данных (z)**. Преобразования из типа Java **String** в базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] зависят от следующих условий. Драйвер отправляет значение **String** на [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)], а [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] при необходимости выполняет преобразование. Если свойство подключения sendStringParametersAsUnicode имеет значение true, а базовым типом данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] является **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] не выполнит преобразование **nvarchar** в **image** и вызовет исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый тип данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] — **image**, то [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразование **varchar** в **image**, а исключение не вызывается.

[!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет ряд заданных преобразований и передает ошибки обратно драйверу JDBC, если возникают проблемы. Преобразование на стороне клиента является исключением и выполняется только в случае использования **даты**, **время**, **timestamp**, **логическое**и  **Строка** значения.

Если столбец [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **XML**, то значение данных должно быть допустимым **XML**. При вызове методов setObject(byte[], SQLXML), setObject(inputStream, SQLXML) или setObject(Blob, SQLXML) значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Пример:

```xml
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E
```

Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.

## <a name="see-also"></a>См. также:

[Основные сведения о типах данных драйвера JDBC](../../connect/jdbc/understanding-the-jdbc-driver-data-types.md)
