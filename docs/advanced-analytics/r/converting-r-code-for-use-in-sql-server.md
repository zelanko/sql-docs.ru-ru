---
title: Преобразование кода R для SQL
description: Перенос кода R в хранимую процедуру SQL Server для развертывания решения и доступа к реляционным данным в SQL Server.
ms.prod: sql
ms.technology: machine-learning
ms.date: 04/15/2018
ms.topic: conceptual
author: dphansen
ms.author: davidph
ms.custom: seo-lt-2019
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: 882ce47467a38ab4a891f632c9598070e13494e3
ms.sourcegitcommit: 09ccd103bcad7312ef7c2471d50efd85615b59e8
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73727535"
---
# <a name="convert-r-code-for-execution-in-sql-server-in-database-instances"></a>Преобразование кода R для выполнения в экземплярах SQL Server (в базе данных)
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

В этой статье приводятся общие рекомендации по изменению кода R для работы в SQL Server. 

При переносе кода R из R Studio или другой среды в SQL Server дополнительные изменения как правило не требуется. Например, это верно для простого кода, такого как функция, которая принимает и возвращает некоторые значения. Кроме того, удобно переносить пакеты **RevoScaleR** или **MicrosoftML**, которые поддерживают разные контексты выполнения с минимальными изменениями.

Тем не менее, в следующих случаях может потребоваться значительная переработка кода:

+ Вы используете библиотеки R, которые осуществляют доступ к сети или не могут быть установлены в SQL Server.
+ В коде выполняются отдельные вызовы источников данных, расположенных вне среды SQL Server, таких как листы Excel, файлы в общих папках или другие базы данных. 
+ Вам требуется выполнить код в параметре *\@script* процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md) и также параметризовать хранимую процедуру.
+ Исходное решение включает несколько шагов, которые в рабочей среде эффективнее выполнять по отдельности. В качестве примера можно сравнить подготовку данных или формирование признаков с обучением модели, оценкой и созданием отчетов.
+ Вы хотите оптимизировать производительность, изменяя библиотеки, используя параллельное выполнение или передачу нагрузки некоторых процессов в SQL Server. 

## <a name="step-1-plan-requirements-and-resources"></a>Шаг 1. Планирование ресурсов и требований

**Пакеты**

+ Определите необходимые пакеты и убедитесь, что они работают в SQL Server.
 
+ Заранее установите пакеты в заданную по умолчанию библиотеку пакетов, которую используют службы машинного обучения. Пользовательские библиотеки не поддерживаются.

**Источники данных** 

+ Если вы планируете внедрить код R в процедуру [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), определите первичный и вторичный источники данных. 

    + В качестве **первичных** источников выступают большие наборы данных, например обучающие данные модели или входные данные для прогнозирования. Спланируйте сопоставление самого большого набора данных с входным параметром процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md).

    + В качестве **вторичных** источников обычно используются наборы меньшего размера, например списки факторов или дополнительные переменные группирования. 
    
    На данный момент процедура sp_execute_external_script поддерживает только один набор данных в качестве входного параметра. При необходимости вы можете добавить несколько скалярных или двоичных входов.

    Вызовы хранимой процедуры, которым предшествует EXECUTE, нельзя использовать в качестве входных данных процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). При этом вы можете использовать запросы, представления и любые другие допустимые инструкции SELECT.

+ Определите нужные выходные данные. Если код R выполняется с помощью хранимой процедуры sp_execute_external_script, она может возвращать только один кадр данных. Тем не менее, вы можете определить несколько скалярных выходов, таких как графики и модели в двоичном формате, а также другие скалярные значения, получаемые на основе кода R или параметров SQL.

**Типы данных**

+ Составьте контрольный список возможных проблем с типами данных.

    Службы машинного обучения SQL Server поддерживают все типы данных R. Тем не менее, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживает гораздо большее число типов данных, чем R. Таким образом, при отправке данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в R и в обратном направлении выполняются определенные неявные преобразования типов данных. Кроме того, может потребоваться явным образом привести или преобразовать некоторые данные. 

    Значения NULL поддерживаются. Тем не менее, R использует структуру данных `na` для представления отсутствующих значений, подобных значениям NULL.

+ Рекомендуется убрать зависимости от данных, которые нельзя использовать в R. Например, типы данных rowid и GUID из SQL Server не поддерживаются в R и приводят к возникновению ошибок.

    Дополнительные сведения см. в разделе [Библиотеки R и типы данных](../r/r-libraries-and-data-types.md).

## <a name="step-2-convert-or-repackage-code"></a>Шаг 2. Преобразование или переупаковка кода

Объем необходимых изменений в коде зависит от того, планируете ли вы отправлять код R с удаленного клиента для выполнения в контексте вычислений SQL Server или хотите развернуть код в составе хранимой процедуры, что позволяет повысить производительность и безопасность. Упаковка кода в хранимую процедуру сопряжена с некоторыми дополнительными ограничениями. 

+ Чтобы избежать перемещения данных, по возможности определяйте в качестве первичных входных данных SQL-запрос.

+ При выполнении кода R в хранимой процедуры вы передаете несколько **скалярных** входов. Для всех параметров, которые требуется использовать в выходных данных, добавьте ключевое слово **OUTPUT**. 

    Например, следующий скалярный вход `@model_name` содержит имя модели, которое также включается в выходные данные в отдельном столбце:

    ```sql
    EXEC sp_execute_external_script @model_name="DefaultModel" OUTPUT, @language=N'R', @script=N'R code here'
    ``` 

+ Все переменные, передаваемые в качестве параметров хранимой процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), должны быть сопоставлены с переменными в коде R. По умолчанию переменные сопоставляются по имени.

    Все столбцы во входном наборе данных также должны быть сопоставлены с переменными в скрипте R.  Предположим, что скрипт R содержит следующую формулу:

    ```R
    formula <- ArrDelay ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    ```
    
    Если входной набор данных не содержит столбцы с именами ArrDelay, CRSDepTime, DayOfWeek, CRSDepHour и DayOfWeek, возникает ошибка.

+ В некоторых случаях необходимо заранее определить схему выходных данных для результатов.

    Например, чтобы вставить данные в таблицу, необходимо использовать инструкцию **WITH RESULT SET** для определения схемы.

    Схема выходных данных также обязательна, если скрипт R использует аргумент `@parallel=1`. Дело в том, что SQL Server может распределить запрос между несколькими параллельными процессами и собирать результаты в конце. Поэтому схему вывода необходимо подготовить до того, как могут быть созданы параллельные процессы.
    
    В других случаях схему результатов можно опустить, указав параметр **WITH RESULT SETS UNDEFINED**. Эта инструкция возвращает набор данных из скрипта R, не присваивая имена столбцам и не указывая типы данных SQL.

+ Рассмотрите возможность создания данных времени и отслеживания с использованием T-SQL вместо R.

    Например, для передачи системного времени или других сведений, используемых при аудите и хранении, можно добавить вызов T-SQL, который передается в результаты, вместо того чтобы создавать аналогичные данные в скрипте R. 

**Повышение производительности и безопасности**

+ Не рекомендуется записывать прогнозы или промежуточные результаты в файл. Чтобы избежать перемещения данных, вместо этого следует записывать прогнозы в таблицу.

+ Выполняйте все запросы заранее и используйте планы запросов SQL Server для определения задач, которые могут выполняться параллельно.

    Если входной запрос может выполняться параллельно, задайте параметр `@parallel=1` как часть аргументов процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). 

    Параллельная обработка с использованием этого параметра обычно поддерживается, если SQL Server может работать с секционированными таблицами или распределять запрос между несколькими процессами и выполнять статистическую обработку результатов в конце. Параллельная обработка с использованием этого параметра обычно не поддерживается, если для обучения моделей применяются алгоритмы, требующие считывания всех данных, или если требуется создать агрегаты.

+ Определите, нет ли в коде R действий, которые можно выполнять отдельно или более эффективно с помощью вызова отдельной хранимой процедуры. Например, вы можете повысить производительность, формируя или извлекая признаки отдельно и сохраняя значения в таблице.

+ Ищите способы для выполнения вычислений на основе наборов с использованием кода T-SQL, а не R.

    Например, это решение R демонстрирует, как пользовательские функции T-SQL и R могут выполнять одинаковую задачу по формированию признаков: [Пошаговое руководство по обработке и анализу данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md).

+ По возможности замените обычные функции R функциями **ScaleR**, поддерживающими распределенное выполнение. Дополнительные сведения см. в статье [Сравнение функций Base R и Scale R](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/revoscaler-compared-to-base-r).

+ Вместе с разработчиком базы данных определите способы повысить производительность с помощью таких возможностей SQL Server, как [оптимизированные для памяти таблицы](https://docs.microsoft.com/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables) или, если вы используете выпуск Enterprise, [Resource Governor](https://docs.microsoft.com/sql/relational-databases/resource-governor/resource-governor).

    Дополнительные сведения см. в статье [Советы и рекомендации по оптимизации SQL Server для служб Analytics Services](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services)

### <a name="step-3-prepare-for-deployment"></a>Шаг 3. Подготовка к развертыванию

+ Обратитесь к администратору, чтобы установить и протестировать пакеты до развертывания кода. 

    В среде разработки допустимо устанавливать пакеты как часть кода, но это не рекомендуется делать в рабочей среде. 

    Пользовательские библиотеки не поддерживаются, даже если вы используете хранимые процедуры или выполняете код R в контексте вычислений SQL Server.

**Упаковка кода R в хранимую процедуру**

+ Относительно простой код можно внедрить в пользовательскую функцию T-SQL без изменений, как описывается в следующих примерах:

    + [Создание функции R, которая выполняется в rxExec](../tutorials/deepdive-create-a-simple-simulation.md)
    + [Формирование признаков с помощью T-SQL и R](../tutorials/sqldev-create-data-features-using-t-sql.md)

+ Для преобразования более сложного кода используйте пакет R **sqlrutils**. С помощью этого пакета опытные пользователи R могут создавать эффективный код хранимых процедур. 

    Для начала необходимо переписать код R в виде отдельной функции с четко определенными входными и выходными данными.

    Далее с помощью пакета **sqlrutils** создайте входные и выходные данные в корректном формате. Пакет **sqlrutils** создает полный код хранимой процедуры и также может зарегистрировать ее в базе данных. 

    Дополнительные сведения и примеры см. в статье, посвященной пакету [sqlrutils (SQL)](ref-r-sqlrutils.md).

**Интеграция с другими рабочими процессами**

+ Используйте средства T-SQL и процессы извлечения, преобразования и загрузки. Выполняйте формирование и извлечение признаков, а также очистку данных, заранее в рамках процессов обработки данных.

    При работе в специализированной среде разработки R, такой как [!INCLUDE[rsql_rtvs_md](../../includes/rsql-rtvs-md.md)] или RStudio, вы можете выполнять извлечение данных на компьютер, их последовательный анализ и запись или отображение результатов. 
    
    Однако при переносе кода R в SQL Server большую часть этого процесса можно упростить или делегировать другим средствам SQL Server. 

+ Используйте безопасные стратегии асинхронной визуализации.

    Пользователи SQL Server часто не могут получить доступ к файлам на сервере, а клиентские средства SQL как правило не поддерживают графическое устройство R. Если в вашем решении создаются диаграммы и другие графические элементы, рекомендуется экспортировать их в виде двоичных данных и записывать или сохранять в таблицу.

+ Упакуйте функции прогнозирования и оценки в хранимые процедуры, что позволит приложениям напрямую обращаться к ним.

### <a name="other-resources"></a>Другие ресурсы

Примеры развертывания решения R в SQL Server можно найти в следующих статьях:

+ [Создание прогнозной модели для компании по прокату лыжного оборудования с использованием R и SQL Server](https://microsoft.github.io/sql-ml-tutorials/R/rentalprediction/)

+ [Аналитика в базе данных для разработчика SQL](../tutorials/sqldev-in-database-r-for-sql-developers.md) — в этой статье показано, как сделать структуру кода R модульной с помощью хранимых процедур

+ [Решение по обработке и анализу данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md) — в этой статье приведено сравнение формирования признаков в R и T-SQL
