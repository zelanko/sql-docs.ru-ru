---
title: Правила приведения типов в XQuery | Документы Microsoft
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: sql
ms.service: ''
ms.component: xquery
ms.reviewer: ''
ms.suite: sql
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: language-reference
applies_to:
- SQL Server
dev_langs:
- XML
helpviewer_keywords:
- XQuery, type casting
- casting rules [XML in SQL Server]
- explicit casting [SQL Server]
- type casting rules [XML in SQL Server]
- cast as operator
- implicit casting
ms.assetid: f2e91306-2b1b-4e1c-b6d8-a34fb9980057
caps.latest.revision: 35
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: c90c004bc5e8db211145850e14d61a74145beb0c
ms.sourcegitcommit: 2ddc0bfb3ce2f2b160e3638f1c2c237a898263f4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="type-casting-rules-in-xquery"></a>Правила приведения типов в запросах XQuery
[!INCLUDE[tsql-appliesto-ss2012-xxxx-xxxx-xxx-md](../includes/tsql-appliesto-ss2012-xxxx-xxxx-xxx-md.md)]

  В следующей диаграмме спецификаций функций и операторов языков W3C XQuery 1.0 и XPath 2.0 показаны встроенные типы данных. К ним относятся встроенные примитивные и встроенные производные типы.  
  
 ![Иерархия типов XQuery 1.0](../xquery/media/xquery-typing-rules.gif "иерархия типов XQuery 1.0")  
  
 В этом разделе описаны правила приведения типов, применяемые при приведении одного типа к другому с помощью одного из следующих методов.  
  
-   Явное приведение можно сделать с помощью **приведенное** или функций-конструкторов типов (например, `xs:integer("5")`).  
  
-   Неявное приведение, выполняемое в процессе повышения типов.  
  
## <a name="explicit-casting"></a>Явное приведение  
 В следующей таблице показано разрешенное приведение встроенных примитивных типов друг к другу.  
  
 ![Описывает правила приведения типов языка XQuery. ] (../xquery/media/casting-builtin-types.gif "Описывает правила приведения типов языка XQuery.")  
  
-   Встроенный примитивный тип может быть приведен к другому встроенному примитивному типу на основе правил, указанных в таблице.  
  
-   Примитивный тип может быть приведен к любому производному от него типу. Например, можно приводить из **xs: decimal** для **xs: Integer**, или из **xs: decimal** для **xs: Long**.  
  
-   Производный тип может быть приведен к любому типу, являющемуся его предком в иерархии типов, вплоть до его встроенного примитивного базового типа. Например, можно приводить из **xs: Token** для **xs: normalizedstring** или **xs: String**.  
  
-   Производный тип может быть приведен к примитивному типу в случае, если его примитивный тип-предок может быть приведен к целевому типу. Например, можно привести **xs: Integer**, производный тип **xs: String**примитивный тип, так как **xs: decimal**, **xs: Integer**элемента примитивный тип-предок, может быть приведен к **xs: String**.  
  
-   Производный тип может быть приведен к другому производному типу, если примитивный тип-предок исходного типа может быть приведен к примитивному типу-предку целевого типа. Например, можно приводить из **xs: Integer** для **xs: Token**, так как можно приводить из **xs: decimal** для **xs: String**.  
  
-   Правила приведения определяемых пользователем типов к встроенным являются теми же, что и для встроенных типов. Например, можно определить **myInteger** тип, производный от **xs: Integer** типа. Затем **myInteger** может быть приведен к **xs: Token**, так как **xs: decimal** может быть приведен к **xs: String**.  
  
 Следующие способы приведения типов не поддерживаются.  
  
-   Приведение к списковым типам или списковых типов к другим недопустимо. Это включает список определяемых пользователем типов и список встроенных типов например **xs: IDREF**, **xs: Entities**, и **xs: NMTOKENS**.  
  
-   Приведение в **xs: QName** не поддерживается.  
  
-   **xs: NOTATION** и полностью упорядоченные подтипы длительность, **xdt: yearmonthduration** и **xdt: daytimeduration**, не поддерживаются. В результате приведение к этим типам или этих типов к другим не поддерживается.  
  
 В следующих примерах показано явное приведение типов.  
  
### <a name="example-a"></a>Пример A  
 В следующем примере запрашивается переменная XML-типа. Запрос возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml  
set @x = '<e>1</e><e>2</e>'  
select @x.query('/e[1] cast as xs:string?')  
go  
```  
  
### <a name="example-b"></a>Пример Б  
 В следующем примере запрашивается типизированная переменная типа XML. Сначала создается коллекция XML-схем. Затем эта коллекция используется для создания типизированной переменной типа XML. В схеме содержатся сведения о типизации для экземпляра XML, назначенного переменной. После этого запросы направляются к данной переменной.  
  
```  
create xml schema collection myCollection as N'  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">  
      <xs:element name="root">  
            <xs:complexType>  
                  <xs:sequence>  
                        <xs:element name="A" type="xs:string"/>  
                        <xs:element name="B" type="xs:string"/>  
                        <xs:element name="C" type="xs:string"/>  
                  </xs:sequence>  
            </xs:complexType>  
      </xs:element>  
</xs:schema>'  
go  
```  
  
 Следующий запрос возвращает статическую ошибку, так как неизвестно, сколько элементов верхнего уровня <`root`> присутствует в экземпляре документа.  
  
```  
declare @x xml(myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
          <root><A>4</A><B>5</B><C>6</baz></C>'  
select @x.query('/root/A cast as xs:string?')  
go  
```  
  
 При указании в выражении одиночного элемента <`root`> запрос завершается успешно. Запрос возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml(myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
              <root><A>4</A><B>5</B><C>6</C></root>'  
select @x.query('/root[1]/A cast as xs:string?')  
go  
```  
  
 В следующем примере переменная XML-типа содержит ключевое слово document, указывающее на коллекцию XML-схем. Это слово указывает, что экземпляр XML должен представлять собой документ с одиночным элементом верхнего уровня. Если в экземпляре XML будет создано два элемента <`root`>, будет возвращена ошибка.  
  
```  
declare @x xml(document myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>  
              <root><A>4</A><B>5</B><C>6</C></root>'  
go  
```  
  
 Можно изменить экземпляр таким образом, чтобы он содержал только один элемент верхнего уровня, и запрос будет работать. Запрос вновь возвращает последовательность значения простого типа, типизированного как xs:string.  
  
```  
declare @x xml(document myCollection)  
set @x = '<root><A>1</A><B>2</B><C>3</C></root>'  
select @x.query('/root/A cast as xs:string?')  
go  
```  
  
## <a name="implicit-casting"></a>Неявное приведение  
 Неявное приведение разрешено только для числовых типов и нетипизированных атомарных типов. Например, следующая **min()** функция возвращает минимальное из двух значений:  
  
```  
min(xs:integer("1"), xs:double("1.1"))  
```  
  
 В этом примере два значения, передаваемый в XQuery **min()** функция принадлежат разным типам. Таким образом, выполняется неявное преобразование где **целое** тип повышается до **двойные** и два **двойные** сравниваются значения.  
  
 Повышение типов, описанное в данном примере, выполняется по следующим правилам.  
  
-   Встроенный производный числовой тип можно повышать до его базового типа. Например **целое** можно повысить до **десятичное**.  
  
-   Объект **десятичное** можно повысить до **float,** и **float** можно повысить до **двойные**.  
  
 Так как неявное приведение допустимо только для числовых типов, следующие операции недопустимы.  
  
-   Неявное приведение строковых типов недопустимо. Например, если два **строка** ожидаемых значений типа и передать **строка** и **маркера**, неявное приведение выполняться и возвращается сообщение об ошибке.  
  
-   Неявное приведение числовых типов к строковым недопустимо. Например, в случае передачи значения целого типа функции, принимающей параметр строкового типа, неявное приведение выполняться не будет, и будет возвращена ошибка.  
  
## <a name="casting-values"></a>Приведение значений  
 При приведении одного типа к другому фактические значения трансформируются из пространства значений исходного типа в пространство значений целевого типа. Например, при приведении значения типа xs:decimal к типу xs:double значение decimal будет преобразовано в значение double.  
  
 Ниже приведены некоторые правила преобразования.  
  
##### <a name="casting-a-value-from-a-string-or-untypedatomic-type"></a>Приведение значения типа string или untypedAtomic к другому типу  
 Значение, которое приводится к типу string или untypedAtomic, преобразуется таким же образом, что и при проверке значения на основе правил целевого типа. Сюда входят правила сопоставления с ожидаемым шаблоном и обработки пробелов. Например, следующая операция завершится успехом, а результатом ее будет значение типа double 1.1e0:  
  
 `xs:double("1.1")`  
  
 При приведении типов string или untypedAtomic к двоичным типам, например xs:base64Binary или xs:hexBinary, входные значения должны быть закодированы по алгоритму base64 или hex соответственно.  
  
##### <a name="casting-a-value-to-a-string-or-untypedatomic-type"></a>Приведение значения к типу string или untypedAtomic  
 При приведении значения к типу string или untypedAtomic оно будет преобразовано в свое каноническое лексическое представление в языке XQuery. Конкретно это означает, что значение, которое при вводе укладывалось в заданный шаблон или другое ограничение, не будет представлено в соответствии с данным ограничением.  Для информирования пользователей об этом [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] флаги типов, когда ограничение типа может вызвать проблемы, предоставляя предупреждение при загрузке таких типов в коллекцию схем.  
  
 При приведении значения типа xs:float к типу xs:double или какому-либо из его подтипов, к типу string или untypedAtomic, значение будет представлено в экспоненциальной записи. Это производится только в случае, если абсолютное значение данного значения меньше 1.0E-6 или же больше или равно 1.0E6. Таким образом, 0 сериализуется в экспоненциальном представлении в форме 0.0E0.  
  
 Например, операция `xs:string(1.11e1)` возвращает строковое значение `"11.1"`, в то время как операция `xs:string(-0.00000000002e0)` возвращает строковое значение `"-2.0E-11"`.  
  
 При приведении двоичных типов, например xs:base64Binary или xs:hexBinary, к типу string или untypedAtomic, двоичные значения будут представлены в закодированной форме по алгоритму base64 или hex соответственно.  
  
##### <a name="casting-a-value-to-a-numeric-type"></a>Приведение значения к числовому типу  
 При приведении значения одного числового типа к значению другого числового типа оно отображается из одного пространства значений в другое без строковой сериализации. Если значение не удовлетворяет ограничениям целевого типа, применяются следующие правила.  
  
-   Если исходное значение уже является числовым, а целевой тип — xs:float либо его подтип, для которого допустимы значения -INF и INF, и приведение исходного числового значения к целевому типу вызовет переполнение, значение сопоставляется с INF, если оно положительное, и с -INF — если отрицательное. Если для целевого типа недопустимы значения INF и -INF и может произойти переполнение, приведение завершается неудачей и SQL Server выдает в качестве результата пустую последовательность.  
  
-   Если исходное значение уже является числовым, а целевой тип — числовой и его диапазон приемлемых значений включает 0, -0e0 или 0e0 и приведение исходного числового значения к целевому типу вызовет потерю точности, сопоставление значения выполняется следующим образом.  
  
    -   Для десятичного целевого типа значению сопоставляется 0.  
  
    -   В случае потери точности отрицательного значения ему сопоставляется -0e0.  
  
    -   В случае потери точности положительного значения для целевого типа с плавающей точкой или с двойной точностью ему сопоставляется 0e0.  
  
     Если в пространство значений целевого типа не входит ноль, приведение завершается неудачей, а результатом является пустая последовательность.  
  
     Обратите внимание, что при приведении значения к двоичному типу с плавающей запятой, например xs:float, xs:double или любому из их подтипов, точность может снизиться.  
  
## <a name="implementation-limitations"></a>Ограничения реализации  
 Существуют следующие ограничения:  
  
-   Значение NaN (нечисловое) с плавающей запятой не поддерживается.  
  
-   На значения, доступные для приведения, накладываются ограничения реализации целевых типов. Например, нельзя привести строку даты с отрицательным годом для **xs: Date**. Если значение предоставляется во время выполнения, результатом такого приведения будет пустая последовательность (а не ошибка времени выполнения).   
  
## <a name="see-also"></a>См. также  
 [Определение сериализации данных XML](../relational-databases/xml/define-the-serialization-of-xml-data.md)  
  
  
