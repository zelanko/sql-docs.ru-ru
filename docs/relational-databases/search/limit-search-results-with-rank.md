---
title: Ограничение количества результатов поиска с помощью RANK | Документация Майкрософт
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: search, sql-database
ms.technology: search
ms.topic: conceptual
helpviewer_keywords:
- row ranking [full-text search]
- relevance ranking values [full-text search]
- full-text search [SQL Server], rankings
- index rankings [full-text search]
- ranked results [full-text search]
- rankings [full-text search]
- per-row rank values [full-text search]
ms.assetid: 06a776e6-296c-4ec7-9fa5-0794709ccb17
author: pmasl
ms.author: pelopes
ms.reviewer: mikeray
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 7740c95e40b4902e88d1ae5f632b34c7f759f441
ms.sourcegitcommit: b2e81cb349eecacee91cd3766410ffb3677ad7e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2020
ms.locfileid: "68132276"
---
# <a name="limit-search-results-with-rank"></a>Ограничение количества результатов поиска с использованием функции RANK
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  Функции [CONTAINSTABLE](../../relational-databases/system-functions/containstable-transact-sql.md) и [FREETEXTTABLE](../../relational-databases/system-functions/freetexttable-transact-sql.md) возвращают столбец с именем RANK, содержащий порядковые номера от 0 до 1000 (ранжирующие значения). Эти значения используются для ранжирования возвращенных строк согласно их соответствию критерию выбора. Ранжирующие значения указывают только относительный порядок релевантности строк в результирующем наборе, при этом чем меньше значение, тем меньше релевантность. Фактические значения несущественны и, как правило, различны для каждого выполнения запроса.  
  
> [!NOTE]  
>  Запросы, использующие предикаты CONTAINS и FREETEXT, не возвращают ранжирующие значения.  
  
 Число элементов, совпадающих с условиями поиска, часто бывает очень велико. Чтобы запросы CONTAINSTABLE или FREETEXTTABLE не возвращали слишком много соответствий, следует использовать необязательный параметр *top_n_by_rank* , в результате чего будет возвращаться только подмножество строк. *top_n_by_rank* — это целочисленное значение *n*, указывающее, что следует возвратить только *n* совпадений с самым высоким рангом в нисходящем порядке. Если параметр *top_n_by_rank* скомбинирован с другими параметрами, то запрос может вернуть меньше строк, чем фактически соответствует всем предикатам.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] упорядочивает соответствия по рангу и возвращает заданное число строк. Это может привести к значительному повышению производительности. Например, запрос, обычно возвращающий 100 000 строк из таблицы с миллионом строк, обрабатывается гораздо быстрее, если запросить всего 100 строк с наивысшими ранжирующими значениями.  
  
##  <a name="examples"></a> Примеры использования параметра RANK для ограничения результатов поиска  
  
### <a name="example-a-searching-for-only-the-top-three-matches"></a>Пример А. Поиск только трех соответствий с максимальным рангом  
 В следующем примере инструкция CONTAINSTABLE используется для возвращения только трех строк с максимальным рангом.  
  
```  
USE AdventureWorks2012  
GO  
  
SELECT K.RANK, AddressLine1, City  
FROM Person.Address AS A  
  INNER JOIN  
  CONTAINSTABLE(Person.Address, AddressLine1, 'ISABOUT ("des*",  
    Rue WEIGHT(0.5),  
    Bouchers WEIGHT(0.9))',  
    3) AS K  
  ON A.AddressID = K.[KEY]  
GO  
```  
  
 [!INCLUDE[ssResult](../../includes/ssresult-md.md)]  
  
```  
RANK        Address                          City  
----------- -------------------------------- ------------------------------  
172         9005, rue des Bouchers           Paris  
172         5, rue des Bouchers              Orleans  
172         5, rue des Bouchers              Metz  
  
(3 row(s) affected)  
```  
  
  
### <a name="example-b-searching-for-the-top-ten-matches"></a>Пример Б. Поиск десяти соответствий с максимальным рангом  
 В следующем примере с помощью CONTAINSTABLE возвращается описание первых 5 товаров, где столбец `Description` содержит слово «aluminum» рядом со словом «light» или «lightweight».  
  
```  
USE AdventureWorks2012  
GO  
  
SELECT FT_TBL.ProductDescriptionID,  
   FT_TBL.Description,   
   KEY_TBL.RANK  
FROM Production.ProductDescription AS FT_TBL INNER JOIN  
   CONTAINSTABLE (Production.ProductDescription,  
      Description,   
      '(light NEAR aluminum) OR  
      (lightweight NEAR aluminum)',  
      5  
   ) AS KEY_TBL  
   ON FT_TBL.ProductDescriptionID = KEY_TBL.[KEY]  
GO  
```  
  
  
##  <a name="how"></a> Как ранжируются результаты поискового запроса  
 Полнотекстовый поиск в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может формировать дополнительную оценку (или значение ранга), которая обозначает релевантность данных, возвращенных полнотекстовым запросом. Это ранжирующее значение вычисляется для каждой строки и может использоваться как критерий упорядочения для сортировки результирующего набора данного запроса по релевантности. Ранжирующие значения показывают только относительный порядок релевантности строк в результирующем наборе. Фактические значения несущественны и, как правило, различны для каждого выполнения запроса. Сохранение ранжирующего значения между запросами не играет роли.  
  
### <a name="statistics-for-ranking"></a>Статистические данные для ранжирования  
 При построении индекса собираются статистические данные, которые будут использоваться в ранжировании. Процесс построения полнотекстового каталога не приводит напрямую к созданию одной индексной структуры. Средство полнотекстового поиска для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] при индексировании данных создает промежуточные индексы. Затем средство полнотекстового поиска выполняет слияние этих индексов в больший индекс по мере необходимости. Этот процесс может повторяться много раз. После этого средство полнотекстового поиска выполняет слияние в единый файл, объединяющее все промежуточные индексы в один большой главный индекс.  
  
 Статистические данные собираются на каждом уровне промежуточных индексов. Слияние этих данных производится при слиянии индексов. Некоторые статистические значения могут формироваться только в процессе создания главного индекса.  
  
 При ранжировании результирующего набора запроса [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует статистические данные из самого большого промежуточного индекса. Это зависит от того, было ли выполнено слияние промежуточных индексов. Если слияние промежуточных индексов не выполнялось, точность статистических данных ранжирования может быть различной. По этой причине один и тот же запрос в разное время может возвращать различные результаты ранжирования по мере добавления, изменения и удаления данных, а также по мере слияния небольших индексов.  
  
 Чтобы свести к минимуму размер индекса и сложность вычислений, статистические данные часто округляются.  
  
 В следующем списке приводятся часто используемые термины и статистические значения, важные при вычислении ранга.  
  
 Свойство  
 Полнотекстовый индексированный столбец строки.  
  
 Документ  
 Сущность, возвращаемая в запросах. В [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ей соответствует строка. Документ может иметь несколько свойств точно так же, как и строка может иметь несколько полнотекстовых индексированных столбцов.  
  
 Индекс  
 Один инвертированный индекс одного или нескольких документов. Может полностью находиться в памяти или храниться на диске. Многие статистические данные относятся к конкретному индексу, в котором было обнаружено соответствие.  
  
 Полнотекстовый каталог  
 Коллекция промежуточных индексов, которые для запросов считаются одной сущностью. Каталоги являются организационными единицами, видимыми администратору [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .  
  
 Слово, токен или элемент  
 Единица проверки соответствия в средстве полнотекстового поиска. Потоки текста из документов формируются в слова или в токены согласно правилам конкретного языка.  
  
 Наличие  
 Смещение слова в свойстве документа, определенное средством разбиения по словам. Первое слово имеет вхождение в позиции 1, следующее — в позиции 2 и т.д. Чтобы избежать ложных положительных результатов в запросах по сходству и запросах фраз, в конце предложения и абзаца используется увеличенный промежуток между вхождениями.  
  
 TermFrequency  
 Количество вхождений значения ключа в строку.  
  
 IndexedRowCount  
 Общее число индексированных строк. Вычисляется на основе счетчиков в промежуточных индексах. Точность этого числа может быть различной.  
  
 KeyRowCount  
 Общее число строк в полнотекстовом каталоге, содержащем конкретный ключ.  
  
 MaxOccurrence  
 Наибольшее число вхождений для конкретного свойства в строке, хранящееся в полнотекстовом каталоге.  
  
 MaxQueryRank  
 Максимальный ранг (1000), возвращенный средством полнотекстового поиска.  
  
  
### <a name="rank-computation-issues"></a>Проблемы при вычислении ранга  
 Процесс вычисления ранга зависит от нескольких факторов.  Средства разбиения по словам в различных языках по-разному разбивают текст на лексемы. Например, строку «dog-house» одно средство разбиения по словам может разбить на «dog» и «house», а другое — на «dog-house». Это означает, что соответствие и ранжирование будут зависеть от заданного языка, потому что в разных языках различаются не только слова, но и длина документа. Разница в длине документа может повлиять на ранжирование во всех запросах.  
  
 Такие статистические данные, как **IndexRowCount** , могут различаться в широких пределах. Например, если каталог имеет 2 миллиарда строк в главном индексе, то новый документ индексируется хранящимся в памяти индексом. Поэтому ранги для этого документа, вычисленные на основе количества документов в индексе, хранящемся в памяти, могут отличаться от рангов для документов из главного индекса. По этой причине рекомендуется после любого заполнения, приводящего к большому числу индексированных или переиндексированных строк, выполнять объединение индексов в главный индекс с помощью DDL-инструкции ALTER FULLTEXT CATALOG... Инструкция REORGANIZE языка [!INCLUDE[tsql](../../includes/tsql-md.md)] . Средство полнотекстового поиска также автоматически объединит индексы на основе таких параметров, как количество промежуточных индексов и их размер.  
  
 Значения**MaxOccurrence** нормализуются в один из 32 диапазонов. Это означает, например, что документ из 50 слов обрабатывается так же, как и документ из 100 слов. Ниже приведена используемая для нормализации таблица. Поскольку размеры документов лежат в диапазоне между соседними значениями таблицы, равными 32 и 128, они фактически обрабатываются как документ одной длины: 128 (32 < **docLength** <= 128).  
  
```  
{ 16, 32, 128, 256, 512, 725, 1024, 1450, 2048, 2896, 4096, 5792, 8192, 11585,   
16384, 23170, 28000, 32768, 39554, 46340, 55938, 65536, 92681, 131072, 185363,   
262144, 370727, 524288, 741455, 1048576, 2097152, 4194304 };  
  
```  
  
  
### <a name="ranking-of-containstable"></a>Ранжирование CONTAINSTABLE  
 Ранжирование[CONTAINSTABLE](../../relational-databases/system-functions/containstable-transact-sql.md) использует следующий алгоритм:  
  
```  
StatisticalWeight = Log2( ( 2 + IndexedRowCount ) / KeyRowCount )  
Rank = min( MaxQueryRank, HitCount * 16 * StatisticalWeight / MaxOccurrence )  
```  
  
 Фразовые соответствия ранжируются как отдельные ключи, за исключением того, что значение **KeyRowCount** (количество строк, содержащих эту фразу) является приближением — оно может быть неточным и выше фактического значения.  
  
 **Ранжирование NEAR**  
  
 Инструкция CONTAINSTABLE поддерживает выполнение запросов для двух и более выражений поиска с помощью параметра NEAR. Ранжирующее значение для каждой из возвращаемых строк зависит от нескольких параметров. Одним из основных факторов ранжирования является общее количество совпадений (или *попаданий*) по отношению к длине документа. Таким образом, например, если у документа из 100 слов и документа из 900 слов будет идентичный набор совпадений, то документ из 100 слов получит более высокий ранг.  
  
 Суммарная длина каждого из попаданий в строке также учитывается в ранжировании этой строки (в зависимости от расстояния между первым и последним выражениями поиска для данного попадания). Чем меньше расстояние, тем больше попадание увеличивает ранжирующее значение строки. Если в полнотекстовом запросе не указывается целочисленное максимальное расстояние, то документ, содержащий лишь попадания с расстояниями, превышающими 100 логических выражений, получит ранг 0.  
  
 **Ранжирование ISABOUT**  
  
 CONTAINSTABLE поддерживает выполнение запросов для взвешенных выражений за счет использования параметра ISABOUT. ISABOUT — это запрос в векторном пространстве, если пользоваться традиционной терминологией извлечения данных. В качестве алгоритма ранжирования по умолчанию используется широко известная формула Жаккарда. Ранжирование вычисляется для каждого термина в запросе, а затем результаты объединяются, как показано ниже.  
  
```  
ContainsRank = same formula used for CONTAINSTABLE ranking of a single term (above).  
Weight = the weight specified in the query for each term. Default weight is 1.  
WeightedSum = Σ[key=1 to n] ContainsRankKey * WeightKey  
Rank =  ( MaxQueryRank * WeightedSum ) / ( ( Σ[key=1 to n] ContainsRankKey^2 )   
      + ( Σ[key=1 to n] WeightKey^2 ) - ( WeightedSum ) )  
  
```  
  
  
### <a name="ranking-of-freetexttable"></a>Ранжирование FREETEXTTABLE  
 Ранжирование[FREETEXTTABLE](../../relational-databases/system-functions/freetexttable-transact-sql.md) основано на формуле ранжирования OKAPI BM25. Запросы FREETEXTTABLE добавляют к запросу словоформы, полученные по исходным словам запроса. Эти слова обрабатываются как отдельные и независимые, не относящиеся к словам, производными которых они являются. Синонимы, сформированные с помощью тезауруса, обрабатываются как отдельные, независимые и взвешенные выражения. Каждое слово в запросе вносит свой вклад в ранжирование.  
  
```  
Rank = Σ[Terms in Query] w ( ( ( k1 + 1 ) tf ) / ( K + tf ) ) * ( ( k3 + 1 ) qtf / ( k3 + qtf ) ) )  
Where:   
w is the Robertson-Sparck Jones weight.   
In simplified form, w is defined as:   
w = log10 ( ( ( r + 0.5 ) * ( N - R + r + 0.5 ) ) / ( ( R - r + 0.5 ) * ( n - r + 0.5 ) )  
N is the number of indexed rows for the property being queried.   
n is the number of rows containing the word.   
K is ( k1 * ( ( 1 - b ) + ( b * dl / avdl ) ) ).   
dl is the property length, in word occurrences.   
avdl is the average length of the property being queried, in word occurrences.   
k1, b, and k3 are the constants 1.2, 0.75, and 8.0, respectively.   
tf is the frequency of the word in the queried property in a specific row.   
qtf is the frequency of the term in the query.   
```  
  
  
## <a name="see-also"></a>См. также:  
 [Запросы с полнотекстовым поиском](../../relational-databases/search/query-with-full-text-search.md)  
  
  
