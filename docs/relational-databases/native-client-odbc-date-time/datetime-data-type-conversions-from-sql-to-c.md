---
title: Преобразования из SQL в C | Документация Майкрософт
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- conversions [ODBC], SQL to C
ms.assetid: 059431e2-a65c-4587-ba4a-9929a1611e96
author: MightyPen
ms.author: genemi
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: 9795126f2cd7c39ebd23ed34fde73664388b235f
ms.sourcegitcommit: 856e42f7d5125d094fa84390bc43048808276b57
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73783848"
---
# <a name="datetime-data-type-conversions-from-sql-to-c"></a>Преобразования типа данных datetime из SQL в C
[!INCLUDE[appliesto-ss-asdb-asdw-pdw-md](../../includes/appliesto-ss-asdb-asdw-pdw-md.md)]

  В следующей таблице приводится список вопросов, которые следует учитывать при преобразовании типов даты-времени [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в типы языка C.  
  
## <a name="conversions"></a>Преобразования  
  
||||||||||  
|-|-|-|-|-|-|-|-|-|  
||SQL_C_DATE|SQL_C_TIME|SQL_C_TIMESTAMP|SQL_C_SS_TIME2|SQL_C_SS_TIMESTAMPOFFSET|SQL_C_BINARY|SQL_C_CHAR|SQL_C_WCHAR|  
|SQL_CHAR|2, 3, 4, 5|2, 3, 6, 7, 8|2, 3, 9, 10, 11|2, 3, 6, 7|2, 3, 9, 10, 11|1|1|1|  
|SQL_WCHAR|2, 3, 4, 5|2, 3, 6, 7, 8|2, 3, 9, 10, 11|2, 3, 6, 7|2, 3, 9, 10, 11|1|1|1|  
|SQL_TYPE_DATE|OK|12|13|12|13, 23|14|16|16|  
|SQL_SS_TIME2|12|8|15|OK|10, 23|17|16|16|  
|SQL_TYPE_TIMESTAMP|18|7, 8|OK|7|23|19|16|16|  
|SQL_SS_TIMESTAMPOFFSET|18, 22|7, 8, 20|20|7, 20|OK|21|16|16|  
  
## <a name="key-to-symbols"></a>Расшифровка символов  
  
|Символ|Значение|  
|------------|-------------|  
|OK|Проблемы преобразования отсутствуют.|  
|1|Применяются правила, использовавшиеся до [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)].|  
|2|Начальные и конечные пробелы пропускаются.|  
|3|Выполняется синтаксический анализ строки, при котором из нее извлекается дата, время, часовой пояс или смещение часового пояса, при этом допускается точность задания долей секунды до 9 десятичных знаков. Если при анализе обнаруживается смещение часового пояса, то время преобразуется к часовому поясу клиента. Если во время этого преобразования возникает ошибка, создается диагностическая запись с кодом SQLSTATE 22018 и сообщением «Переполнение поля даты и времени».|  
|4|Если значение не является действительной датой, отметкой времени или значением timestampoffset, то формируется диагностическая запись с ошибкой SQLSTATE 22018 и сообщением «Недопустимое символьное значение для спецификации приведения».|  
|5|Если значение времени не равно нулю, то создается запись диагностики с кодом SQLSTATE 01S07 и сообщением «Частичное усечение».|  
|6|Если значение не является действительным значением времени, отметкой времени или значением timestampoffset, то формируется диагностическая запись с ошибкой SQLSTATE 22018 и сообщением «Недопустимое символьное значение для спецификации приведения».|  
|7|Компонент даты не учитывается.|  
|8|Если значение долей секунды не равно нулю, то создается диагностическая запись с кодом SQLSTATE 01S07 и сообщением «Частичное усечение».|  
|9|Если значение не является действительным значением даты, времени, отметкой времени или значением timestampoffset, то формируется диагностическая запись с ошибкой SQLSTATE 22018 и сообщением «Недопустимое символьное значение для спецификации приведения».|  
|10|Если значение является действительным значением времени, то компонент даты принимает значение текущей даты на стороне клиента.|  
|11|Если значение является действительным значением даты, то для времени устанавливается значение, равное нулю.|  
|12|Создается запись диагностики с кодом SQLSTATE 07006 и сообщением «Нарушение атрибута ограниченного типа данных».|  
|13|Время установлено в нуль.|  
|14|Если буфер недостаточно велик для значения SQL_DATE_STRUCT, то формируется диагностическая запись с ошибкой SQLSTATE 22003 и сообщением «Численное значение вне допустимого диапазона».|  
|15|Дата устанавливается равной текущей дате на стороне клиента.|  
|16|Если буфер недостаточно велик для преобразованного строкового значения, но не помещается только дробное значение секунд, то происходит усечение долей секунд и формируется диагностическая запись с ошибкой SQLSTATE 01004 и сообщением «Строковые данные, усечение справа». Если буфер недостаточно велик для помещения строкового значения без усечения компонентов даты, времени или смещения, то формируется диагностическая запись с ошибкой SQLSTATE 22003 и сообщением «Численное значение вне допустимого диапазона». Учтите, что для значений типа timestampoffset и значений даты невозможна ошибка SQLSTATE 01004, поскольку крайняя правая часть преобразованной строки не содержит долей секунды. Поэтому при любом усечении неизбежна потеря данных.|  
|17|Если буфер недостаточно велик для значения SQL_SS_TIME2_STRUCT, то формируется диагностическая запись с ошибкой SQLSTATE 22003 и сообщением «Численное значение вне допустимого диапазона».|  
|18|Если значение времени не равно нулю, то создается запись диагностики с кодом SQLSTATE 01S07 и сообщением «Частичное усечение».|  
|19|Если серверный тип — datetime или smalldatetime, то значение соответствует формату потока табличных данных и будет 4-байтовым значением для smalldatetime или 8-байтовым для datetime.<br /><br /> Если типом данных на стороне сервера является datetime2, то значение возвращается в виде SQL_TIMESTAMP_STRUCT. Если буфер недостаточно велик для возвращенного значения, то формируется диагностическая запись с ошибкой SQLSTATE 22003 и сообщением «Численное значение вне допустимого диапазона».|  
|20|Время приводится к часовому поясу клиента. Если во время этого преобразования возникла ошибка, создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Переполнение поля datetime».|  
|21|Если буфер недостаточно велик для значения SQL_SS_TIMESTAMPOFFSET_STRUCT, то значение возвращается в виде SQL_SS_TIMESTAMPOFFSET_STRUCT. В противном случае формируется диагностическая запись с ошибкой SQLSTATE 22003 и сообщением «Численное значение вне допустимого диапазона».|  
|22|Это значение приводится к часовому поясу клиента до извлечения даты. Тем самым обеспечивается согласованность с другими преобразованиями с типами timestampoffset. Если во время этого преобразования возникла ошибка, создается запись диагностики с кодом SQLSTATE 22008 и сообщением «Переполнение поля datetime». В результате может быть получена дата, отличающаяся от значения, получаемого простым усечением.|  
  
 Таблица в этом разделе описывает преобразования между типами, возвращаемыми клиенту, и типами в привязке. Для выходных параметров, если тип сервера, указанный в SQLBindParameter, не совпадает с фактическим типом на сервере, на сервере будет выполнено неявное преобразование, и тип, возвращаемый клиенту, будет соответствовать типу, указанному с помощью SQLBindParameter. Это может привести к непредвиденным результатам преобразования, если правила преобразования сервера отличаются от правил, перечисленных в предыдущей таблице. Например, если необходима дата по умолчанию, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] использует не текущую дату, а 01.01.1900.  
  
## <a name="see-also"></a>См. также раздел  
 [Улучшения &#40;даты и времени ODBC&#41;](../../relational-databases/native-client-odbc-date-time/date-and-time-improvements-odbc.md)  
  
  
