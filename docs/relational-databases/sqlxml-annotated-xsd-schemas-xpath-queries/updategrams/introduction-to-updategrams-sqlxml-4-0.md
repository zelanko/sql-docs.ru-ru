---
title: "Общие сведения о диаграммах обновления (SQLXML 4.0) | Документы Microsoft"
ms.custom: 
ms.date: 03/17/2017
ms.prod: sql-non-specified
ms.prod_service: database-engine, sql-database
ms.service: 
ms.component: sqlxml
ms.reviewer: 
ms.suite: sql
ms.technology:
- dbe-xml
ms.tgt_pltfrm: 
ms.topic: reference
helpviewer_keywords:
- explicit schema mapping [SQLXML]
- updategrams [SQLXML], mapping schema specifying
- namespaces [SQLXML]
- updategrams [SQLXML], about updategrams
- attribute-centric mapping
- invalid characters [SQLXML]
- element-centric mapping [SQLXML]
- mapping schema [SQLXML], updategrams
- namespaces [SQLXML], updategrams
- executing updategrams [SQLXML]
- implicit schema mapping
ms.assetid: cfe24e82-a645-4f93-ab16-39c21f90cce6
caps.latest.revision: 
author: douglaslMS
ms.author: douglasl
manager: craigg
ms.workload: Inactive
ms.openlocfilehash: 2dc3ce73bfe3da97e6567c1819eea34a8bc1dfaa
ms.sourcegitcommit: 37f0b59e648251be673389fa486b0a984ce22c81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/12/2018
---
# <a name="introduction-to-updategrams-sqlxml-40"></a>Общие сведения о диаграммах обновления (SQLXML 4.0)
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
Можно изменить (вставки, обновления или удаления) базы данных в [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] из существующего XML-документа с помощью диаграммы обновления или OPENXML [!INCLUDE[tsql](../../../includes/tsql-md.md)] функции.  
  
 Функция OPENXML изменяет базу данных, разделяя существующий XML-документ и формируя набор строк, который можно передавать инструкциям INSERT, UPDATE и DELETE. С помощью функции OPENXML операции выполняются непосредственно с таблицами базы данных. Поэтому использование функции OPENXML является наиболее оптимальным вариантом во всех случаях, когда поставщики наборов строк, например таблицы, могут быть источниками.  
  
 Диаграммы обновления, подобно функции OPENXML, позволяют вставлять, обновлять и удалять данные в базе данных. Однако диаграммы обновления работают не с таблицами, а с XML-представлениями, создаваемыми аннотированной XSD-схемой (или XDR-схемой); например, обновления применяются к XML-представлению, созданному сопоставляемой схемой. Схема сопоставления в свою очередь содержит данные, необходимые для сопоставления XML-элементов и атрибутов с соответствующими таблицами и столбцами базы данных. Диаграмма обновления использует эти данные сопоставления, чтобы выполнить обновление таблиц и столбцов базы данных.  
  
> [!NOTE]  
>  Настоящая документация предназначена для тех, кто знаком с шаблонами и поддержкой схем сопоставления в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]. Дополнительные сведения см. в разделе [введение в аннотированные схемы XSD &#40; SQLXML 4.0 &#41; ](../../../relational-databases/sqlxml/annotated-xsd-schemas/introduction-to-annotated-xsd-schemas-sqlxml-4-0.md). Для приложений прежних версий, которые используют XDR, в разделе [аннотированные схемы XDR &#40; устарел в SQLXML 4.0 &#41;](../../../relational-databases/sqlxml/annotated-xsd-schemas/annotated-xdr-schemas-deprecated-in-sqlxml-4-0.md).  
  
## <a name="required-namespaces-in-the-updategram"></a>Обязательные пространства имен в диаграмме обновления  
 Ключевые слова в диаграмме обновления, такие как  **\<синхронизации >**,  **\<перед >**, и  **\<после >**, существующие в **urn: schemas-microsoft-com: XML-диаграмма обновления** пространства имен. Префикс пространства имен может быть произвольным. В этой документации **updg** обозначает префикс **диаграмма обновления** пространства имен.  
  
## <a name="reviewing-syntax"></a>Обзор синтаксиса  
 Диаграмма обновления является шаблоном с  **\<синхронизации >**,  **\<перед >**, и  **\<после >** блоки, которые образуют синтаксис диаграммы обновления. Следующий код показывает этот синтаксис в его простейшей форме:  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
  <updg:sync [mapping-schema= "AnnotatedSchemaFile.xml"] >  
    <updg:before>  
        ...  
    </updg:before>  
    <updg:after>  
        ...  
    </updg:after>  
  </updg:sync>  
</ROOT>  
```  
  
 Следующие определения описывают роль каждого блока.  
  
 **\<before>**  
 Определяет текущее состояние (называемое также «исходным состоянием») экземпляра записи.  
  
 **\<after>**  
 Определяет новое состояние изменяемых данных.  
  
 **\<sync>**  
 Содержит  **\<перед >** и  **\<после >** блоков. Объект  **\<синхронизации >** блок может содержать более одного набора  **\<перед >** и  **\<после >** блоков. При наличии более чем один набор  **\<перед >** и  **\<после >** блоки, эти блоки (даже если они пустые) должен быть указан как пары. Кроме того, она может иметь более одного  **\<синхронизации >** блока. Каждый  **\<синхронизации >** блок является одной единицей транзакции (что означает, что в  **\<синхронизации >** блок выполняется или не выполняется вообще). Если задано несколько  **\<синхронизации >** блоков в диаграмме обновления, сбой одного  **\<синхронизации >** блок не влияет на остальные  **\<синхронизации >** блоков.  
  
 Ли диаграмма обновления удаляет вставляет или обновляет экземпляр записи зависит от содержимого  **\<перед >** и  **\<после >** блоки:  
  
-   Если экземпляр записи имеется только в  **\<перед >** блок без соответствующего экземпляра в  **\<после >** блок, диаграмма обновления выполняет операцию удаления.  
  
-   Если экземпляр записи имеется только в  **\<после >** блок без соответствующего экземпляра в  **\<перед >** блок, он выполняет операцию вставки.  
  
-   Если экземпляр записи появляется в  **\<перед >** блокировку и имеет соответствующий экземпляр в  **\<после >** блок, он является операцией обновления. В этом случае диаграмма обновления обновляет экземпляр записи значения, заданные в  **\<после >** блока.  
  
## <a name="specifying-a-mapping-schema-in-the-updategram"></a>Указание сопоставления схемы в диаграмме обновления  
 В диаграмме обновления XML-абстракция, созданная сопоставляемой схемой (поддерживаются схемы XSD и XDR), может быть явной или неявной (то есть диаграмма обновления может работать как с заданной схемой сопоставления, так и без нее). Если схема сопоставления не указан, то диаграмма обновления предполагает неявное сопоставление (сопоставление по умолчанию), где каждый элемент в  **\<перед >** блока или  **\<после >** сопоставляется таблице, а каждый его дочерний элемент или атрибут сопоставляется со столбцом в базе данных. Если схема сопоставления указана явно, то элементы и атрибуты в диаграмме обновления должны совпадать с элементами и атрибутами сопоставляемой схемы.  
  
### <a name="implicit-default-mapping"></a>Неявное сопоставление (по умолчанию)  
 В большинстве случаев диаграмма обновления, выполняющая простые обновления, не требует схемы сопоставления. В такой ситуации диаграмма обновления полагается на схему сопоставления, принятую по умолчанию.  
  
 В следующей диаграмме обновления показано неявное сопоставление. В этом примере диаграмма обновления применяется для вставки данных нового клиента в таблицу Sales.Customer. Поскольку эта диаграмма обновления используется неявное сопоставление \<Sales.Customer > элемент сопоставляется с таблицей Sales.Customer, а атрибуты CustomerID и SalesPersonID сопоставляются с соответствующими столбцами в таблице Sales.Customer.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
<updg:before>  
</updg:before>  
<updg:after>  
    <Sales.Customer CustomerID="1" SalesPersonID="277" />  
    </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="explicit-mapping"></a>Явное сопоставление  
 Если указывается схема сопоставления (XSD или XDR), диаграмма обновления использует эту схему для определения подлежащих обновлению таблиц и столбцов базы данных.  
  
 Если диаграмма обновления выполняет сложное обновление (например, вставку записей в несколько таблиц на основе связь родитель потомок, указанный в схеме сопоставления), необходимо явно задать схему сопоставления с помощью  **Схема сопоставления** атрибут, для которого выполняется диаграмма обновления.  
  
 Диаграмма обновления является шаблоном, поэтому заданный в ней путь для схемы сопоставления зависит от расположения файла шаблона (является относительным). Дополнительные сведения см. в разделе [указание схемы с заметками сопоставления в диаграмме обновления &#40; SQLXML 4.0 &#41; ](../../../relational-databases/sqlxml-annotated-xsd-schemas-xpath-queries/updategrams/specifying-an-annotated-mapping-schema-in-an-updategram-sqlxml-4-0.md).  
  
## <a name="element-centric-and-attribute-centric-mapping-in-updategrams"></a>Элементная и атрибутивная модель сопоставления в диаграммах обновления  
 При сопоставлении по умолчанию (когда сопоставляемая схема не указывается в диаграмме обновления), элементы диаграммы обновления сопоставляются с таблицами и дочерними элементами (в случае элементной модели сопоставления), а атрибуты сопоставляются со столбцами (в случае атрибутивной модели сопоставления).  
  
### <a name="element-centric-mapping"></a>Сопоставление, ориентированное на элементы  
 В диаграмме обновления, основанной на элементах, элемент содержит дочерние элементы, обозначающие свойства этого элемента. В качестве примера см. следующую диаграмму обновления.  **\<Person.Contact >** элемент содержит  **\<FirstName >**и  **\<LastName >** дочерних элементов. Эти дочерние элементы являются свойствами  **\<Person.Contact >** элемента.  
  
 Эта диаграмма обновления не указывает схему сопоставления, в ней используется неявное сопоставление, где  **\<Person.Contact >** элемент сопоставляется с таблицей Person.Contact и его дочерние элементы сопоставляются FirstName и Столбцы «Фамилия».  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:after>  
    <Person.Contact>  
       <FirstName>Catherine</FirstName>  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="attribute-centric-mapping"></a>атрибутивное сопоставление  
 В атрибутивной модели сопоставления элементы имеют атрибуты. В следующей диаграмме обновления используется атрибутивная модель сопоставления. В этом примере  **\<Person.Contact >** элемент состоит из **FirstName** и **LastName** атрибуты. Эти атрибуты являются свойствами  **\<Person.Contact >** элемента. Как в предыдущем примере, эта диаграмма обновления не указана схема сопоставления, поэтому он используется неявное сопоставление для сопоставления  **\<Person.Contact >** элемент таблице Person.Contact и атрибутам элементов в соответствующие столбцы в таблице.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" LastName="Abel" />  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
### <a name="using-both-element-centric-and-attribute-centric-mapping"></a>Одновременное использование элементной и атрибутивной моделей сопоставления  
 Можно использовать сочетание элементной и атрибутивной моделей сопоставления, как показано в следующей диаграмме обновления. Обратите внимание, что  **\<Person.Contact >** элемент содержит атрибут и дочерний элемент. Кроме того, в этой диаграмме обновления используется неявное сопоставление. Таким образом **FirstName** атрибута и  **\<LastName >** сопоставляются с соответствующими столбцами в таблице Person.Contact.  
  
```  
<ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram">  
<updg:sync >  
  <updg:before>  
  </updg:before>  
  <updg:after>  
    <Person.Contact FirstName="Catherine" >  
       <LastName>Abel</LastName>  
    </Person.Contact>  
  </updg:after>  
</updg:sync>  
</ROOT>  
```  
  
## <a name="working-with-characters-valid-in-sql-server-but-not-valid-in-xml"></a>Работа с символами, допустимыми в SQL Server, но не допустимыми в XML  
 В [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] имена таблиц могут содержать пробелы. Но в XML имена таблиц такого типа не допускаются.  
  
 Для кодирования недопустимых символов [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] идентификаторы, но это не идентификаторах XML, используйте "__xHHHH\_\_" как значение кодировки, где HHHH четырехзначный шестнадцатеричный код UCS-2 для символа в наиболее значительные первый разряд. С помощью этой схемы кодирования, символ пробела замещается x0020 (из четырех цифр шестнадцатеричный код пробела); Таким образом, имя таблицы [Order Details] в [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] становится _x005B_Order_x0020_Details_x005D\_ в формате XML.  
  
 Аналогичным образом, может потребоваться указать элемент трехчастные имена, такие как \<[база данных]. [ Владелец]. [таблица] >. Поскольку символы скобок ([и]) являются недопустимыми в формате XML, необходимо указать его в виде \<_x005B_database_x005D\_._x005B_owner_x005D\_._x005B_table_x005D\_>, где _x005B\_ — Кодировка для левую скобку ([) и _x005D\_ кодировка правая квадратная скобка (]).  
  
## <a name="executing-updategrams"></a>Выполнение диаграмм обновления  
 Диаграмма обновления является шаблоном, поэтому к ней применяются все механизмы обработки шаблона. В SQLXML 4.0 диаграмму обновления можно выполнить следующими способами:  
  
-   с помощью команды ADO;  
  
-   с помощью команды OLE DB.  
  
## <a name="see-also"></a>См. также  
 [Вопросы безопасности диаграмм обновления &#40; SQLXML 4.0 &#41;](../../../relational-databases/sqlxml-annotated-xsd-schemas-xpath-queries/security/updategram-security-considerations-sqlxml-4-0.md)  
  
  
