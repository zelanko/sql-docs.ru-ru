---
title: Рекомендации и ограничения XML-кода массовой загрузки (SQLXML 4.0) | Документация Майкрософт
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- XML Bulk Load [SQLXML], about XML Bulk Load
- bulk load [SQLXML], about bulk load
ms.assetid: c5885d14-c7c1-47b3-a389-455e99a7ece1
author: douglaslMS
ms.author: douglasl
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 1640ff8c4daab2260253d1104f1f8099d306120a
ms.sourcegitcommit: 2429fbcdb751211313bd655a4825ffb33354bda3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2018
ms.locfileid: "52512747"
---
# <a name="guidelines-and-limitations-of-xml-bulk-load-sqlxml-40"></a>Правила и ограничения массовой загрузки XML (SQLXML 4.0)
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  Использование массовой загрузки XML требует понимания следующих рекомендаций и ограничений.  
  
-   Встроенные схемы не поддерживаются.  
  
     Если в исходном XML-документе содержится встроенная схема, при массовой загрузке XML она не учитывается. Для массовой загрузки XML нужно задать схему сопоставления, внешнюю по отношению к XML-данным. Нельзя задать схему сопоставления в узел с помощью **xmlns = «x: schema»** атрибута.  
  
-   Проверяется правильность формата XML-документа, но сам документ не проверяется.  
  
     Массовая загрузка XML проверяет XML-документа, чтобы определить, является ли он что хорошо полных, чтобы убедиться, что XML соответствует требований к синтаксису, рекомендация консорциума W3c XML 1.0. Если формат документа содержит ошибки, массовая загрузка XML прекращается и возвращает ошибку. Единственное исключение — когда документ является фрагментом (например, когда у него не один корневой элемент), в этом случае массовая загрузка XML загружает документ.  
  
     Массовая загрузка XML не проверяет документ на соответствие какой-либо схеме DTD или XML-Data, которую содержит или на которую ссылается файл XML-данных. Кроме того, массовая загрузка XML-данных не проверяет файл XML-данных на соответствие переданной схеме сопоставления.  
  
-   Никакая информация из пролога XML-документа не учитывается.  
  
     Массовая загрузка XML пропускает всю информацию, до и после \<корневой > элемент XML-документа. В частности, массовая загрузка XML не учитывает никаких XML-деклараций, внутренних определений DTD, ссылок на внешние DTD, комментариев и тому подобное.  
  
-   При наличии схемы сопоставления, задающей связь «первичный ключ — внешний ключ» между двумя таблицами (например, между таблицами Customer и CustOrder), таблица, содержащая первичный ключ, должна описываться в схеме первой. Таблица с внешним ключевым столбцом должна располагаться после нее. Причиной этого является порядок, в котором таблицы идентифицируются в схеме заказа, который используется для их загрузки в базу данных. Например, следующая схема XDR вызовет ошибку, когда он используется в Массовая загрузка XML, так как  **\<порядок >** элемент описан раньше  **\<клиента >** элемент. Столбец CustomerID в таблице CustOrder представляет собой внешний ключевой столбец, ссылающийся на первичный ключевой столбец CustomerID в таблице Cust.  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
  
        <ElementType name="Order" sql:relation="CustOrder" >  
          <AttributeType name="OrderID" />  
          <AttributeType name="CustomerID" />  
          <attribute type="OrderID" />  
          <attribute type="CustomerID" />  
        </ElementType>  
  
       <ElementType name="CustomerID" dt:type="int" />  
       <ElementType name="CompanyName" dt:type="string" />  
       <ElementType name="City" dt:type="string" />  
  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
       <ElementType name="Customers" sql:relation="Cust"   
                         sql:overflow-field="OverflowColumn"  >  
          <element type="CustomerID" sql:field="CustomerID" />  
          <element type="CompanyName" sql:field="CompanyName" />  
          <element type="City" sql:field="City" />  
          <element type="Order" >   
               <sql:relationship  
                   key-relation="Cust"  
                    key="CustomerID"  
                    foreign-key="CustomerID"  
                    foreign-relation="CustOrder" />  
          </element>  
       </ElementType>  
    </Schema>  
    ```  
  
-   Если схема не содержит столбцов переполнения с помощью **SQL: Overflow-поле** заметки, Массовая загрузка XML пропускает любые данные, которые присутствуют в документе XML, но не описаны в схеме сопоставления.  
  
     Массовая загрузка XML применяет заданную схему сопоставления каждый раз, как в потоке XML-данных попадаются известные теги. Данные, которые присутствуют в XML-документе, но не описаны в схеме, пропускаются. Например, предположим, что схема сопоставления, который описывает  **\<клиента >** элемент. Файл данных XML имеет  **\<AllCustomers >** корневой тег (которые не описаны в схеме), который включает все  **\<клиента >** элементов:  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
      <Customer>...</Customer>  
       ...  
    </AllCustomers>  
    ```  
  
     В этом случае Массовая загрузка XML пропускает  **\<AllCustomers >** элемент и начинает сопоставление с  **\<клиента >** элемент. Массовая загрузка XML пропускает все элементы, не описанные в схеме, но присутствующие в XML-документе.  
  
     Рассмотрим другой файл источника данных XML, содержащий  **\<порядок >** элементов. Эти элементы не описаны в схеме сопоставления.  
  
    ```  
    <AllCustomers>  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      <Customer>...</Customer>  
        <Order> ... </Order>  
        <Order> ... </Order>  
         ...  
      ...  
    </AllCustomers>  
    ```  
  
     Массовая загрузка XML пропускает эти  **\<порядок >** элементов. Но если вы используете **SQL: Overflow-поле**заметки в схеме, чтобы указать столбец как столбец переполнения, Массовая загрузка XML сохранит все неиспользованные данные в этом столбце.  
  
-   Разделы CDATA и ссылки на сущности для сохранения их в базе данных преобразуются в эквивалентные строки.  
  
     В этом примере раздел CDATA содержит значение для  **\<Город >** элемент. Массовая загрузка XML извлекает строковое значение («NY»), прежде чем вставлять  **\<Город >** элемент в базу данных.  
  
    ```  
    <City><![CDATA[NY]]> </City>  
    ```  
  
     Массовая загрузка XML не сохраняет ссылки на сущности.  
  
-   Если в схеме сопоставления задано значение по умолчанию для атрибута и в исходных XML-данных этот атрибут отсутствует, при массовой загрузке XML будет использовано значение по умолчанию.  
  
     Следующий образец схемы XDR назначается значение по умолчанию для **HireDate** атрибут:  
  
    ```  
    <?xml version="1.0" ?>  
    <Schema xmlns="urn:schemas-microsoft-com:xml-data"   
            xmlns:dt="urn:schemas-microsoft-com:xml:datatypes"    
            xmlns:sql="urn:schemas-microsoft-com:xml-sql" >  
       <ElementType name="root" sql:is-constant="1">  
          <element type="Customers" />  
       </ElementType>  
  
       <ElementType name="Customers" sql:relation="Cust3" >  
          <AttributeType name="CustomerID" dt:type="int"  />  
          <AttributeType name="HireDate"  default="2000-01-01" />  
          <AttributeType name="Salary"   />  
  
          <attribute type="CustomerID" sql:field="CustomerID" />  
          <attribute type="HireDate"   sql:field="HireDate"  />  
          <attribute type="Salary"     sql:field="Salary"    />  
       </ElementType>  
    </Schema>  
    ```  
  
     В этом XML-данных **HireDate** отсутствует атрибут из второго  **\<клиентов >** элемент. Когда Массовая загрузка XML вставляет второй  **\<клиентов >** элемент в базу данных, используется значение по умолчанию, которая указана в схеме.  
  
    ```  
    <ROOT>  
      <Customers CustomerID="1" HireDate="1999-01-01" Salary="10000" />  
      <Customers CustomerID="2" Salary="10000" />  
    </ROOT>  
    ```  
  
-   **Заметки SQL: URL-кодирование** Аннотация не поддерживается:  
  
     Нельзя задать во вводных XML-данных URL-адрес и ждать, что массовая загрузка XML прочтет данные, находящиеся по этому адресу.  
  
     Создаются таблицы, заданные в схеме сопоставления (база данных должна существовать). Если один или несколько таблиц в базе данных уже существует, свойство SGDropTables определяет эти таблицы уничтожены, следует ли удалить и повторно создать.  
  
-   Если задано свойство SchemaGen (например, SchemaGen = true), будут созданы таблицы, которые определены в схеме сопоставления. Но SchemaGen не создает никаких ограничений (например, ограничений PRIMARY KEY/FOREIGN KEY) для этих таблиц с одним исключением: Если XML-узлы, которые составляют первичный ключ в связи определяются как имеющие тип XML с идентификатором (то есть **тип = «xsd:ID»** для XSD) и свойство SGUseID имеет значение True для SchemaGen, а затем не только первичные ключи создаются из узлов типа ID, но связи первичного/внешнего ключа создаются на основе сопоставление схемы связей.  
  
-   SchemaGen не использует аспекты схемы XSD и расширения для создания реляционной [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] схемы.  
  
-   Если задано свойство SchemaGen (например, SchemaGen = true) для массовой загрузки XML только таблицы (и не одноименные представления), которые задаются обновляются.  
  
-   SchemaGen предоставляет только базовую функциональность для создания реляционной схемы из аннотированного XSD. При необходимости пользователь должен изменить созданные таблицы вручную.  
  
-   Где существует более одной связи между таблицами, SchemaGen пытается создать одну связь, которая включает все ключи, участвующие в двух таблицах. Это ограничение может вызвать ошибку [!INCLUDE[tsql](../../../includes/tsql-md.md)].  
  
-   При массовой загрузке XML-данных в базу по меньшей мере один атрибут или дочерний элемент в схеме сопоставления должен быть сопоставлен со столбцом базы данных.  
  
-   Если при массовой загрузке XML происходит вставка значений дат, эти значения должны быть заданы в формате (-)CCYY-MM-DD((+-)TZ). Это стандартный формат даты в XSD.  
  
-   Некоторые флаги свойств несовместимы друг с другом. Например, Массовая загрузка не поддерживает **Ignoreduplicatekeys = true** вместе с **Keepidentity = false**. Когда **Keepidentity = false**, Массовая загрузка ожидает, что сервер для формирования значений ключей. Таблицы должны иметь **УДОСТОВЕРЕНИЙ** ограничение по ключу. Сервер будет не создает повторяющиеся ключи, поэтому нет необходимости для **Ignoreduplicatekeys** будет присвоено **true**. **Ignoreduplicatekeys** должно быть присвоено **true** только при передаче значений первичного ключа из входящих данных в таблицу, содержащую строки, если существует вероятность конфликта значений первичного ключа.  
  
  
