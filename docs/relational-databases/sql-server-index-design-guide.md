---
title: "Руководство по проектированию индексов SQL Server | Microsoft Docs"
ms.custom: ""
ms.date: "10/06/2016"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "database-engine"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 11f8017e-5bc3-4bab-8060-c16282cfbac1
caps.latest.revision: 3
author: "BYHAM"
ms.author: "rickbyh"
manager: "jhubbard"
caps.handback.revision: 3
---
# Руководство по проектированию индексов SQL Server
[!INCLUDE[tsql-appliesto-ss2008-all_md](../includes/tsql-appliesto-ss2008-all-md.md)]

  Плохо спроектированные индексы и их недостаточное количество — основной источник узких мест в приложениях баз данных. Проектирование эффективных индексов имеет первостепенную важность для достижения высокой производительности баз данных и приложений. Это руководство по проектированию индексов SQL Server содержит сведения и рекомендации, руководствуясь которыми вы сможете создавать эффективные индексы, удовлетворяющие потребностям ваших приложений.  
    
 Предполагается, что читатель обладает общими знаниями типов индексов, которые есть в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Общее описание типов индексов приведено в разделе [Типы индексов](http://msdn.microsoft.com/library/ms175049.aspx).  
  
  
##  <a name="Basics"></a> Основы проектирования индексов  
 Индекс является структурой на диске, которая связана с таблицей или представлением и ускоряет получение строк из таблицы или представления. Индекс содержит ключи, построенные из одного или нескольких столбцов в таблице или представлении. Эти ключи хранятся в виде структуры сбалансированного дерева, которая поддерживает быстрый поиск строк по их ключевым значениям в SQL Server.  
  
 Выбор правильных индексов для базы данных и ее рабочей нагрузки — это решение сложной задачи о соотношении скорости обработки запроса и стоимости обновления. Узкие индексы, то есть индексы, в ключе которых мало столбцов, требуют меньше места на диске и меньше текущих издержек. С другой стороны, широкие индексы охватывают больше запросов. Прежде чем удастся найти наиболее эффективный индекс, возможно, придется поэкспериментировать с несколькими различными вариантами. Добавление, изменение и удаление индексов не влияет на схему базы данных или конструкцию приложений. Следовательно, эксперименты с различными индексами можно проводить без каких-либо опасений.  
  
 Оптимизатор запросов в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] с большой вероятностью выбирает наилучший индекс в подавляющем большинстве случаев. Общая стратегия разработки индексов должна давать оптимизатору запросов по возможности разнообразные варианты, чтобы ему было из чего выбирать. Следует довериться его решению. Это уменьшит время анализа и обеспечит высокую производительность в различных ситуациях. Чтобы выяснить, какие индексы оптимизатор запросов использует для отдельных запросов, в меню [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]Запрос ** ** выберите элемент **Включить действительный план выполнения**.  
  
 Использование индекса не всегда означает высокую производительность, а высокая производительность не всегда означает эффективное использование индекса. Если бы использование индекса всегда способствовало производительности, то работа оптимизатора запросов была бы очень простой. На самом деле, неверный выбор индекса может привести к неоптимальной производительности. Следовательно, задача оптимизатора запросов состоит в том, чтобы выбрать индекс или комбинацию индексов, если это улучшит производительность, и избежать индексированного поиска, если это ее понизит.  
  
### Задачи проектирования индексов  
 Рекомендуемая стратегия проектирования индексов включает в себя следующие задачи:  
  
1.  Прежде всего следует понять характеристики самой базы данных. Например, будет ли это база данных оперативной обработки транзакций (OLTP) с часто изменяющимися данными, или система поддержки решений (DDS), или хранилище данных (OLAP), предназначенное в основном для чтения, которое должно быстро обрабатывать большие объемы данных. В [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]индексы *columnstore, оптимизированные для памяти xVelocity* особенно хорошо подходят для стандартных наборов данных хранилищ данных. Индексы columnstore могут изменить работу пользователей с хранилищем данных, обеспечивая более высокую производительность для таких стандартных запросов хранилища данных, как фильтрация, статистическая обработка, группирование и запросы соединения типа «звезда». Дополнительные сведения см. в разделе [Сводка функций индексов columnstore по версиям](Columnstore%20Indexes%20Guide.md).  
  
2.  Определите наиболее часто используемые запросы. Например, если известно, что часто используется запрос на соединение двух и более таблиц, это поможет определить наилучший тип индексов.  
  
3.  Выясните характеристики столбцов, используемых в запросах. Например, идеальным будет индекс для столбцов с типом данных integer, которые к тому же имеют уникальные или отличные от NULL значения. Для столбцов с хорошо определенными подмножествами данных в [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях можно использовать отфильтрованный индекс. Дополнительные сведения см. в разделе [Рекомендации по проектированию отфильтрованных индексов](#Filtered) этого руководства.  
  
4.  Определите, какие параметры индексов могут повысить производительность при создании индекса или при его поддержке. Например, при создании кластеризованного индекса для существующей большой таблицы очень выгодно будет использовать параметр ONLINE. Параметр ONLINE позволяет продолжать параллельную обработку базовых данных во время создания или повторного построения индекса. Дополнительные сведения см. в разделе [Установка параметров индекса](../relational-databases/indexes/set-index-options.md).  
  
5.  Определите оптимальное расположение для хранения индекса. Некластеризованный индекс может храниться в той же файловой группе, что и базовая таблица, или в другой группе. Правильный выбор расположения для хранения индексов может повысить производительность запросов за счет повышения скорости дискового ввода-вывода. Например, если некластеризованный индекс хранится в файловой группе не на том диске, на котором расположены файловые группы таблицы, то производительность может повыситься, поскольку это позволяет одновременно обращаться к нескольким дискам.  
  
     Кластеризованные и некластеризованные индексы могут использовать схему секционирования, которая охватывает несколько файловых групп. Секционирование делает большие таблицы и индексы более управляемыми, позволяет быстро и эффективно получать доступ к наборам данных и управлять ими, при этом сохраняя целостность всей коллекции. Дополнительные сведения см. в разделе [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md). При выборе секционирования определите, требуется ли выравнивание индекса, то есть должен ли индекс быть секционирован точно так же, как и таблицы, или он может быть секционирован иным образом.  
  
##  <a name="General_Design"></a> Общие рекомендации по проектированию индексов  
 Опытный администратор базы данных может спроектировать хороший набор индексов, но эта задача очень сложна, требует много времени и сопряжена с ошибками даже для рабочих нагрузок и баз данных средней сложности. В разработке оптимальных индексов может помочь понимание характеристик базы данных, запросов и столбцов данных.  
  
### Соображения, связанные с базами данных  
 При проектировании индекса следует учитывать следующие рекомендации:  
  
-   Большое количество индексов в таблице снижает производительность инструкций INSERT, UPDATE, DELETE и MERGE, потому что при изменении данных в таблице все индексы должны быть соответствующим образом изменены. Например, если столбец используется в нескольких индексах и выполняется инструкция UPDATE, которая изменяет данные из этого столбца, каждый индекс, содержащий этот столбец, должен быть обновлен, как и столбец в базовой таблице (куча или кластеризованный индекс).  
  
    -   Избегайте использования чрезмерного количества индексов для интенсивно обновляемых таблиц и следите, чтобы индексы были узкими, то есть содержали как можно меньше столбцов.  
  
    -   Используйте большое количество индексов, чтобы улучшить производительность запросов для таблиц с низкими требованиями к обновлениям, но большими объемами данных. Большое число индексов может повысить производительность запросов, которые не изменяют данных, таких как инструкции SELECT, поскольку у оптимизатора запросов будет больший выбор индексов при определении самого быстрого способа доступа.  
  
-   Индексирование маленьких таблиц может оказаться не лучшим выбором, так как поиск данных в индексе может потребовать у оптимизатора запросов больше времени, чем простой просмотр таблицы. Следовательно, для маленьких таблиц индексы могут вообще не использоваться, но тем не менее их необходимо поддерживать при изменении данных в таблице.  
  
-   Индексы представлений могут дать значительное улучшение производительности, если представление содержит агрегаты, соединения таблиц или сочетание того и другого. Необязательно явно ссылаться в запросе на представление, чтобы его мог использовать оптимизатор запросов.  
  
-   Для анализа базы данных и получения рекомендаций по созданию индексов следует использовать помощник по настройке ядра СУБД. Дополнительные сведения см. в разделе [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).  
  
### Вопросы работы с запросами  
 При проектировании индекса следует принимать во внимание следующие рекомендации, связанные с обработкой запросов.  
  
-   Следует создавать некластеризованные индексы для столбцов, которые часто используются в предикатах и условиях соединения в запросах. Однако следует избегать добавления столбцов без необходимости. Добавление слишком большого числа индексных столбцов может отрицательно повлиять на количество свободного места на диске и на производительность поддержания индекса.  
  
-   Покрывающие индексы могут повысить производительность запросов, так как данные, необходимые для удовлетворения требований запроса, присутствуют в самом индексе. Таким образом, для получения запрашиваемых данных требуются только страницы индекса, а не страницы данных таблицы или кластеризованного индекса. Следовательно, уменьшается общий объем операций дискового ввода-вывода. Например, запрос по столбцам **a** и **b** таблицы, у которой есть составной индекс, созданный на основе столбцов **a**, **b**и **c** , может найти нужные данные, пользуясь только этим индексом.  
  
-   Запросы следует составлять так, чтобы они вставляли или изменяли как можно больше строк одной инструкцией, вместо того, чтобы использовать для обновления тех же строк нескольких запросов. Используя только одну инструкцию, можно воспользоваться возможностями, которые обеспечивает поддержание оптимизированного индекса.  
  
-   Определите тип запроса и то, как в нем используются столбцы. Например: столбец, который используется в запросе с точным соответствием, может оказаться подходящим кандидатом для создания кластеризованного или некластеризованного индекса.  
  
### Вопросы работы со столбцами  
 При проектировании индекса, следует принимать во внимание следующие рекомендации, относящиеся к столбцам.  
  
-   Нужно следить, чтобы длина ключа для кластеризованных индексов была небольшой. Кроме того, кластеризованные индексы только выиграют при создании на основе уникальных или не принимающих значения NULL столбцах.  
  
-   Столбцы с типами данных **ntext**, **text**, **image**, **varchar(max)**, **nvarchar(max)** и **varbinary(max)** нельзя указать в качестве ключевых столбцов индекса. Однако типы данных **varchar(max)**, **nvarchar(max)**, **varbinary(max)** и **xml** могут участвовать в некластеризованных индексах в качестве их неключевых столбцов индекса. Дополнительные сведения см. в разделе [Индекс с включенными столбцами](#Included_Columns)этого руководства.  
  
-   Столбцы типа **xml** могут быть ключевым столбцом только в XML-индексе. Дополнительные сведения см в разделе [XML-индексы (SQL Server)](../relational-databases/xml/xml-indexes-sql-server.md). С пакетом обновления 1 (SP1) в SQL Server 2012 появился новый тип XML-индекса — выборочный XML-индекс. Этот новый индекс повышает производительность запросов для данных, хранимых в виде XML на SQL Server, и тем самым значительно ускоряет индексирование рабочих нагрузок XML-данных большого объема и повышает масштабируемость за счет уменьшения места хранения самого индекса. Дополнительные сведения см. в разделе [Выборочный XML-индекс (SXI)](../relational-databases/xml/selective-xml-indexes-sxi.md).  
  
-   Проверьте уникальность столбцов. Замена неуникального индекса уникальным для той же комбинации столбцов обеспечивает оптимизатору запросов дополнительные сведения, что делает индекс более полезным. Дополнительные сведения см. в разделе [Правила по созданию уникальных индексов](#Unique) этого руководства.  
  
-   Проверьте распределение данных в столбце. Часто длительное выполнение запроса обусловлено индексированием столбца, в котором мало уникальных значений, или присоединением такого столбца. Это фундаментальная проблема, связанная с данными и запросом, и обычно она не может быть решена без определения ситуации. Например: физический телефонный справочник, отсортированный в алфавитном порядке по фамилии, не сможет быстро найти человека, если всех жителей города зовут Смит или Джонс. Дополнительные сведения о распределении данных см. в разделе [Statistics](../relational-databases/statistics/statistics.md).  
  
-   Попробуйте применить отфильтрованные индексы для столбцов, имеющих точно определенные подмножества, например разреженных столбцов, столбцов, содержащих в основном значения NULL, столбцов с разнородными категориями значений и столбцов с различными диапазонами значений. Правильно составленный отфильтрованный индекс может увеличить скорость выполнения запроса, уменьшить стоимость обслуживания индекса и стоимость хранения.  
  
-   Следует учитывать порядок столбцов, если индекс будет включать их несколько. Столбец, использованный в предложении WHERE в условии поиска равных (=), больших (>), меньших (<) или находящихся в интервале (BETWEEN) значений или участвующий в соединении, должен стоять первым. Дополнительные столбцы должны быть упорядочены по уровню различимости, то есть от наиболее четкого к наименее четкому.  
  
     Например, если индекс определен как `LastName`, `FirstName` , индекс будет полезным, если критерий поиска — `WHERE LastName = 'Smith'` или `WHERE LastName = Smith AND FirstName LIKE 'J%'`. Однако оптимизатор запросов не станет использовать этот индекс для запроса только по критерию `FirstName (WHERE FirstName = 'Jane')`.  
  
-   Следует рассмотреть возможность индексирования вычисляемых столбцов. Дополнительные сведения см. в разделе [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).  
  
### Характеристики индекса  
 После того, как определено, что индекс соответствует запросу, можно выбрать наилучший тип индекса для конкретной ситуации. Ниже представлены характеристики индекса:  
  
-   кластеризованный или некластеризованный;  
  
-   уникальный или неуникальный;  
  
-   с одним или несколькими столбцами;  
  
-   порядок по возрастанию или по убыванию в столбцах индекса;  
  
-   полнотабличные или фильтруемые некластеризованные индексы.  
  
 Также можно задать начальные характеристики хранилища индекса, чтобы оптимизировать его производительность или поддержание, задав такие параметры, как FILLFACTOR. Чтобы оптимизировать производительность, можно также определить место хранения индекса с помощью файловых групп или схем секционирования.  
  
###  <a name="Index_placement"></a> Размещение индекса в файловых группах или схемах секций  
 Во время разработки стратегии индексирования следует обратить внимание на помещение индексов в файловые группы, связанные с базой данных. Аккуратный выбор схемы файловой группы или секционирования может улучшить производительность.  
  
 По умолчанию индексы хранятся в той же файловой группе, что и базовая таблица, для которой создается индекс. Несекционированный некластеризованный индекс и базовая таблица всегда находятся в одной файловой группе. Однако можно сделать следующее.  
  
-   Создайте некластеризованные индексы в файловой группе, отличной от файловой группы базовой таблицы или кластеризованного индекса.  
  
-   Секционировать кластеризованные и некластеризованные индексы, чтобы они размещались в нескольких файловых группах.  
  
-   Переместить таблицу из одной файловой группы в другую, удалив кластеризованный индекс и указав новую файловую группу или схему секционирования в предложении MOVE TO инструкции DROP INDEX или выполнив инструкцию CREATE INDEX с предложением DROP_EXISTING.  
  
 Создав некластеризованный индекс в другой файловой группе, можно достичь прироста производительности, если файловые группы находятся на разных физических дисках с собственными контроллерами. Сведения о данных и индексе могут считываться параллельно несколькими головками. Например, если таблица `Table_A` в файловой группе `f1` и индекс `Index_A` в файловой группе `f2` используются в одном и том же запросе, производительность увеличится, так как обе файловые группы используются полностью, не состязаясь между собой. Однако если таблица `Table_A` сканируется запросом, а на индекс `Index_A` ссылки нет, то используется только файловая группа `f1` . В этом случае нет никакого выигрыша в производительности.  
  
 Поскольку тип и время необходимого доступа спрогнозировать невозможно, лучшим решением может оказаться распределение таблиц и индексов по всем файловым группам. Это гарантирует, что доступ будет осуществляться ко всем дискам, так как все данные и индексы равномерно распределены по ним, независимо от способа доступа к данным. Для системных администраторов этот подход также более прост.  
  
#### Секции во многих файловых группах  
 Можно рассмотреть возможность секционирования кластеризованных и некластеризованных индексов по нескольким файловым группам. Секционированные индексы разбиваются горизонтально или построчно, в зависимости от функции секционирования. Функция секционирования определяет, как каждая строка сопоставляется с набором секций на основе значений определенных столбцов — столбцов секционирования. Схема секционирования определяет сопоставление секций набору файловых групп.  
  
 Секционирование индекса может предоставить следующие преимущества.  
  
-   Система становится более масштабируемой, а управление большими индексами в ней упрощается. Например, в системах OLTP можно реализовать приложения, учитывающие секционирование и работающие с большими индексами.  
  
-   Запросы выполняются быстрее и эффективнее. Когда запросы выполняются в нескольких секциях индекса, оптимизатор запросов может обрабатывать определенные секции в одно и то же время и исключать секции, к которым запрос не относится.  
  
 Дополнительные сведения см. в разделе [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).  
  
###  <a name="Sort_Order"></a> Рекомендации по созданию порядка сортировки индексов  
 При определении индексов следует иметь в виду, что данные ключевых столбцов индекса сохраняются в порядке возрастания или убывания. По умолчанию сортировка производится по возрастанию, как и в предыдущих версиях [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Синтаксис инструкций CREATE INDEX, CREATE TABLE и ALTER TABLE поддерживает ключевые слова ASC (по возрастанию) и DESC (по убыванию) для конкретных столбцов в индексах и ограничениях.  
  
 Указание порядка, в котором значения ключей хранятся в индексе, полезно тогда, когда запрос ссылается на таблицу с предложением ORDER BY, в котором указано другое направление для ключевого столбца индекса или индексированного столбца. В этом случае индекс может исключить необходимость в операторе SORT в плане запроса, то есть запрос будет выполняться значительно эффективнее. Например, покупателю в отделе заказов [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] необходимо определить качество товаров от разных поставщиков. Больше всего его интересуют товары тех поставщиков, которые имеют набольшую частоту отказов. Как показано в следующем запросе, получение данных по соответствию этому критерию требует, чтобы столбец `RejectedQty` в таблице `Purchasing.PurchaseOrderDetail` был отсортирован в порядке убывания (от большего значения к меньшему), а столбец `ProductID` — в порядке возрастания (от меньшего к большему).  
  
```  
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 Следующий план выполнения для этого запроса показывает, что оптимизатор запросов применяет оператор SORT для результирующего набора в порядке, указываемом предложением ORDER BY.  
  
 ![IndexSort1](../relational-databases/media/indexsort1.gif)
  
  
 Если создан индекс для ключевых столбцов, который соответствует индексу, указанному в предложении ORDER BY, оператор SORT может быть исключен из плана запроса, что значительно повысит его эффективность.  
  
```  
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 После повторного выполнения запроса план выполнения показывает, что оператор SORT исключен и используется вновь созданный некластеризованный индекс.  
  
 ![InsertSort2](../relational-databases/media/insertsort2.gif)
  
  
 [!INCLUDE[ssDE](../includes/ssde-md.md)] одинаково эффективно работает в обоих направлениях. Индекс, определенный как `(RejectedQty DESC, ProductID ASC)` , может также быть использован в запросах с порядком сортировки, обратным порядку, определенному в предложении ORDER BY. Например, запрос со следующим предложением ORDER BY-: `ORDER BY RejectedQty ASC, ProductID DESC` может воспользоваться этим индексом.  
  
 Порядок сортировки может быть указан только для ключевых столбцов. Представление каталога [sys.index_columns](../relational-databases/system-catalog-views/sys-index-columns-transact-sql.md) и функция INDEXKEY_PROPERTY помогут определить, в каком порядке хранится столбец индекса — возрастающем или убывающем.  
  
  
##  <a name="Clustered"></a> Правила проектирования кластеризованного индекса  
 Кластеризованные индексы сортируют и хранят строки данных в таблице, основываясь на их ключевых значениях. Может быть только один кластеризованный индекс на таблицу, потому что сами строки данных могут быть отсортированы только в одном порядке. За несколькими исключениями, каждая таблица должна иметь кластеризованный индекс, определенный по столбцу или столбцам и предлагающий следующее:  
  
-   Может применяться для часто используемых запросов.  
  
-   Обеспечивает высокую степень уникальности.  
  
    > [!NOTE]  
    >  При создании ограничения PRIMARY KEY будет автоматически создан уникальный индекс по столбцу или столбцам. По умолчанию этот индекс кластеризован; однако при создании ограничения можно указать некластеризованный индекс.  
  
-   Может использоваться в диапазонных запросах.  
  
 Если кластеризованный индекс создан не со свойством UNIQUE, компонент [!INCLUDE[ssDE](../includes/ssde-md.md)] автоматически добавляет 4-байтовый столбец uniqueifier к таблице. При необходимости компонент [!INCLUDE[ssDE](../includes/ssde-md.md)] автоматически добавляет значение uniqueifier к строке, чтобы сделать каждый ключ уникальным. Данный столбец и его значения используются внутри и недоступны пользователям для просмотра или использования.  
  
### Архитектура кластеризованного индекса  
 В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] индексы организованы в виде сбалансированных деревьев. Каждая страница в сбалансированном дереве индекса называется узлом индекса. Верхний узел сбалансированного дерева называется корневым. Узлы нижнего уровня индекса называются конечными. Все уровни индекса между корневыми и конечными узлами называются промежуточными. В кластеризованном индексе конечные узлы содержат страницы данных базовой таблицы. На страницах индекса корневого и промежуточного узлов находятся строки индекса. Каждая строка индекса содержит ключевое значение и указатель либо на страницу промежуточного уровня сбалансированного дерева, либо на строку данных на конечном уровне индекса. Страницы на каждом уровне связаны в двунаправленный список.  
  
 Для каждого кластеризованного индекса таблица [sys.partitions](../relational-databases/system-catalog-views/sys-partitions-transact-sql.md) содержит одну строку со значением **index_id**, равным 1 для каждой секции, используемой индексом. По умолчанию, кластеризованный индекс занимает одну секцию. Если кластеризованный индекс занимает несколько секций, каждая секция содержит сбалансированное дерево, содержащее данные этой секции. Например, если кластеризованный индекс занимает четыре секции, существует четыре сбалансированных дерева: по одному в каждой секции.  
  
 В зависимости от типов данных, каждая структура кластеризованного индекса состоит из одной или более единиц распределения, которые применяются для хранения и управления данными секции. Для каждой секции кластеризованный индекс содержит, как минимум, одну единицу распределения IN_ROW_DATA. Для хранения столбцов больших объектов (LOB) кластеризованному индексу требуется одна единица распределения LOB_DATA для каждой секции. Кроме того, для хранения строк переменной длины, превышающих ограничение на размер строки, равное 8 060 байтам, для каждой секции требуется одна единица распределения ROW_OVERFLOW_DATA.  
  
 Страницы в цепочке данных и строки, которые они содержат, упорядочены по значению ключа кластеризованного индекса. Все строки вставляются так, чтобы значение ключа составляло вместе с существующими строками упорядоченную последовательность.  
  
 На следующем рисунке изображена структура кластеризованного индекса для одной секции.  
 
 ![bokind2](../relational-databases/media/bokind2.gif)  
  
### Вопросы работы с запросами  
 Прежде чем создать кластеризованные индексы, необходимо понять, как будет происходить обращение к данным. Рассмотрим использование кластеризованного индекса для запросов, которые выполняют следующее:  
  
-   Возвращают диапазон значений с помощью операторов, таких как BETWEEN, >, >=, < и <=.  
  
     После того как строка с первым значением будет найдена с помощью кластеризованного индекса, строки с последующими индексированными значениями гарантированно окажутся физически смежными с этой строкой. Например, если запрос получает записи из диапазона порядковых номеров продаж, кластеризованный индекс по столбцу `SalesOrderNumber` может быстро определить расположение строки, содержащей стартовый порядковый номер продаж, и затем извлечь все последующие строки из таблицы, пока не будет достигнут последний порядковый номер продаж.  
  
-   Возвращают большие результирующие наборы.  
  
-   Используют предложения JOIN; обычно в них участвуют внешние ключевые столбцы.  
  
-   Используют предложения ORDER BY или GROUP BY.  
  
     Индекс по столбцам, указанным в предложении ORDER BY или GROUP BY, может исключить потребность в сортировке данных для компонента [!INCLUDE[ssDE](../includes/ssde-md.md)] , потому что строки будут уже отсортированы. Это улучшает производительность запроса.  
  
### Вопросы работы со столбцами  
 В общем случае надо так определить ключ кластеризованного индекса, чтобы в него вошло как можно меньше столбцов. Рассмотрите столбцы, которым присущ один или несколько следующих атрибутов:  
  
-   Являются уникальными или содержат много различных значений.  
  
     Например, идентификатор сотрудника уникально идентифицирует служащих. Кластеризованный индекс или ограничение PRIMARY KEY на столбец `EmployeeID` улучшило бы производительность запросов, которые производят поиск сведений о сотруднике, основываясь на номере идентификатора сотрудника. В качестве альтернативы кластеризованный индекс мог бы быть создан по столбцам `LastName`, `FirstName`и `MiddleName` , потому что записи сотрудников часто группируются и запрашиваются именно таким образом, так что сочетание этих столбцов обеспечивало бы высокую степень различия.  
  
-   Обращение к ним происходит последовательно.  
  
     Например, код продукта уникально идентифицирует продукты в таблице `Production.Product` в базе данных [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] . Запросы, в которых указан последовательный поиск, например `WHERE ProductID BETWEEN 980 and 999`, извлекут заметную выгоду из кластеризованного индекса по `ProductID`. Это происходит потому, что строки будут храниться в отсортированном порядке по этому ключевому столбцу.  
  
-   Определен как IDENTITY.  
  
-   Часто используются для сортировки данных, полученных из таблицы.  
  
     Это может служить хорошей идеей для кластеризации (которая по сути является физической сортировкой) таблицы по этому столбцу, потому что исключит затраты на сортировку при каждом запросе к столбцу.  
  
 Кластеризованные индексы — не лучший выбор для следующих атрибутов:  
  
-   столбцов, которые подвергаются частым изменениям;  
  
     Изменения вызывают перемещение целых строк, потому что компонент [!INCLUDE[ssDE](../includes/ssde-md.md)] должен сохранять значения данных строки в физическом порядке. Это важно при работе в крупномасштабных системах обработки транзакций, в которых данные обычно быстро меняются.  
  
-   широких ключей.  
  
     Широкие ключи составлены из нескольких столбцов или нескольких столбцов большого размера. Ключевые значения из кластеризованного индекса используются всеми некластеризованными индексами как уточняющие запросы. Любые некластеризованные индексы, определенные на той же самой таблице, будут значительно больше, потому что записи некластеризованного индекса содержат ключ кластеризации, а также ключевые столбцы, определенные для этого некластеризованного индекса.  
  
  
##  <a name="Nonclustered"></a> Рекомендации по созданию некластеризованных индексов  
 Некластеризованный индекс содержит значения ключей индекса и указатели строк, которые указывают на место хранения табличных данных. Можно создать несколько некластеризованных индексов для таблицы или индексированного представления. Как правило, некластеризованные индексы следует создавать для повышения эффективности часто используемых запросов, не учитываемых кластеризованными индексами.  
  
 Подобно тому, как читатель использует индекс в книге, оптимизатор запросов выискивает значение типа данных, просматривая некластеризованный индекс. Там он находит место расположения интересующего его значения в таблице и затем получает данные непосредственно из этого места. Благодаря этому некластеризованные индексы считаются оптимальным выбором для запросов с точным соответствием, поскольку такие индексы содержат записи, описывающие точное расположение в таблице значений типов данных, которые задаются в подобных запросах. К примеру, чтобы выбрать в таблице `HumanResources. Employee` всех сотрудников, подчиняющихся тому или иному менеджеру, оптимизатор запросов может воспользоваться некластеризованным индексом `IX_Employee_ManagerID`; ключевым столбцом в нем является `ManagerID`. Оптимизатор запросов может быстро обнаружить в индексе все записи, соответствующие указанному значению `ManagerID`. Каждый элемент указателя ссылается на конкретную страницу и строку в таблице или на кластеризованный индекс, в котором можно найти соответствующие данные. После того как оптимизатор запросов обнаружит все записи в индексе, он может переходить непосредственно к нужной странице и строке, откуда он будет получать требуемые данные.  
  
### Архитектура некластеризованного индекса  
 Некластеризованные индексы имеют ту же структуру сбалансированного дерева, что и кластеризованные индексы; существуют только следующие различия:  
  
-   строки данных в базовой таблице не сортируются и хранятся в порядке, который основан на их некластеризованных ключах;  
  
-   конечный уровень некластеризованного индекса состоит из страниц индекса вместо страниц данных.  
  
 Указатели строк на строках некластеризованных индексов являются либо указателем на строку, либо ключом кластеризованного индекса для строки, как описано ниже.  
  
-   Если таблица является кучей, что означает, что она не содержит кластеризованный индекс, то обнаружитель строки является указателем на строку. Указатель строится на основе идентификатора файла (ID), номера страницы и номера строки на странице. Весь указатель целиком называется идентификатором строки (RID).  
  
-   Если для таблицы имеется кластеризованный индекс или индекс построен на индексированном представлении, то указатель строки — это ключ кластеризованного индекса для строки.  
  
 Для некластеризованных индексов таблица [sys.partitions](../relational-databases/system-catalog-views/sys-partitions-transact-sql.md) содержит одну строку со значением столбца **index_id** >1 для каждой секции, используемой индексом. По умолчанию некластеризованный индекс включает одну секцию. Если некластеризованный индекс состоит из нескольких секций, то каждая секция имеет структуру сбалансированного дерева, в которой содержатся индексные строки для данной конкретной секции. Например, если некластеризованный индекс состоит из четырех секций, то существуют четыре структуры сбалансированного дерева, по одной на каждую секцию.  
  
 В зависимости от типов данных в некластеризованном индексе каждая структура некластеризованного индекса будет содержать одну или более единиц распределения, в которых хранятся данные для определенной секции. Каждый некластеризованный индекс будет содержать по меньшей мере одну единицу распределения IN_ROW_DATA на секцию, в которой хранятся страницы сбалансированного дерева индекса. Некластеризованный индекс будет также содержать одну единицу распределения LOB_DATA на секцию, если в индексе содержатся столбцы типа большого объекта (LOB). Кроме того, некластеризованный индекс будет содержать одну единицу распределения ROW_OVERFLOW_DATA на секцию, если в индексе содержатся столбцы переменной длины, в которых превышается максимальный размер строки, равный 8 060 байт.  
  
 На следующей иллюстрации показана структура некластеризованного индекса, состоящего из одной секции.  

![bokind1a](../relational-databases/media/bokind1a.gif)  
  
  
### Соображения, связанные с базами данных  
 При проектировании некластеризованных индексов следует принимать во внимание характеристики соответствующей базы данных.  
  
-   В базах данных или таблицах, характеризующихся нечастыми обновлениями и большими объемами хранимых данных, запросы могут выполняться быстрее при использовании множества некластеризованных индексов. Рекомендуется создать отфильтрованные индексы для четко определенных подмножеств данных, что позволит повысить производительность запросов, а также снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными некластеризованными индексами.  
  
     Производительность приложений систем поддержки принятия решений, а также баз данных может быть увеличена за счет использования большого числа некластеризованных индексов. В процессе определения наиболее быстрого метода доступа оптимизатор запросов может выбирать из большего числа индексов, а если база данных не предназначена для частых обновлений, это значит, что операции по обслуживанию индексов не будут сказываться на ее быстродействии.  
  
-   При работе с приложениями и базами данных обработки транзакций в сети следует избегать слишком большого числа индексов. Кроме того, индексы должны быть узкими, то есть содержать минимальное количество столбцов.  
  
     Большое количество индексов в таблице снижает производительность инструкций INSERT, UPDATE, DELETE и MERGE, потому что при изменении данных в таблице все индексы должны быть соответствующим образом изменены.  
  
### Вопросы работы с запросами  
 Перед тем как приступать к созданию некластеризованных индексов, необходимо разобраться с тем, каким образом будет организован доступ к данным. Рассмотрите возможность использования некластеризованных индексов для запросов, обладающих следующими атрибутами:  
  
-   Используйте предложения JOIN или GROUP BY.  
  
     Создавайте многомерные некластеризованные индексы для столбцов, участвующих в операциях соединения и группирования, а кластеризованный индекс для внешних ключевых столбцов.  
  
-   Запросы, не возвращающие больших результирующих наборов.  
  
     Создайте отфильтрованные индексы для использования с запросами, возвращающими четко определенные подмножества строк из большой таблицы.  
  
-   Содержат столбцы, часто встречающиеся в условиях поиска запроса, таких как предложение WHERE, возвращающих точные соответствия.  
  
### Вопросы работы со столбцами  
 Рассмотрите столбцы, обладающие одним или несколькими указанными ниже атрибутами:  
  
-   Покрытие запроса.  
  
     Производительность повышается в тех случаях, когда индекс содержит все столбцы запроса. Оптимизатор запросов может обнаружить все значения столбцов внутри данного индекса; необходимость в обращении к таблицам или данным кластеризованных индексов отпадает, в результате чего снижается интенсивность дисковых операций ввода-вывода. Для расширения покрытия столбцов не следует создавать широкий ключ индекса; используйте индекс с включенными столбцами.  
  
     Если таблица имеет кластеризованный индекс, то столбец или столбцы, определенные в этом кластеризованном индексе, автоматически добавляются к концу каждого некластеризованного индекса таблицы. Это может привести к возникновению покрытого запроса без указания столбцов кластеризованного индекса в определении некластеризованного индекса. Так, если для таблицы имеется кластеризованный индекс в столбце `C`, то некластеризованный индекс в столбцах `B` и `A` будет иметь в качестве ключевых значений столбцы `B`, `A`и `C`.  
  
-   Множество индивидуальных значений, таких как сочетание фамилии и имени, если кластеризованный индекс используется для других столбцов.  
  
     Если имеется очень мало индивидуальных значений, скажем, только 1 и 0, то при выполнении большинства запросов этот индекс не будет использоваться, так как эффективность просмотра таблиц, как правило, выше. Для этого типа данных рекомендуется создать отфильтрованный индекс для определенного значения, которое содержится в небольшом количестве строк. Например, если большая часть значений равна 0, то оптимизатор запросов может использовать отфильтрованный индекс для строк данных, в которых содержится 1.  
  
####  <a name="Included_Columns"></a> Использование включенных столбцов для расширения некластеризованных индексов  
 Функциональность некластеризованных индексов можно расширить с помощью добавления неключевых столбцов к конечному уровню некластеризованного индекса. Добавление неключевых столбцов позволяет создавать некластеризованные индексы, покрывающие больше запросов. Это обусловлено следующими преимуществами неключевых столбцов.  
  
-   Они могут содержать типы данных, не разрешенные для ключевых столбцов индекса.  
  
-   Они не учитываются компонентом [!INCLUDE[ssDE](../includes/ssde-md.md)] при расчете числа ключевых столбцов индекса и размера ключа индекса.  
  
 Индекс с включенными неключевыми столбцами может значительно повысить производительность запроса, когда все столбцы запроса включены в индекс как ключевые или неключевые. Производительность повышается благодаря тому, что оптимизатор запросов может найти все значения столбцов в этом индексе; при этом нет обращения к данным таблиц или кластеризованных индексов, что приводит к меньшему количеству дисковых операций ввода-вывода.  
  
> [!NOTE]  
>  Если индекс содержит все столбцы, ссылаемые в запросе, это называется покрытием запроса.  
  
 В то время как ключевые столбцы сохраняются на всех уровнях индекса, неключевые столбцы сохраняются только на конечном уровне.  
  
##### Использование включенных столбцов для обхода ограничений по размеру  
 Можно включать неключевые столбцы в некластеризованный индекс, чтобы избежать превышения текущих ограничений на размер индекса (16 ключевых столбцов) и размер ключа индекса (900 байт). Компонент [!INCLUDE[ssDE](../includes/ssde-md.md)] не учитывает неключевые столбцы при расчете количества ключевых столбцов индекса и размера ключа индекса.  
  
 Например, нужно индексировать следующие столбцы в таблице `Document` :  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 Поскольку для типов данных **nchar** и **nvarchar** необходимо 2 байта для каждого символа, индекс, содержащий эти три столбца, на 10 байт превысит ограничение на размер в 900 байт (455 * 2). Использование предложения `INCLUDE` в инструкции `CREATE INDEX` позволит определить ключ индекса как (`Title, Revision`), а `FileName` определить как неключевой столбец. Таким образом, размер ключа индекса составит 110 байт (55 \* 2), при этом индекс будет по-прежнему содержать все нужные столбцы. Следующая инструкция создает такой индекс:  
  
```  
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### Правила для индекса с включенными столбцами  
 При проектировании некластеризованных индексов с включенными столбцами пользуйтесь следующими правилами.  
  
-   Неключевые столбцы определяются предложением INCLUDE инструкции CREATE INDEX.  
  
-   Неключевые столбцы можно определять только для некластеризованных индексов по таблицам или индексированным представлениям.  
  
-   Допускаются данные всех типов, за исключением **text**, **ntext**и **image**.  
  
-   Вычисляемые столбцы, являющиеся детерминированными и точными или неточными, могут быть включенными столбцами. Дополнительные сведения см. в разделе [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).  
  
-   Как и ключевые столбцы, вычисляемые столбцы, полученные на основе типов данных **image**, **ntext** и **text**, могут быть неключевыми (включенными) столбцами, если тип данных этого вычисляемого столбца допустим в качестве неключевого столбца индекса.  
  
-   Имена столбцов нельзя указывать ни в списке INCLUDE, ни в списке ключевых столбцов.  
  
-   Имена столбцов в списке INCLUDE нельзя повторять.  
  
##### Требования к размеру столбцов  
  
-   Должен быть определен как минимум один ключевой столбец. Максимальное количество неключевых столбцов равно 1023. Это на 1 меньше, чем максимальное количество столбцов таблицы.  
  
-   Ключевые столбцы индекса, в отличие от неключевых, должны удовлетворять текущим ограничениям на максимальное количество столбцов (16) и общий размер ключа индекса (900 байт).  
  
-   Общий размер всех неключевых столбцов ограничен только размером столбцов, указанных в предложении INCLUDE, например, столбцы **varchar(max)** могут иметь размер до 2 ГБ.  
  
##### Правила изменения столбца  
 При изменении столбца таблицы, определенного как включенный столбец, действуют следующие ограничения.  
  
-   Неключевые столбцы нельзя удалять из таблицы до удаления соответствующего индекса.  
  
-   Неключевые столбцы нельзя изменять, за исключением следующих операций:  
  
    -   изменение поведения столбца в отношении значения NULL с NOT NULL на NULL;  
  
    -   увеличение длины столбцов типов **varchar**, **nvarchar**и **varbinary** .  
  
        > [!NOTE]  
        >  Эти ограничения на изменение столбца также применяются к ключевым столбцам индекса.  
  
##### Рекомендации по проектированию  
 Переопределите некластеризованные индексы с большим размером ключа индекса, чтобы только столбцы, используемые для поиска и уточняющего запроса, были ключевыми. Все остальные столбцы, покрывающие запрос, сделайте включенными неключевыми столбцами. Таким образом, в наличии будут все столбцы, покрывающие запрос, но сам ключ индекса будет небольшим и эффективным.  
  
 Например, нужно спроектировать индекс, покрывающий следующий запрос:  
  
```  
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 Для покрытия запроса необходимо включить в индекс все его столбцы. Хотя можно определить все столбцы как ключевые, размер ключа составит 334 байт. Поскольку в качестве критерия поиска реально используется только столбец `PostalCode` , имеющий длину 30 байт, более эффективный индекс определит `PostalCode` в качестве ключевого столбца, а все остальные столбцы включит как неключевые.  
  
 Следующая инструкция создает индекс с включенными столбцами, покрывающий данный запрос.  
  
```  
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### Вопросы производительности  
 Избегайте добавления неиспользуемых столбцов. Добавление слишком большого количества столбцов, ключевых или неключевых, может оказать следующее влияние на производительность.  
  
-   На странице будет помещаться меньше строк индекса. Это может привести к увеличению количества операций ввода-вывода и снизить эффективность кэша.  
  
-   Увеличение места на диске, требуемого для хранения индекса. В частности, добавление типов данных **varchar(max)**, **nvarchar(max)**, **varbinary(max)** или **xml** в качестве неключевых столбцов индекса может значительно повысить требования к месту на диске. Это обусловлено тем, что значения столбцов копируются на конечный уровень индекса. Поэтому они находятся и в индексе, и в базовой таблице.  
  
-   Обслуживание индекса может увеличить время выполнения операций изменения, вставки, обновления и удаления в базовой таблице или индексированном представлении.  
  
 Необходимо определить, что важнее — повышение производительности запросов или производительность при изменении данных и дополнительные требования к месту на диске.  
  
  
##  <a name="Unique"></a> Правила по созданию уникальных индексов  
 Уникальный индекс гарантирует, что ключ индекса не будет содержать одинаковых значений, а значит, каждая строка в таблице будет уникальна. Создание уникального индекса имеет смысл, только если данные сами по себе могут быть уникальными. Например, если требуется обеспечить уникальность значений в столбце `NationalIDNumber` из таблицы `HumanResources.Employee` , когда первичным ключом является `EmployeeID`, создайте ограничение UNIQUE для столбца `NationalIDNumber` . Если пользователь попытается ввести в этот столбец одно и тоже значение для нескольких сотрудников, появится сообщение об ошибке, а дублирующие данные не будут сохранены.  
  
 В случае уникальных индексов по нескольким столбцам индекс гарантирует, что каждая комбинация значений в ключе индекса уникальна. Например, если уникальный индекс создан для комбинации столбцов `LastName`, `FirstName`и `MiddleName` , то никакие две строки в таблице не могут образовывать одну и ту же комбинацию этих значений.  
  
 Как кластеризованные, так и некластеризованные индексы могут быть уникальными. Учитывая, что данные в столбце уникальны, можно создать уникальный кластеризованный индекс и несколько уникальных некластеризованных индексов для одной и той же таблицы.  
  
 Уникальные индексы имеют следующие преимущества:  
  
-   Гарантируется целостность данных в определенных столбцах.  
  
-   Предоставляются дополнительные сведения, полезные оптимизатору запросов.  
  
 Создание ограничений PRIMARY KEY или UNIQUE автоматически создает уникальный индекс для заданных столбцов. Между созданием ограничения UNIQUE и созданием уникального индекса независимо от ограничения больших различий нет. Проверка данных происходит подобным же образом, и оптимизатор запросов не делает различия между уникальным индексом, который создан ограничением, и индексом, созданным вручную. Однако на столбцы, для которых важна целостность данных, следует накладывать ограничение UNIQUE или PRIMARY KEY. Тогда цель создания индекса будет ясна.  
  
### Замечания  
  
-   Уникальный индекс и ограничения UNIQUE и PRIMARY KEY не могут быть созданы, если дублирующиеся значения уже существуют.  
  
-   Если данные уникальны и если нужно и далее требовать этой уникальности, создание уникального индекса вместо неуникального для тех же сочетаний столбцов предоставит дополнительные сведения оптимизатору запросов, который может создать более эффективные планы выполнения. В этом случае рекомендуется создание уникального индекса (предпочтительнее через ограничение UNIQUE).  
  
-   Уникальный некластеризованный индекс может содержать любые неключевые столбцы. Дополнительные сведения о включенных столбцах см. в разделе [Индекс с включенными столбцами](#Included_Columns).  
  
  
##  <a name="Filtered"></a> Рекомендации по проектированию отфильтрованных индексов  
 Отфильтрованный индекс — это оптимизированный некластеризованный индекс, особенно подходящий для запросов, осуществляющих выборку из хорошо определенного подмножества данных. Он использует предикат фильтра для индексирования части строк в таблице. Хорошо спроектированный отфильтрованный индекс позволяет повысить производительность запросов, снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными индексами.  
  
||  
|-|  
|**Область применения**: начиная с [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] до [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
  
 Отфильтрованные индексы могут предоставить следующие преимущества по сравнению с индексами, построенными на всей таблице.  
  
-   **Улучшение производительности запроса и качества плана**  
  
     Хорошо спроектированный отфильтрованный индекс повышает производительность запроса и качество плана выполнения, поскольку он меньше, чем полнотабличный некластеризованный индекс, и содержит отфильтрованную статистику. Отфильтрованная статистика точнее полнотабличной статистики, так как содержит только строки отфильтрованного индекса.  
  
-   **Снижение расходов на обслуживание индекса**  
  
     Индекс обслуживается только в случае, если инструкции языка обработки данных (DML) затрагивают данные в индексе. Отфильтрованный индекс уменьшает расходы на обслуживание индекса по сравнению с полнотабличным некластеризованным индексом, поскольку он меньше и обслуживается только при изменении данных в индексе. Возможно наличие большого числа отфильтрованных индексов, особенно если они содержат редко изменяющиеся данные. Аналогично, если отфильтрованный индекс содержит только часто изменяемые данные, меньший размер индекса уменьшает затраты на обновление статистики.  
  
-   **Снижение затрат на хранение индекса**  
  
     Создание отфильтрованного индекса может уменьшить место на диске для некластеризованных индексов, если нет необходимости в полнотабличном индексе. Полнотабличный некластеризованный индекс можно заменить несколькими отфильтрованными индексами без значительного увеличения требований к хранилищу.  
  
 Отфильтрованные индексы полезны, когда столбцы содержат хорошо определенные подмножества данных, указанных в инструкциях SELECT. Примеры:  
  
-   Разреженные столбцы, содержащие небольшое количество значений, отличных от NULL.  
  
-   Разнородные столбцы, содержащие категории данных.  
  
-   Столбцы, содержащие диапазоны значений, таких как количество долларов, время и даты.  
  
-   Секции таблицы, определенные логикой простого сравнения для значений столбцов.  
  
 Снижение затрат на обслуживание отфильтрованного индекса более заметно, когда количество строк в индексе является небольшим по сравнению с полнотабличным индексом. Если отфильтрованный индекс включает большую часть строк в таблице, его обслуживание может быть более затратным по сравнению с полнотабличным индексом. В этом случае нужно использовать полнотабличный индекс вместо отфильтрованного.  
  
 Отфильтрованные индексы определены в одной таблице и поддерживают только простые операторы сравнения. Если необходим критерий фильтра, который ссылается на множество таблиц или имеет сложную логику, нужно создать представление.  
  
### Вопросы проектирования  
 Для разработки эффективных отфильтрованных индексов важно понимать, какие запросы приложения используются и как они связаны с подмножествами данных. Некоторые примеры данных, имеющих точно определенные подмножества, являются столбцами, содержащими в основном значения NULL, столбцами с разнородными категориями и столбцами с различными диапазонами значений. Далее приведены различные сценарии, в которых отфильтрованный индекс дает преимущества над полнотабличными индексами.  
  
#### Отфильтрованные индексы для подмножеств данных  
 Если столбец содержит только небольшое число удовлетворяющих запросу значений, можно создать отфильтрованный индекс на этом подмножестве значений. Например, если столбец содержит в основном значения NULL, а запрос выбирает только из значений, отличных от NULL, можно создать отфильтрованный индекс для строк данных, отличных от NULL. В результате индекс уменьшится и затраты на его обслуживание будут значительно меньше, чем для полнотабличного некластеризованного индекса на тех же ключевых столбцах.  
  
 Например, база данных `AdventureWorks2012` содержит таблицу `Production.BillOfMaterials` с 2679 строками. Столбец `EndDate` содержит только 199 строк, содержащих значения, отличные от NULL, и 2 480 строк, содержащих значение NULL. Следующий отфильтрованный индекс может перекрывать запросы, которые возвращают столбцы, указанные в индексе, и выбирают только строки, содержащие значения `EndDate`, отличные от NULL.  
  
```  
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 Отфильтрованный индекс `FIBillOfMaterialsWithEndDate` допустим для следующего запроса. Можно отобразить план выполнения запроса для проверки того, использует ли оптимизатор запросов отфильтрованный индекс.  
  
```  
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 Дополнительные сведения о создании отфильтрованного индекса и об определении выражения предиката отфильтрованного индекса см. в разделе [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).  
  
#### Отфильтрованные индексы для разнородных данных  
 Если таблица содержит строки с разнородными данными, можно создать отфильтрованный индекс для одной или более категорий данных.  
  
 Например, продукты, содержащиеся в таблице `Production.Product` , связаны с идентификатором `ProductSubcategoryID`, который в свою очередь связан с категориями продуктов, такими как велосипеды, запчасти, одежда или аксессуары. Эти категории являются разнородными, так как значения их столбцов в таблице `Production.Product` не являются близко коррелирующими. Например, столбцы `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`и `Style` имеют уникальные характеристики для каждой категории продукта. Предположим, что существуют частые запросы на аксессуары, имеющие подкатегории с 27 по 36 включительно. Можно повысить результативность запросов на аксессуары, создав отфильтрованный индекс по подкатегориям аксессуаров, как показано в следующем примере.  
  
```  
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;  
  
```  
  
 Отфильтрованный индекс `FIProductAccessories` включает следующий запрос, поскольку результаты  
  
 запроса содержатся в индексе, а план запроса не включает в себя поиск в базовых таблицах. Например, выражение предиката запроса `ProductSubcategoryID = 33` — это подмножество предиката отфильтрованного индекса `ProductSubcategoryID >= 27` и `ProductSubcategoryID <= 36`, а столбцы `ProductSubcategoryID` и `ListPrice` в предикате запроса являются ключевыми столбцами в индексе. Имя сохраняется на конечном уровне индекса в качестве включенного столбца.  
  
```  
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
  
```  
  
#### Ключевые столбцы  
 Это лучший способ включения небольшого количества ключевых или включенных столбцов в определение отфильтрованного индекса и включения только столбцов, необходимых для оптимизатора запросов при выборе отфильтрованного индекса для плана выполнения запроса. Оптимизатор запросов может выбрать отфильтрованный индекс независимо от того, перекрывает он запрос или нет. Однако оптимизатор запросов с большей вероятностью выберет отфильтрованный индекс, если он перекрывает запрос.  
  
 В некоторых случаях отфильтрованный индекс перекрывает запрос, не включая в определение отфильтрованного индекса в качестве ключевых или включенных столбцов столбцы из выражения отфильтрованного индекса. Следующие правила содержат описание того, должен ли быть столбец в выражении отфильтрованного индекса ключевым или включенным столбцом в определении отфильтрованного индекса. В примерах используется ранее созданный отфильтрованный индекс `FIBillOfMaterialsWithEndDate` .  
  
 Столбец в выражении отфильтрованного индекса не обязательно должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если выражение отфильтрованного индекса эквивалентно предикату запроса, а запрос не возвращает столбец с результатами запроса в выражение отфильтрованного индекса. Например, значение `FIBillOfMaterialsWithEndDate` охватывает следующий запрос, поскольку предикат запроса эквивалентен критерию фильтра, а возврат `EndDate` с результатами запроса не происходит. `FIBillOfMaterialsWithEndDate` не требуется `EndDate` в качестве ключа или включенного столбца в определении отфильтрованного индекса.  
  
```  
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 Столбец в выражении отфильтрованного индекса должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если предикат запроса использует в сравнении столбец, который не эквивалентен выражению отфильтрованного индекса. Например, отфильтрованный индекс `FIBillOfMaterialsWithEndDate` допустим для следующего запроса, поскольку этот запрос выбирает подмножество строк из отфильтрованного индекса. Однако он не перекрывает следующий запрос, поскольку столбец `EndDate` используется в сравнении `EndDate > '20040101'`, не эквивалентном выражению отфильтрованного индекса. Обработчик запросов не может выполнить запрос без поиска значений `EndDate`. Поэтому в определении отфильтрованного индекса `EndDate` должен быть ключевым или включенным столбцом.  
  
```  
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 Столбец в выражении отфильтрованного индекса должен быть ключевым или включенным столбцом в определении отфильтрованного индекса, если этот столбец содержится в результирующем наборе запроса. Например, отфильтрованный индекс `FIBillOfMaterialsWithEndDate` не перекрывает следующий запрос, поскольку тот возвращает столбец `EndDate` в результате запроса. Поэтому в определении отфильтрованного индекса `EndDate` должен быть ключевым или включенным столбцом.  
  
```  
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 Ключ кластеризованного индекса таблицы необязательно должен быть ключевым или включенным столбцом в определении отфильтрованного индекса. Ключ кластеризованного индекса автоматически включается во все некластеризованные индексы, в том числе отфильтрованные индексы.  
  
#### Операторы преобразования данных в предикате фильтра  
 Если оператор сравнения определен в выражении отфильтрованного индекса результатов отфильтрованного индекса в неявном или явном преобразовании данных, произойдет ошибка, если преобразование выполняется в левой части оператора сравнения. Решением является применение выражения отфильтрованного индекса с оператором преобразования данных (CAST или CONVERT) в правой части оператора сравнения.  
  
 В следующем примере создается таблица с различными типами данных.  
  
```  
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
  
```  
  
 В следующем определении отфильтрованного индекса столбец `b` неявно преобразуется в тип данных integer для сравнения с константой 1. Это вызывает сообщение об ошибке 10611, поскольку преобразование выполняется в левой части оператора в отфильтрованном предикате.  
  
```  
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 Решением является преобразование константы в правой части к типу столбца `b`, как показано в следующем примере.  
  
```  
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 Перемещение преобразования данных из левой части оператора сравнения в правую может изменить значение преобразования. В приведенном выше примере при добавлении оператора CONVERT в правую часть сравнение изменяется со сравнения целочисленного типа на сравнение типа **varbinary** .  
  
  
##  <a name="Additional_Reading"></a> Дополнительные материалы  
 [Повышение производительности с помощью индексированных представлений SQL Server 2008](http://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)  
  
 [Секционированные таблицы и индексы](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  