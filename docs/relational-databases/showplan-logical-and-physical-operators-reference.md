---
title: Справочник по логическим и физическим операторам Showplan
ms.custom: seo-dt-2019
ms.date: 10/12/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
- sql13.swb.showplan.foreignkeyreferencescheck
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: a3fd29114074ea0e83e04b7c434264d1666efb59
ms.sourcegitcommit: 8515bb2021cfbc7791318527b8554654203db4ad
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/08/2020
ms.locfileid: "86091561"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Справочник по логическим и физическим операторам Showplan
[!INCLUDE [SQL Server Azure SQL Database](../includes/applies-to-version/sql-asdb.md)]
  Операторы описывают, как [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] выполняет запрос или инструкцию языка DML. Оптимизатор запросов использует операторы для построения плана запроса, чтобы создать результат, заданный в запросе, или произвести операцию, указанную в инструкции DML. План запроса — это дерево физических операторов. Можно просмотреть план запроса с помощью инструкций SET SHOWPLAN, параметров графического плана выполнения в среде [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]и классов событий SQL Server Profiler Showplan.  
  
 Операторы классифицируются как логические и физические.  
  
 **Логические операторы**  
 Логические операторы описывают операции реляционной алгебры, используемые для обработки инструкции. Другими словами, логические операторы описывают на концептуальном уровне, какие действия следует совершить.  
  
 **Физические операторы**  
 Физические операторы реализуют действия, описанные логическими операторами. Каждый физический оператор является объектом или процедурой, выполняющей операцию. Например, некоторые физические операторы обращаются к столбцам и строкам таблицы, индекса или представления. Другие физические операторы выполняют другие операции, такие как вычисления, статистическая обработка, проверка целостности данных или соединения. Физическим операторам соответствует их стоимость.  
  
 Физические операторы производят инициализацию, собирают данные и закрываются. Если формулировать более конкретно, физический оператор может ответить на вызов трех следующих методов.  
  
-   **Init()** : метод **Init()** заставляет физический оператор инициализировать себя и подготовить все необходимые структуры данных. Физический оператор может получать много вызовов **Init()** , хотя обычно получает лишь один.  
  
-   **GetNext()** : метод **GetNext()** заставляет физический оператор получить первую или последующую строку данных. Физический оператор может получить много вызовов **GetNext()** или не получить ни одного.  
  
-   **Close()** : при вызове метода **Close()** физический оператор выполняет некоторые действия по очистке и закрывается. Физический оператор получает только один вызов **Close()** .  
  
Метод **GetNext()** возвращает одну строку данных, а число его вызовов отображается значением **ActualRows** в выводе инструкции Showplan, который формируется с использованием `SET STATISTICS PROFILE ON` или `SET STATISTICS XML ON`. Дополнительные сведения об этих параметрах SET см. в разделах [SET STATISTICS PROFILE (Transact-SQL)](../t-sql/statements/set-statistics-profile-transact-sql.md) и [SET STATISTICS XML (Transact-SQL)](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
Счетчики **ActualRebinds** и **ActualRewinds**, которые появляются в выводе инструкции Showplan, указывают на число вызовов метода **Init()** . Если оператор не находится внутри вложенного цикла соединения, **ActualRebinds** равняется одному, а **ActualRewinds** нулю. Если оператор находится внутри цикла соединения, сумма числа повторных привязок и сбросов на начало должна равняться количеству строк, обработанных снаружи цикла. Повторная привязка значит, что изменился один и более связанный параметр соединения, и внутреннюю часть нужно пересчитать. Сброс на начало значит, что не изменился ни один из связанных параметров и можно вновь использовать прежний внутренний результирующий набор.  
  
Счетчики**ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, который произведен с использованием инструкции SET STATISTICS XML ON. Они заполнены только для операторов **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**и **Table-valued Function** . Счетчики**ActualRebinds** и **ActualRewinds** могут быть заполнены также для операторов **Assert** и **Filter** , когда атрибут **StartupExpression** установлен в TRUE.  
  
Когда счетчики **ActualRebinds** и **ActualRewinds** присутствуют в выводе инструкции Showplan в формате XML, их значения сравнимы со значениями **EstimateRebinds** и **EstimateRewinds**. Когда они отсутствуют, оценочное число строк (**EstimateRows**) сравнимо с действительным числом строк (**ActualRows**). Обратите внимание, что действительный графический вывод Showplan отображает нули для действительных повторных привязок и сбросов на начало, когда те отсутствуют.  
  
Связанный счетчик **ActualEndOfScans**доступен только в том случае, когда вывод инструкции Showplan производится с помощью инструкции SET STATISTICS XML ON. Всякий раз, когда физический оператор достигает конца потока данных, этот счетчик увеличивается на единицу. Физический оператор может достигать конца своего потока данных ни одного, один или несколько раз. Как и в случае с повторными привязками и сбросами на начало, число окончаний просмотров может превышать единицу только в том случае, если оператор находится внутри цикла соединения. Количество окончаний просмотров должно быть меньше или равно сумме количеств повторных привязок и сбросов на начало.  
  
## <a name="mapping-physical-and-logical-operators"></a>Сопоставление физических и логических операторов  
 Оптимизатор запросов создает план запроса в виде дерева логических операторов. После этого оптимизатор запросов выбирает наиболее эффективный физический оператор для каждого логического. Оптимизатор запросов использует подход, основанный на стоимости, чтобы определить, с помощью какого физического оператора будет реализован логический.  
  
 Обычно логическую операцию можно реализовать с помощью нескольких физических операторов. Однако в редких случаях физический оператор может реализовывать несколько логических операций.  
  
## <a name="operator-descriptions"></a>Описание оператора  
 Этот раздел содержит описания логических и физических операторов.  

 > [!TIP]
 > Каждый раз, когда значок графического плана выполнения имеет желтый круг с двумя стрелками справа налево, это означает, что оператор выполняется параллельно. Дополнительные сведения о параллелизме см. в статье [Руководство по архитектуре потоков и задач](../relational-databases/thread-and-task-architecture-guide.md#sql-server-task-scheduling).
  
|Значок графического плана выполнения|Оператор Showplan|Описание|  
|-----------------------------------|-----------------------|-----------------|  
|![Значок оператора Adaptive Join](../relational-databases/media/AdaptiveJoin.gif "Значок оператора Adaptive Join")|**Adaptive Join**|Оператор **Adaptive Join** позволяет отложить выбор метода хэш-соединения или соединения вложенными циклами до завершения сканирования первых входных данных. Оператор **Adaptive Join** является физическим. Дополнительные сведения см. в разделе [Основные сведения об адаптивных соединениях](../relational-databases/performance/joins.md#adaptive). | 
|None|**Aggregate**|Оператор **Aggregate** вычисляет выражения с функциями MIN, MAX, SUM, COUNT или AVG. Оператор **Aggregate** может быть логическим или физическим.| 
|![Значок оператора Arithmetic Expression](../relational-databases/media/arithmetic-expression-32x-2.gif "Значок оператора Arithmetic Expression")|**Arithmetic Expression**|Оператор **Arithmetic Expression** вычисляет новое значение на основе существующих значений в строке. **Арифметическое выражение** в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]не используется.| 
|None|**Async Concat**|Оператор **Async Concat** применяется только в удаленных запросах (распределенных запросах). Он имеет *n* дочерних узлов и один родительский узел. Обычно некоторые дочерние узлы являются удаленными компьютерами, участвующими в распределенном запросе. Оператор **Async Concat`open()` выполняет вызовы**  одновременно ко всем дочерним узлам, а затем применяет к каждому битовую карту. Для каждого бита, равного 1, оператор **Async Concat** по запросу отправляет выходные строки родительскому узлу.| 
|![Значок оператора Assert](../relational-databases/media/assert-32x.gif "Значок оператора Assert")|**Assert**|Оператор **Assert** проверяет условие. Например, этот оператор проверяет целостность ссылок или гарантирует, что скалярный вложенный запрос возвращает одну строку. Для каждой входной строки оператор **Assert** вычисляет выражение в столбце **Аргумент** плана выполнения. Если значением этого выражения является NULL, строка передается через оператор **Assert** и выполнение запроса продолжается. При значении этого выражения, отличном от NULL, будет выдана соответствующая ошибка. **Assert** является физическим оператором.| 
|![Значок элемента Assign Language](../relational-databases/media/assign-32.gif "Значок элемента Assign Language")|**Assign**|Оператор **Assign** присваивает переменной значение выражения или константы. **Assign** является элементом языка.| 
|![Значок оператора Bitmap](../relational-databases/media/bitmap-32x.gif "Значок оператора Bitmap")|**Bitmap Create**|Оператор **Bitmap Create** появляется на выходе инструкции Showplan, в которой строятся битовые маски. **Bitmap Create** является логическим оператором.| 
|![Значок оператора Bitmap](../relational-databases/media/bitmap-32x.gif "Значок оператора Bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] использует оператор **Bitmap** для реализации фильтрации по битовым картам в планах параллельных запросов. Фильтрация по битовым маскам повышает скорость выполнения запросов, исключая строки, которые не могут производить соединенные записи, до передачи строк другим операторам, например оператору **Parallelism** . Фильтр по битовым картам использует компактное представление набора значений из таблицы, находящейся в одной части дерева операторов, для фильтрации строк из другой таблицы, находящейся в другой части дерева. Если сразу удалять ненужные строки в запросе, последующие операторы работают с меньшим количеством строк, тем самым повышая общую производительность. Оптимизатор определяет, достаточно ли избирательна битовая маска, чтобы быть полезной, и в каких операторах применить фильтр. **Bitmap** является физическим оператором.| 
|![Значок оператора Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")|**Bookmark Lookup**|Оператор **Bookmark Lookup** производит поиск соответствующей строки в таблице или кластеризованном индексе по закладке (идентификатору строки или ключу кластеризации). Столбец **Argument** содержит метку закладки, предназначенную для поиска строки в данной таблице или кластеризованном индексе. Столбец **Argument** содержит также имя таблицы или кластеризованного индекса, в которых производится поиск. Если в столбце **Argument** присутствует предложение WITH PREFETCH, обработчик запросов определяет, что оптимальным решением при поиске закладки в таблице или кластеризованном индексе будет применение асинхронной упреждающей выборки (упреждающего чтения).<br /><br /> Начиная с [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)]**Bookmark Lookup** не используется. Вместо этого функцию поиска закладок обеспечивают операторы **Key Lookup** и **RID Lookup**.| 
|None|**Branch Repartition**|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора **Parallelism** внутри отдельной области называются **Branch Repartition**. Итератор оператора **Parallelism** на границе двух таких областей называется **Segment Repartition**. **Branch Repartition** и **Segment Repartition** являются логическими операторами.| 
|None|**Broadcast**|У**Broadcast** один дочерний и *n* родительских узлов. **Broadcast** рассылает входные строки нескольким получателям по требованию. Каждый пользователь получает полный набор строк. Например, если все получатели являются элементами хэш-соединения, то будет создано *n* копий хэш-таблиц.| 
|![Значок оператора Build Hash](../relational-databases/media/build-hash.gif "Значок оператора Build Hash")|**Создание хэша**|Указывает сборку хэш-таблицы пакета для индекса columnstore, оптимизированного для памяти xVelocity.| 
|None|**Cache**|Оператор**Cache** является специальной версией оператора **Spool** . Он сохраняет только одну строку данных. **Cache** является логическим оператором. Оператор**Cache** не используется в [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|![Значок оператора Clustered Index Delete](../relational-databases/media/clustered-index-delete-32x.gif "Значок оператора Clustered Index Delete")|**Clustered Index Delete**|Оператор **Clustered Index Delete** удаляет строки из кластеризованного индекса, заданного в столбце Argument плана выполнения запроса. При наличии в столбце Argument предиката WHERE:() удаляются только строки, удовлетворяющие условиям предиката.**Clustered Index Delete** является физическим оператором.| 
|![Значок оператора Clustered Index Insert](../relational-databases/media/clustered-index-insert-32x.gif "Значок оператора Clustered Index Insert")|**Clustered Index Insert**|Оператор **Clustered Index Delete** инструкции Showplan вставляет строки со своего входа в кластеризованный индекс, указанный в столбце Argument. В столбце Argument также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. Если оператор **Clustered Index Insert** не имеет потомков для вставки значений, то вставленная строка берется из самого оператора **Insert** .**Clustered Index Insert** является физическим оператором.| 
|![Оператор Clustered Index Merge](../relational-databases/media/clustered-index-merge-32x.gif "Оператор Clustered Index Merge")|**Clustered Index Merge**|Оператор **Clustered Index Merge** применяет поток данных слияния к кластеризованному индексу. Оператор удаляет, обновляет или вставляет строки из кластеризованного индекса, заданного в столбце оператора **Аргумент** . Фактически выполненная операция зависит от значения столбца **ACTION** во время выполнения, указанного в столбце **Argument** оператора. **Clustered Index Merge** является физическим.| 
|![Значок оператора Clustered Index Scan](../relational-databases/media/clustered-index-scan-32x.gif "Значок оператора Clustered Index Scan")|**Clustered Index Scan**|Оператор **Clustered Index Scan** сканирует кластеризованный индекс, заданный в столбце Argument плана выполнения запроса. При наличии необязательного предиката WHERE:() возвращаются только строки, удовлетворяющие предикату. Если столбец Argument содержит предложение ORDERED, обработчик запросов требует, чтобы выходные данные строк были возвращены в порядке, в соответствии с которым они были отсортированы в кластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск в индексе оптимальным способом, без обязательной сортировки выходных данных. **Clustered Index Scan** является логическим и физическим оператором.| 
|![Значок оператора Clustered Index Seek](../relational-databases/media/clustered-index-seek-32x.gif "Значок оператора Clustered Index Seek")|**Clustered Index Seek**|Оператор **Clustered Index Seek** использует поисковые возможности индексов для получения строк из кластеризованного индекса. Столбец **Argument** содержит имя используемого кластеризованного индекса и предикат SEEK:(). Подсистема хранилища использует этот индекс для обработки только тех строк, которые удовлетворяют данному предикату SEEK:(). Также может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:(), но это не является обязательным и не использует индексы для завершения процесса.<br /><br /> Если столбец **Аргумент** содержит предложение ORDERED, то обработчик запросов определил, что строки необходимо возвращать в том порядке, в котором их отсортировал кластеризованный индекс. Если предложение ORDERED отсутствует, подсистема хранилища выполняет поиск индекса оптимальным способом, без обязательной сортировки выходных данных. Сохранять порядок выходных данных является менее эффективным, чем формировать несортированные выходные данные. При указании ключевого слова LOOKUP выполняется поиск закладок. В [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] и более поздних версиях оператор **Key Lookup** обеспечивает функцию поиска закладок. **Clustered Index Seek** — это логический и физический оператор.| 
|![Значок оператора Clustered Index Update](../relational-databases/media/clustered-index-update-32x.gif "Значок оператора Clustered Index Update")|**Clustered Index Update**|Оператор **Clustered Index Scan** обновляет входные строки кластеризованного индекса, указанные в столбце **Argument** . При наличии в столбце предиката WHERE:() обновляются только строки, удовлетворяющие условиям предиката. При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. При наличии предиката DEFINE:() перечисляются значения, определенные данным оператором. Ссылки на эти значения могут присутствовать в предложении SET или в любом месте внутри данного оператора либо внутри данного запроса. **Clustered Index Update** является логическим и физическим оператором.| 
|![Значок оператора Collapse](../relational-databases/media/collapse-32x.gif "Значок оператора Collapse")|**Свернуть**|Оператор **Collapse** оптимизирует процедуру обновления. При выполнении она может быть разбита (оператором **Split** ) на операции удаления и вставки. Столбец **Argument** содержит предложение GROUP BY:(), указывающее список ключевых столбцов. Если обработчик запросов встречает смежные строки, удаляющие и вставляющие одни и те же значения ключей, он заменяет эти отдельные операции на одну, более эффективную операцию обновления. **Collapse** является логическим и физическим оператором.| 
|![Просмотр индекса columnstore](../relational-databases/media/columnstoreindexscan.gif "Просмотр индекса columnstore")|**Просмотр индекса columnstore**|Оператор **Columnstore Index Scan** просматривает индекс columnstore, заданный в столбце **Argument** плана выполнения запроса.| 
|![Значок оператора Compute Scalar](../relational-databases/media/compute-scalar-32x.gif "Значок оператора Compute Scalar")|**Compute Scalar**|Оператор **Compute Scalar** вычисляет выражение и выдает вычисляемую скалярную величину. Затем эту величину можно вернуть пользователю или сослаться на нее в каком-либо запросе, а также выполнить эти действия одновременно. Примерами одновременного использования этих возможностей являются предикаты фильтра или соединения. **Compute Scalar** — это логический и физический оператор.<br /><br /> Операторы**Compute Scalar** в инструкциях Showplan, сформированных с помощью XML SET STATISTICS, могут не содержать элемент **RunTimeInformation** . (В графических инструкциях Showplan **Фактическое число строк**, **Фактическое число повторных привязок**и **Фактическое число сбросов на начало** могут отсутствовать в окне **Свойства** , если в среде **выбран параметр** Включить действительный план выполнения [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].) В данном случае это означает, что хотя эти операторы были использованы в скомпилированном плане запроса, их работа выполнялась другими операторами в исполняемом плане запроса. Кроме того, обратите внимание, что число запусков на выходе Showplan, сформированных SET STATISTICS PROFILE, равно сумме повторных привязок и сбросов на начало в инструкциях Showplan, сформированных XML SET STATISTICS.| 
|![Значок оператора Concatenation](../relational-databases/media/concatenation-32x.gif "Значок оператора Concatenation")|**Concatenation**|Оператор **Concatenation** просматривает несколько входов, возвращая каждую просмотренную строку. Оператор**Concatenation** обычно используется для реализации конструкции [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. Физический оператор **Concatenation** имеет два или более входов и один выход. Он копирует строки из первого входного потока в выходной поток и повторяет эту операцию для каждого дополнительного входного потока. **Concatenation** является как логическим, так и физическим оператором.| 
|![Значок оператора Constant Scan](../relational-databases/media/constant-scan-32x.gif "Значок оператора Constant Scan")|**Constant Scan**|Оператор **Constant Scan** вводит в запрос одну или несколько константных строк. Оператор **Compute Scalar** часто используется после выполнения оператора **Constant Scan** . Он добавляет столбцы в строки, полученные в результате выполнения оператора **Constant Scan** .| 
|![Значок элемента языка Convert (ядро СУБД)](../relational-databases/media/convert-32x.gif "Значок элемента языка Convert (ядро СУБД)")|**Преобразовать**|Оператор **Convert** автоматически преобразует скалярные данные из одного типа в другой. **Convert** является элементом языка.| 
|None|**Cross Join**|Оператор **Cross Join** соединяет каждую строку из первого (верхнего) входного параметра с каждой строкой второго (нижнего) входного параметра. **Cross Join** является логическим оператором.| 
|None|**Курсор**|Логический и физический операторы **Cursor** предназначены для описания того, каким образом выполняются операции запроса или обновления с участием курсора. Физические операторы описывают алгоритм физической реализации обработки курсора, например использование курсора, управляемого набором ключей. Каждый шаг выполнения курсора соответствует физическому оператору. Логические операторы описывают свойства курсора, например доступность курсора только для чтения.<br /><br /> Логические операторы включают в себя Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary и Synchronous.<br /><br /> Физические операторы включают в себя Dynamic, Fetch Query, Keyset, Population Query, Refresh Query и Snapshot.| 
|![Значок оператора курсора Cursor Catchall](../relational-databases/media/cursor-catch-all.gif "Значок оператора курсора Cursor Catchall")|**catchall**|Общий значок отображается в тех случаях, когда с помощью логики, управляющей графическими планами визуализации, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существует три общих значка захвата: синий (итераторы), оранжевый (курсоры) и зеленый (элементы языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Значок элемента языка Declare](../relational-databases/media/declare-32x.gif "Значок элемента языка Declare")|**Declare**|Оператор **Declare** выделяет локальную переменную в плане запроса. **Declare** является элементом языка.| 
|![Значок оператора Delete (ядро СУБД)](../relational-databases/media/delete-32x.gif "Значок оператора Delete (ядро СУБД)")|**Удаление**|Оператор **Delete** удаляет те строки из объекта, которые удовлетворяют необязательному предикату в столбце **Argument** .| 
|![Значок оператора Delete Scan](../relational-databases/media/delete-scan-32x.gif "Значок оператора Delete Scan")|**Deleted Scan**|Оператор **Deleted Scan** просматривает удаленную таблицу в триггере.| 
|None|**Distinct Sort**|Логический оператор **Distinct Sort** просматривает входные данные, удаляя дубликаты и сортируя данные по столбцам, заданным в предикате DISTINCT ORDER BY:() столбца **Argument** . **Distinct Sort** является логическим оператором.| 
|None|**Distinct**|Оператор **Distinct** удаляет дубликаты из набора строк или из коллекции значений. **Distinct** является логическим оператором.| 
|![Значок оператора параллелизма Distribute Streams](../relational-databases/media/parallelism-distribute-stream.gif "Значок оператора параллелизма Distribute Streams")|**Distribute Streams**|Оператор **Distribute Streams** используется только в параллельных планах запросов. Оператор **Distribute Streams** преобразует один входящий поток записей в несколько выходящих потоков. Формат и содержимое записей не меняются. Каждая запись из входящего потока направляется в один из выходящих потоков. Данный оператор автоматически сохраняет в выходящих потоках относительный порядок входящих записей. Чтобы определить выходящий поток, в который попадет запись из входящего потока, обычно используется хэширование.<br /><br /> Если выход является секционированным, столбец **Argument** содержит предикат PARTITION COLUMNS:() и столбцы секционирования. Оператор**Distribute Streams** является логическим оператором.| 
|![Значок оператора Dynamic Cursor](../relational-databases/media/dynamic-32x.gif "Значок оператора Dynamic Cursor")|**Динамический**|В операторе **Dynamic** используется курсор, который отслеживает изменения, внесенные другими.| 
|![Значок оператора Fetch Query Cursor](../relational-databases/media/fetch-query-32x.gif "Значок оператора Fetch Query Cursor")|**Fetch Query**|Оператор **Fetch Query** извлекает строки, если выборка выполняется в курсоре.| 
|![Значок оператора Filter (ядро СУБД)](../relational-databases/media/filter-32x.gif "Значок оператора Filter (ядро СУБД)")|**Filter**|Оператор **Filter** просматривает входные данные и возвращает только те строки, которые удовлетворяют критерию фильтрации (предикату), представленному в столбце **Argument** .| 
|None|**Flow Distinct**|Логический оператор **Flow Distinct** просматривает входные данные и удаляет дубликаты. Оператор **Distinct** принимает на входе все данные, чтобы выдать выходные данные, тогда как оператор **FlowDistinct** возвращает строки по мере поступления (если строка не является дубликатом, так как в этом случае она не возвращается).| 
|![Значок оператора Проверка ссылок на внешние ключи](../relational-databases/media/fk-references-32x.gif "Значок оператора Проверка ссылок на внешние ключи")|**Проверка ссылок на внешние ключи**|Оператор **Проверка ссылок на внешние ключи** выполняет проверку целостности ссылок на месте путем сравнения измененной строки со строками из ссылающихся таблиц, чтобы убедиться, что изменение не нарушит целостность данных. Оператор **Проверка ссылок на внешние ключи** используется в том случае, если существует более 253 ссылок на один и тот же первичный или уникальный ключ. **Проверка ссылок на внешние ключи** является логическим и физическим оператором.| 
|None|**Full Outer Join**|Логический оператор **Full Outer Join** возвращает каждую строку, удовлетворяющую предикату соединения из первого (верхнего) входа и соединенную с каждой строкой из второго (нижнего) входа. Он также возвращает строки из:<br /><br /> первых входных данных, не имеющих соответствий во вторых входных данных;<br /><br /> вторых входных данных, не имеющих соответствий в первых входных данных.<br /><br /> Вход, не содержащий совпадающих значений, возвращается как значение NULL. **Full Outer Join** является логическим оператором.| 
|![Значок оператора параллелизма Gather Streams](../relational-databases/media/parallelism-32x.gif "Значок оператора параллелизма Gather Streams")|**Gather Streams**|Оператор **Gather Streams** используется только в планах параллельных запросов. Оператор **Gather Streams** считывает несколько входных потоков и создает один выходной поток записей, комбинируя все входные потоки. Формат и содержимое записей не меняются. Если этот оператор сохраняет порядок, все входные потоки должны быть упорядочены. В случае упорядоченного выхода в столбце **Argument** содержится предикат ORDER BY:(), а имена столбцов упорядочены. **Gather Streams** — логический оператор.| 
|![Значок оператора Hash Match](../relational-databases/media/hash-match-32x.gif "Значок оператора Hash Match")|**Hash Match**|Оператор **Hash Match** строит хэш-таблицу при помощи вычисления хэш-значения для каждой строки из своих входных данных. Предикат A HASH:() со списком столбцов, использованных для создания хэш-значения, отображается в столбце **Argument** . Затем для каждой тестовой строки (если возможно) он вычисляет хэш-значение (с использованием той же хэш-функции) и осуществляет поиск совпадений по хэш-таблице. При наличии остаточного предиката (определенного посредством предиката RESIDUAL:() в столбце **Argument** ) строки должны удовлетворять также и этому предикату, чтобы рассматриваться в качестве совпадающих. Поведение зависит от выполняемой логической операции.<br /><br /> Для любых соединений используйте первые (верхние) входные данные для формирования хэш-таблицы, а вторые (нижние) входные данные — для выполнения пробы хэш-таблицы. Выходные данные совпадают (или не совпадают) в зависимости от типа соединения. Если несколько операций соединения используют один и тот же столбец соединения, эти операции группируются в хэш-группу.<br /><br /> Для операторов Distinct и Aggregate используйте входные данные для формирования хэш-таблицы (удаляя повторяющиеся элементы и вычисляя любые статистические выражения). Когда хэш-таблица будет построена, просмотрите таблицу и выведите все записи.<br /><br /> Для оператора Union используйте первые входные данные для формирования хэш-таблицы (удаляя повторяющиеся элементы). Используйте вторую входную строку (в которой не должно быть дубликатов) с целью тестирования хэш-таблицы, возвращения всех строк, не имеющих совпадений, затем просмотрите хэш-таблицу для возвращения всех записей.<br />**Hash Match** является физическим оператором. Дополнительные сведения см. в разделе [Основные сведения о хэш-соединениях](../relational-databases/performance/joins.md#hash).| 
|![Значок элемента языка If](../relational-databases/media/if-32x.gif "Значок элемента языка If")|**Если оператор**|Оператор **If** выполняет условную обработку в зависимости от значения выражения. **If** является элементом языка.| 
|None|**Inner Join**|Логический оператор **Inner Join** возвращает каждую строку, которая удовлетворяет соединению первого (верхнего) входа со вторым (нижним).| 
|![Значок оператора Insert (ядро СУБД)](../relational-databases/media/insert-32x.gif "Значок оператора Insert (ядро СУБД)")|**Insert**|Логический оператор **Insert** вставляет строки из входного потока в объект, заданный в столбце **Argument** . Соответствующим физическим оператором является **Table Insert**, **Index Insert**или **Clustered Index Insert** .| 
|![Значок оператора Inserted Scan](../relational-databases/media/inserted-scan-32x.gif "Значок оператора Inserted Scan")|**Inserted Scan**|Оператор **Inserted Scan** просматривает таблицу **inserted** . **Inserted Scan** является логическим и физическим оператором.| 
|![Значок элемента языка Intrinsic](../relational-databases/media/intrinsic-32x.gif "Значок элемента языка Intrinsic")|**Intrinsic**|Оператор **Intrinsic** вызывает внутреннюю функцию [!INCLUDE[tsql](../includes/tsql-md.md)] . **Intrinsic** является элементом языка.| 
|![Значок оператора Iterator Catchall](../relational-databases/media/iterator-catch-all.gif "Значок оператора Iterator Catchall")|**Итератор**|Общий значок **Iterator** отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Значок оператора Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Значок оператора Bookmark Lookup")|**Key Lookup**|Оператор **Key Lookup** выполняет поиск закладок в таблице с кластеризованным индексом. Столбец **Аргумент** содержит имя кластеризованного индекса и ключ кластеризации, который используется для поиска строки в кластеризованном индексе. Оператор**Key Lookup** всегда сопровождается оператором **Nested Loops** . Если в столбце **Аргумент** присутствует предложение WITH PREFETCH, обработчик запросов определяет, что оптимальным решением при поиске закладки в таблице или кластеризованном индексе будет применение асинхронной упреждающей выборки (упреждающего чтения).<br /><br /> Использование оператора **Key Lookup** в плане запроса указывает, что запрос может выиграть от настройки производительности. Например, производительность запроса можно повысить, добавив покрывающий индекс.| 
|![Значок оператора курсора Keyset](../relational-databases/media/keyset-32x.gif "Значок оператора курсора Keyset")|**Keyset**|Оператор **Keyset** использует курсор, для которого видимыми являются обновления, но не вставки, выполненные другими.| 
|![Значок Language Element Catchall](../relational-databases/media/language-construct-catch-all.gif "Значок Language Element Catchall")|**Элемент Language**|Общий значок **Language Element** отображается в тех случаях, когда с помощью логики, управляющей графическими планами Showplan, не удается найти подходящий значок для итератора. Значок общего захвата не обязательно указывает на ошибку. Существуют три общих значка: синий (итераторы), оранжевый (курсоры) и зеленый (конструкции языка [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|None|**Left Anti Semi Join**|Оператор **Left Anti Semi Join** возвращает каждую строку первого (верхнего) входа, для которой нет соответствующей строки во втором (нижнем) входе. Если в столбце **Argument** предикат соединения отсутствует, каждая строка будет считаться подходящей. **Left Anti Semi Join** является логическим оператором.| 
|None|**Left Outer Join**|Оператор **Left Outer Join** возвращает строки, удовлетворяющие условию соединения первого (верхнего) входа со вторым (нижним) входом. Он также возвращает строки из первого входа, не имеющие соответствия строкам во втором входе. Строки, не имеющие соответствия строкам во втором входе, возвращаются как значения NULL. Если в столбце **Argument** предикат соединения отсутствует, каждая строка будет считаться подходящей. **Left Outer Join** является логическим оператором.| 
|None|**Left Semi Join**|Оператор **Left Semi Join** возвращает каждую строку первого (верхнего) входа, для которой нет соответствующей строки во втором (нижнем) входе. Если в столбце **Argument** предикат соединения отсутствует, каждая строка будет считаться подходящей. **Left Semi Join** является логическим оператором.| 
|![Значок оператора Log Row Scan](../relational-databases/media/log-row-scan-32x.gif "Значок оператора Log Row Scan")|**Log Row Scan**|Оператор **Log Row Scan** просматривает журнал транзакций. **Log Row Scan** является логическим и физическим оператором.| 
|![Значок оператора Merge interval](../relational-databases/media/merge-interval-32x.gif "Значок оператора Merge Interval")|**Merge Interval**|Оператор **Merge Interval** проводит слияние нескольких (возможно, пересекающихся) интервалов и возвращает минимальный, непересекающийся интервал, который затем используется для поиска записей индекса. Этот оператор обычно проводит слияние интервалов (представленных в виде столбцов строки), сформированных при выполнении одного или нескольких операторов **Compute Scalar** над операторами **Constant Scan** . **Merge Interval** является логическим и физическим оператором.| 
|![Значок оператора Merge Join](../relational-databases/media/merge-join-32x.gif "Значок оператора Merge Join")|**Merge Join**|Оператор **Merge Join** выполняет внутреннее соединение, левое внешнее соединение, левое полусоединение, левое антиполусоединение, правое внешнее соединение, правое полусоединение, правое антиполусоединение, а также логические операции соединения.<br /><br /> В столбце **Argument** оператор **Merge Join** содержит предикат MERGE:(), если операция устанавливает соединение "один ко многим", или предикат MANY-TO-MANY MERGE:(), если операция устанавливает соединение "многие ко многим". Столбец **Argument** содержит также список столбцов, используемых для выполнения операции с разделителями-запятыми. Оператор **Merge Join** требует наличия двух входных значений, отсортированных в соответствующих столбцах, что можно сделать с помощью вставки явных операций сортировки в план запроса. Соединение слиянием особенно эффективно в случаях, когда явной сортировки не требуется, например, когда в базе данных имеется подходящий индекс сбалансированного дерева или когда порядок сортировки может использоваться для нескольких операций вроде соединения слиянием или группирования со сведением. **Merge Join** является физическим. Дополнительные сведения см. в разделе [Основные сведения о соединениях слиянием](../relational-databases/performance/joins.md#merge).| 
|![Значок оператора Nested Loops](../relational-databases/media/nested-loops-32x.gif "Значок оператора Nested Loops")|**Nested Loops**|Оператор **Nested Loops** выполняет логические операции внутреннего соединения, левого внешнего соединения, левого полусоединения и антилевого полусоединения. При соединениях вложенными циклами выполняется поиск во внутренней таблице каждой строки внешней таблицы, обычно с помощью индекса. На основании предполагаемых затрат обработчик запросов определяет, сортировать ли внешние входные данные, чтобы улучшить сосредоточенность поиска по индексу во внутренней таблице. Возвращается результат выполнения логической операции над любыми строками, удовлетворяющими необязательному предикату в столбце **Argument** . Если для атрибута OPTIMIZED задано значение **True**, это означает, что используются оптимизированные соединения вложенными циклами (или пакетная сортировка). **Nested Loops** является физическим оператором. Дополнительные сведения см. в разделе [Основные сведения о соединении вложенных циклов](../relational-databases/performance/joins.md#nested_loops).| 
|![Значок оператора Nonclustered Index Delete](../relational-databases/media/nonclust-index-delete-32x.gif "Значок оператора Nonclustered Index Delete")|**Nonclustered Index Delete**|Оператор **Nonclustered Index Delete** удаляет входные строки из некластеризованного индекса, указанного в столбце **Argument** . **Nonclustered Index Delete** является физическим оператором.| 
|![Значок оператора Nonclustered Index Insert](../relational-databases/media/nonclust-index-insert-32x.gif "Значок оператора Nonclustered Index Insert")|**Index Insert**|Оператор **Index Insert** вставляет строки из входного потока в некластеризованный индекс, заданный в столбце **Argument** . В столбце **Argument** также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. **Index Insert** является физическим оператором.| 
|![Значок оператора Nonclustered Index Scan](../relational-databases/media/nonclustered-index-scan-32x.gif "Значок оператора Nonclustered Index Scan")|**Index Scan**|Оператор **Index Scan** получает все записи некластеризованного индекса, указанного в столбце **Argument** . Если в столбце **Argument** присутствует необязательный предикат WHERE:(), то возвращаются только те строки, которые удовлетворяют условию, указанному в этом предикате. **Index Scan** является логическим и физическим оператором.| 
|![Значок оператора Nonclustered Index Seek](../relational-databases/media/index-seek-32x.gif "Значок оператора Nonclustered Index Seek")|**Index Seek**|Оператор **Index Seek** использует возможности поиска по индексам для получения строк из некластеризованного индекса. Столбец **Argument** содержит имя используемого некластеризованного индекса. Он также содержит предикат SEEK:(). Подсистема хранилища использует этот индекс для обработки только строк, удовлетворяющих предикату SEEK:(). При необходимости может включаться предикат WHERE:(), в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату SEEK:() (при этом не используются индексы). Если столбец **Argument** содержит предложение ORDERED, обработчик запросов определяет, что строки должны возвращаться в том порядке, в котором они отсортированы в некластеризованном индексе. Если предложение ORDERED отсутствует, подсистема хранилища производит поиск индекса оптимальным способом (что не гарантирует сортировки выходных данных). Сохранение сортировки в выводе может оказаться менее эффективным, чем возврат неупорядоченного вывода. **Index Seek** является логическим и физическим оператором.| 
|![Значок оператора Nonclustered Index Spool](../relational-databases/media/index-spool-32x.gif "Значок оператора Nonclustered Index Spool")|**Index Spool**|Физический оператор **Index Spool** содержит предикат SEEK:() в столбце **Argument** . Оператор **Index Spool** сканирует входные строки, помещая каждую строку в скрытый файл буфера (хранимый в базе данных **tempdb** и существующий только в течение выполнения запроса), и создает для строк некластеризованный индекс. Это позволяет использовать поддерживаемый индексами механизм поиска для вывода только строк, отвечающих требованиям предиката SEEK:(). Если оператор сбрасывается на начало (например, оператором **Nested Loops** ), но при этом не требуется повторная привязка, то вместо повторного сканирования ввода используются буферизованные данные.| 
|![Значок оператора Nonclustered Index Update](../relational-databases/media/nonclust-index-update-32x.gif "Значок оператора Nonclustered Index Update")|**Nonclustered Index Update**|Физический оператор **Nonclustered Index Update** обновляет строки, указанные во входных параметрах, в некластеризованном индексе, заданном в столбце **Argument** . При наличии предиката SET:() данное значение устанавливается для каждого обновляемого столбца. **Nonclustered Index Update** является физическим оператором.| 
|![Значок оператора Online Index Insert](../relational-databases/media/online-index-32x.gif "Значок оператора Online Index Insert")|**Online Index Insert**|Физический оператор **Online Index Insert** указывает, что операции создания, изменения и удаления индекса выполняются в сети. То есть данные базовых таблиц по-прежнему доступны для пользователей во время операции с индексом.| 
|None|**Parallelism**|<a name="exchange"></a> Оператор **Parallelism** (или итератор обмена) выполняет логические операции потоков распространения, сбора и повторного секционирования. Столбцы **Argument** могут также содержать предикат PARTITION COLUMNS:() со списком секционируемых столбцов, разделенным запятыми. Столбцы **Argument** могут также содержать предикат ORDER BY:(), содержащий список столбцов для сохранения порядка сортировки во время секционирования. **Parallelism** является физическим оператором. Дополнительные сведения об операторе Parallelism см. в [серии публикаций в блоге Крейга Фридмана (Craig Freedman)](https://docs.microsoft.com/archive/blogs/craigfr/the-parallelism-operator-aka-exchange).<br /><br />**Примечание.** Если запрос скомпилирован как параллельный, но во время выполнения запускается как последовательный, выходные данные Showplan, сформированные SET STATISTICS XML или с помощью параметра **Включить действительный план выполнения** в [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], не будут содержать элемент **RunTimeInformation** для оператора **Parallelism**. В выходных данных инструкции SET STATISTICS PROFILE подсчет действительного числа строк и фактическое количество выполнений для оператора **Parallelism** будут равны нулю. Любое из этих условий означает, что оператор **Parallelism** использовался только при компиляции запроса, но не в рабочем плане запроса. Обратите внимание, что иногда планы параллельных запросов выполняются последовательно, если сервер выполняет большое количество параллельных запросов.| 
|![Значок оператора Parameter Table Scan](../relational-databases/media/parameter-table-scan-32x.gif "Значок оператора Parameter Table Scan")|**Parameter Table Scan**|Оператор **Parameter Table Scan** просматривает таблицу, переданную как параметр текущего запроса. Обычно он применяется для запросов INSERT из хранимой процедуры. **Parameter Table Scan** является логическим и физическим оператором.| 
|None|**Partial Aggregate**|Оператор**Partial Aggregate** используется в параллельных планах. Он применяется в статистической функции к максимальному числу входных строк, чтобы избежать записи на диск (сброса на диск). **Hash Match** — это единственный физический оператор (итератор), реализующий статистическую обработку секций. **Partial Aggregate** является логическим оператором.| 
|![Значок оператора курсора Population Query](../relational-databases/media/poulation-query-32x.gif "Значок оператора курсора Population Query")|**Population Query**|Оператор **Population Query** заполняет рабочую таблицу курсора при его открытии.| 
|![Значок оператора курсора Refresh Query](../relational-databases/media/refresh-query-32x.gif "Значок оператора курсора Refresh Query")|**Refresh Query**|Оператор **Refresh Query** выбирает текущие данные для строк из буфера выборки.| 
|![Значок оператора Remote Delete](../relational-databases/media/remote-delete-32x.gif "Значок оператора Remote Delete")|**Remote Delete**|Оператор **Remote Delete** удаляет входные строки удаленного объекта. **Remote Delete** является логическим и физическим оператором.| 
|![Оператор Showplan Remote Index Seek](../relational-databases/media/remote-index-scan-32x.gif "Оператор Showplan Remote Index Seek")|**Remote Index Scan**|Оператор **Remote Index Scan** просматривает удаленный индекс, указанный в столбце Argument. **Remote Index Scan** является логическим и физическим оператором.| 
|![Оператор Showplan Remote Index Seek](../relational-databases/media/remote-index-seek-32x.gif "Оператор Showplan Remote Index Seek")|**Remote Index Seek**|Оператор **Remote Index Seek** использует возможности поиска объекта удаленного индекса, чтобы получить строки. Столбец **Argument** содержит имя используемого удаленного индекса и предикат SEEK:(). **Remote Index Seek** является логическим физическим оператором.| 
|![Значок оператора Remote Insert](../relational-databases/media/remote-insert-32x.gif "Значок оператора Remote insert")|**Remote Insert**|Оператор **Remote Insert** вставляет входные строки в удаленный объект. **Remote Insert** является логическим и физическим оператором.| 
|![Значок оператора Remote Query](../relational-databases/media/remote-query-32x.gif "Значок оператора Remote Query")|**Remote Query**|Оператор **Remote Query** отправляет запрос удаленному источнику. Текст запроса, отправленного удаленному серверу, выводится в столбце **Argument** . **Remote Query** является логическим и физическим оператором.| 
|![Значок оператора Remote Scan](../relational-databases/media/remote-scan-32x.gif "Значок оператора Remote Scan")|**Remote Scan**|Оператор **Remote Scan** позволяет удаленно просматривать необходимые объекты. Имя удаленного объекта появляется в столбце **Argument** . **Remote Scan** является логическим и физическим оператором.| 
|![Значок оператора Remote Update](../relational-databases/media/remote-update-32x.gif "Значок оператора Remote Update")|**Remote Update**|Оператор **Remote Update** обновляет входные строки удаленного объекта. **Remote Update** является логическим и физическим оператором.| 
|![Значок оператора параллелизма Repartition Streams](../relational-databases/media/parallelism-repartition-stream.gif "Значок оператора параллелизма Repartition Streams")|**Repartition Streams**|Оператор **Repartition Streams** (или итератор обмена) собирает несколько потоков и создает несколько потоков записей. Формат и содержимое записей не меняются. Если оптимизатор запросов использует фильтр по битовым картам, то число строк в выходном потоке сокращается. Каждая запись из входного потока помещается в один выходной поток. Если оператор настроен для сохранения порядка, то все входные потоки упорядочиваются и сливаются в несколько упорядоченных выходных потоков. Если выход является секционированным, столбец **Argument** содержит предикат PARTITION COLUMNS:() и столбцы секционирования. В случае упорядоченного выхода в столбце **Argument** содержится предикат ORDER BY:() и упорядочиваемые столбцы. **Repartition Streams** — это логический оператор. Он используется только в параллельных планах запроса.| 
|![Значок элемента языка Result](../relational-databases/media/result-32x.gif "Значок элемента языка Result")|**Результат**|Оператор **Result** представляет собой данные, возвращенные в конце плана запроса. Обычно он является корневым элементом инструкции Showplan. **Result** является элементом языка.| 
|![Значок оператора RID Lookup](../relational-databases/media/rid-nonclust-locate-32x.gif "Значок оператора RID Lookup")|**RID Lookup**|Оператор**RID Lookup** осуществляет поиск закладки в куче при помощи заданного идентификатора строки. Столбец **Argument** всегда содержит метку закладки, которая применяется для поиска строки в таблице, и имя таблицы, в которой осуществляется поиск. Оператор**RID Lookup** всегда сопровождается оператором NESTED LOOP JOIN. **RID Lookup** является физическим оператором. Дополнительные сведения о поиске закладок см. в разделе[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)на веб-узле MSDN в блоге SQL Server.| 
|![Значок оператора Row Count Spool](../relational-databases/media/remote-count-spool-32x.gif "Значок оператора Row Count Spool")|**Row Count Spool**|Оператор **Row Count Spool** просматривает входные данные, подсчитывая число представленных строк и возвращая такое же количество строк, очищенных от данных. Этот оператор используется, когда необходимо проверить существование строк, а не наличие в них данных. Например, если оператор **Nested Loops** выполняет операцию левого полусоединения, а предикат соединения применяется к внутренним входным данным, оператор Row Count Spool можно разместить выше внутреннего ввода оператора **Nested Loops** . Тогда оператор **Nested Loops** может определить количество выходных строк оператора Row Count Spool (поскольку реальные данные с внутренней стороны не требуются) для определения того, нужно ли возвращать внешние строки. Оператор**Row Count Spool** — это физический оператор.| 
|None|**Right Anti Semi Join**|Оператор **Right Anti Semi Join** выводит каждую строку второго (нижнего) входного множества, для которой не существует соответствующей строки в первом (верхнем) входном множестве. Соответствующая строка определяется как строка, которая удовлетворяет предикату в столбце **Argument** (если предиката не существует, то каждая строка является строкой соответствия). **Right Anti Semi Join** является логическим оператором.| 
|None|**Right Outer Join**|Оператор **Right Outer Join** возвращает каждую строку, которая удовлетворяет соединению второго (нижнего) входа с первым (верхним). Она также возвращает все строки из второго входа, для которых нет совпадений в первом, соединяя их со значением NULL. Если в столбце **Argument** предикат соединения отсутствует, каждая строка будет считаться подходящей. **Right Outer Join** является логическим оператором.| 
|None|**Right Semi Join**|Оператор **Right Semi Join** возвращает каждую строку из второго (нижнего) потока входных данных, если имеется соответствующая строка в первом (нижнем) потоке входных данных. Если в столбце **Argument** предикат соединения отсутствует, каждая строка будет считаться подходящей. **Right Semi Join** является логическим оператором.| 
|![Значок оператора Segment](../relational-databases/media/segment-32x.gif "Значок оператора Segment")|**Segment**|**Segment** является физическим и логическим оператором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Эти столбцы отображаются в виде аргументов оператора **Segment** . Затем оператор выводит по одному сегменту за раз.| 
|![Значок оператора Sequence](../relational-databases/media/sequence-32x.gif "Значок оператора Sequence")|**Последовательность**|Оператор **Sequence** выполняет планы широкого обновления. Практически он выполняет каждый вход по очереди (сверху вниз). Каждый вход обычно является обновлением отдельного объекта. Он возвращает лишь строки, полученные из последнего (нижнего) входа. **Sequence** является логическим и физическим оператором.| 
|![Значок оператора Sequence Project](../relational-databases/media/sequence-project-32x.gif "Значок оператора Sequence Project")|**Проект последовательности**|Оператор **Sequence Project** добавляет столбцы для выполнения вычислений над упорядоченным набором. Он делит входной набор на сегменты в соответствии со значением одного или нескольких столбцов. Затем оператор выводит по одному сегменту за раз. Эти столбцы отображаются как аргументы оператора **Sequence Project** . **Sequence Project** является логическим и физическим оператором.| 
|None|**Segment Repartition**|В плане параллельных запросов иногда содержатся концептуальные области итераторов. Все итераторы в рамках такой области могут обрабатываться параллельными потоками. Сами же области должны обрабатываться последовательно. Некоторые итераторы оператора **Parallelism** внутри отдельной области называются **Branch Repartition**. Итератор оператора **Parallelism** на границе двух таких областей называется **Segment Repartition**. **Branch Repartition** и **Segment Repartition** являются логическими операторами.| 
|![Значок оператора курсора Snapshot](../relational-databases/media/snapshot-32x.gif "Значок оператора курсора Snapshot")|**Моментальный снимок**|Оператор **Snapshot** создает курсор, который не видит изменений, сделанных другими курсорами.| 
|![Значок оператора Sort](../relational-databases/media/sort-32x.gif "Значок оператора Sort")|**Sort**|Оператор **Sort** сортирует входящие строки. Столбец **Argument** содержит либо предикат DISTINCT ORDER BY:(), если в этой операции удаляются дубликаты, либо предикат ORDER BY:() с разделенным запятыми списком сортируемых столбцов. Столбцы имеют префикс со значением ASC, если они сортируются по возрастанию, или значением DESC, если сортируются по убыванию. **Sort** — это логический и физический оператор.| 
|![Значок оператора Split](../relational-databases/media/split-32x.gif "Значок оператора Split")|**Split**|Оператор **Split** используется для оптимизации процесса обновления. Он разбивает каждую операцию обновления на операции удаления и вставки. Оператор**Split** является логическим и физическим оператором.| 
|![Значок оператора Spool](../relational-databases/media/spool-32x.gif "Значок оператора Spool")|**Eager Spool**|Оператор **Eager Spool** принимает весь ввод, сохраняя каждую строку в скрытый временный объект базы данных **tempdb** . Если оператор сбрасывается на начало (например, оператором **Nested Loops** ), но при этом не требуется повторная привязка, то вместо повторного сканирования ввода используются буферизованные данные. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Eager Spool** выполняет построение своего буферного файла «жадным» способом: когда родительский оператор буфера запрашивает первую строку, оператор буферизации принимает все строки из своего входного оператора и сохраняет ее в буфер. **Eager Spool** — логический оператор.| 
|![Значок оператора Spool](../relational-databases/media/spool-32x.gif "Значок оператора Spool")|**Lazy Spool**|Логический оператор **Lazy Spool** сохраняет все строки входных данных в скрытом временном объекте, который хранится в базе данных **tempdb** . Если оператор сбрасывается на начало (например, оператором **Nested Loops** ), но при этом не требуется повторная привязка, то вместо повторного сканирования ввода используются буферизованные данные. Если требуется повторная привязка, буферизованные данные удаляются, а объект буфера перестраивается путем повторного просмотра ввода. Оператор **Lazy Spool** производит отложенное построение своего буферного файла: каждый раз, когда родительский оператор буфера запрашивает строку, оператор буферизации получает строку из своего входного оператора и сохраняет ее в буфер, а не обрабатывает все строки сразу. Lazy Spool — это логический оператор.| 
|![Значок оператора Spool](../relational-databases/media/spool-32x.gif "Значок оператора Spool")|**Spool**|Оператор **Spool** сохраняет промежуточные результаты запроса в базе данных **tempdb** .| 
|![Значок оператора Stream Aggregate](../relational-databases/media/stream-aggregate-32x.gif "Значок оператора Stream Aggregate")|**Статистическое выражение потока**|Оператор **Stream Aggregate** группирует строки в один или несколько столбцов и вычисляет одно или несколько агрегатных выражений, возвращенных запросом. Выход этого оператора может быть использован последующими операторами запроса, возвращен клиенту или то и другое. Оператору **Stream Aggregate** необходимы входные данные, упорядоченные по группируемым столбцам. Оптимизатор использует перед этим оператором оператор **Sort** , если данные не были ранее отсортированы оператором **Sort** или используется упорядоченный поиск или просмотр в индексе. В инструкции SHOWPLAN_ALL или графическом плане выполнения в среде [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]столбцы в предикате GROUP BY перечисляются в столбце **Argument** , а агрегатные выражения — в столбце **Defined Values** . **Stream Aggregate** является физическим оператором.| 
|![Значок оператора Switch](../relational-databases/media/switch-32x.gif "Значок оператора Switch")|**Параметр**|Оператор**Switch** представляет собой особый тип итератора объединения, который имеет *n* входов. Выражение связывается с каждым оператором **Switch** . В зависимости от возвращаемого значения выражения (между 0 и *n*-1) оператор **Switch** копирует соответствующий входной поток в выходной поток. В частности, оператор **Switch** применяется при реализации планов запроса, содержащих быстрые курсоры прямого направления с такими операторами, как **TOP** . **Switch** является и логическим, и физическим оператором.| 
|![Значок оператора Table Delete](../relational-databases/media/table-delete-32x.gif "Значок оператора Table Delete")|**Table Delete**|Физический оператор **Table Delete** удаляет строки из таблицы, указанной в столбце **Аргумент** плана выполнения запроса.| 
|![Значок оператора Table insert](../relational-databases/media/table-insert-32x.gif "Значок оператора Table Insert")|**Table Insert**|Оператор **Table Insert** вставляет строки из своих входных данных в таблицу, указанную в столбце **Argument** плана выполнения запроса. В столбце **Argument** также содержится предикат SET:(), который указывает значение, устанавливаемое для каждого столбца. Если оператор **Table Insert** не имеет потомков для вставки значений, то вставленная строка берется из самого оператора вставки. **Table Insert** является физическим оператором.| 
|![Оператор Table Merge](../relational-databases/media/table-merge-32x.gif "Оператор Table Merge")|**Table Merge**|Оператор **Table Merge** применяет поток данных слияния к куче. Оператор удаляет, обновляет или вставляет строки в таблицу, указанную в столбце **Argument** оператора. Тип выполненной операции зависит от значения времени выполнения столбца **ACTION** , указанного в столбце **Argument** оператора. **Table Merge** является физическим оператором.| 
|![Значок оператора Table Scan](../relational-databases/media/table-scan-32x.gif "Значок оператора Table Scan")|**Table Scan**|Оператор **Table Scan** получает строки из таблицы, указанной в столбце **Аргумент** плана выполнения запроса. Если предикат WHERE:() присутствует в столбце **Argument** , возвращаются только строки, удовлетворяющие условию, указанному в этом предикате. **Table Scan** является логическим и физическим оператором.| 
|![Значок оператора Table Spool](../relational-databases/media/table-spool-32x.gif "Значок оператора Table Spool")|**Table Spool**|Оператор **Table Spool** просматривает входную таблицу и помещает копию каждой строки в скрытую буферную таблицу, которая находится в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) и существует только в течение времени жизни запроса. Если оператор сбрасывается на начало (например, оператором **Nested Loops** ), но при этом не требуется повторная привязка, то вместо повторного сканирования ввода используются буферизованные данные. **Table Spool** является физическим оператором.| 
|![Значок оператора Table Spool](../relational-databases/media/table-spool-32x.gif "Значок оператора Table Spool")|**Window Spool**|Оператор **Window Spool** расширяет каждую строку в набор строк, представляющий связанное с ним окно. В запросе предложение OVER определяет окно в наборе результатов запроса, а оконная функция затем вычисляет значения для каждой строки в окне. **Window Spool** является логическим и физическим оператором.| 
|![Значок оператора Table Update](../relational-databases/media/table-update-32x.gif "Значок оператора Table Update")|**Table Update**|Физический оператор **Table Update** обновляет входные строки в таблице, указанной в столбце **Аргумент** плана выполнения запроса. Предикат SET:() определяет значение для каждого обновляемого столбца. Эти значения могут быть упомянуты в предложении SET или в другом месте в этом операторе, а также в каком-либо другом месте в рамках запроса.| 
|![Значок оператора Table-Valued Function](../relational-databases/media/table-valued-function-32x.gif "Значок оператора Table-Valued Function")|**Table-valued Function**|Оператор **Table-valued Function** вычисляет функцию с табличным значением (языка [!INCLUDE[tsql](../includes/tsql-md.md)] или среды CLR) и сохраняет строки результата в базе данных [tempdb](../relational-databases/databases/tempdb-database.md) . Когда родительские итераторы запрашивают эти строки, оператор **Table-valued Function** возвращает эти строки из базы данных **tempdb**.<br /><br /> Запросы, вызывающие функции с табличным значением, формируют планы запросов с итератором **Table-valued Function** . **Функция с табличным значением** может вычисляться с различными значениями параметров:<br /><br /> -<br /> **Модуль чтения функции с табличным значением XML** принимает большой двоичный объект XML как параметр и возвращает набор строк, представляющий узлы XML в том же порядке, что и в документе XML. Другие параметры могут ограничивать возвращаемые XML-узлы подмножеством XML-документа.<br /><br /> -**Модуль чтения функции с табличным значением XML с фильтром XPath** — это специальный тип **модуля чтения функции с табличным значением XML** , ограничивающий результат узлами XML, соответствующими выражению XPath.<br /><br /> Оператор**Table-valued Function** — это логический и физический оператор.| 
|None|**Top N Sort**|Оператор**Top N Sort** аналогичен итератору **Sort** за исключением того, что требуются только первые *N* строк, а не весь результирующий набор. Для небольших значений *N*ядро выполнения запросов [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] пытается выполнить операцию сортировки полностью в памяти. Для больших значений *N*ядро выполнения запросов использует более общий способ сортировки, в котором *N* не является параметром.| 
|![Значок оператора Top](../relational-databases/media/top-32x.gif "Значок оператора Top")|**Top**|Оператор **Top** просматривает входные данные и возвращает только указанное число или процент строк, выбранных, возможно, на основе порядка сортировки. Столбец **Аргумент** может содержать список столбцов, которые проверяются на наличие связей. Планируется использовать оператор **Top** для соблюдения ограничений на число строк. **Top** — это логический и физический оператор.| 
|![Значок расширенного оператора (UDX)](../relational-databases/media/udx-32x.gif "Значок расширенного оператора (UDX)")|**UDX**|Расширенные операторы (UDX) реализуют часть операций XQuery и XPath в [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Все операторы UDX являются и логическими, и физическими операторами.<br /><br /> Расширенный оператор (UDX) **FOR XML** используется для сериализации реляционных наборов строк, которые он получает на входе, в представление XML в одном столбце BLOB в единственной строке на выходе. Это статистический оператор XML, учитывающий порядок данных.<br /><br /> Расширенный оператор (UDX) **XML SERIALIZER** — это статистический оператор XML, учитывающий порядок данных. Он получает на входе строки, представляющие XML-узлы или скаляры XQuery в порядке, соответствующем XML-документу, и выдает сериализованный XML BLOB в единственном XML-столбце единственной строки вывода.<br /><br /> Расширенный оператор (UDX) **XML FRAGMENT SERIALIZER** является особым видом оператора **XML SERIALIZER** , использующимся для обработки входных строк, представляющих фрагменты XML, вставляемые в расширение вставки данных XQuery.<br /><br /> Расширенный оператор (UDX) **XQUERY STRING** вычисляет строковое значение XQuery из входных строк, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими скаляр XQuery, содержащий строковое значение входа.<br /><br /> Расширенный оператор (UDX) **XQUERY LIST DECOMPOSER** является оператором декомпозиции списка XQuery. Для каждой входной строки, представляющей собой узел XML, он создает одну или несколько строк, представляющих скаляр XQuery, содержащий значение элемента списка, если входные данные имеют тип списка XSD.<br /><br /> Расширенный оператор (UDX) **XQUERY DATA** определяет значение функции XQuery fn:data() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:data()** .<br /><br /> Расширенный оператор (UDX) **XQUERY CONTAINS** определяет значение функции XQuery fn:data() для входных данных, представляющих собой узлы XML. Это статистический строковый оператор, чувствительный к порядку данных. Он выводит одну строку со столбцами, представляющими собой скаляр XQuery, содержащий значение функции **fn:contains()** .<br /><br /> Расширенный оператор **UPDATE XML NODE** обновляет узел XML в расширении замены модификации данных XQuery с помощью метода **modify()** типа XML.| 
|None|**Union**|Оператор **Union** просматривает несколько входов, выводя каждую просмотренную строку и удаляя дубликаты. **Union** — это логический оператор.| 
|![Значок оператора Update (ядро СУБД)](../relational-databases/media/update-32x.gif "Значок оператора Update (ядро СУБД)")|**Update**|Оператор **Update** обновляет каждую строку, начиная с ее ввода в объект, указанный в столбце **Argument** плана выполнения запроса. **Update** является логическим оператором. Операторы **Table Update**, **Index Update**или **Clustered Index Update**являются физическими.| 
|![Значок элемента языка While](../relational-databases/media/while-32x.gif "Значок элемента языка While")|**While**|Оператор **While** реализует цикл while языка [!INCLUDE[tsql](../includes/tsql-md.md)] . **While** является элементом языка.| 
  
