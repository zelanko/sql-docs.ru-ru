---
title: Создание кластеризованных индексов | Документация Майкрософт
ms.custom: ''
ms.date: 02/17/2017
ms.prod: sql
ms.prod_service: table-view-index, sql-database
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- index creation [SQL Server], clustered indexes
- clustered indexes, creating
- clustered indexes, PRIMARY KEY constraint
- clustered indexes, UNIQUE constraint
- indexes [SQL Server], clustered
ms.assetid: 47148383-c2c7-4f08-a9e4-7016bf2d1d13
author: MikeRayMSFT
ms.author: mikeray
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 514ec88554282cf6e2cf0cc74eb1f35e77091fa9
ms.sourcegitcommit: 2429fbcdb751211313bd655a4825ffb33354bda3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2018
ms.locfileid: "52539023"
---
# <a name="create-clustered-indexes"></a>Создание кластеризованных индексов
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

  Кластеризованные индексы для таблиц можно создать с помощью [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] или [!INCLUDE[tsql](../../includes/tsql-md.md)]. За некоторыми исключениями, каждая таблица должна иметь кластеризованный индекс. Кроме того, что кластеризованный индекс повышает производительность запросов, его можно перестраивать или переорганизовывать по запросу, управляя фрагментацией таблицы. Кластеризованный индекс может быть также создан для представления. (Кластеризованные индексы определены в разделе [Описания кластеризованных и некластеризованных индексов](../../relational-databases/indexes/clustered-and-nonclustered-indexes-described.md).)  
  
 **В этом разделе**  
  
-   **Перед началом работы**  
  
     [Стандартные реализации](#Implementations)  
  
     [Ограничения](#Restrictions)  
  
     [безопасность](#Security)  
  
-   **Для создания кластеризованного индекса для таблицы используется:**  
  
     [Среда SQL Server Management Studio](#SSMSProcedure)  
  
     [Transact-SQL](#TsqlProcedure)  
  
##  <a name="BeforeYouBegin"></a> Перед началом  
  
###  <a name="Implementations"></a> Стандартные реализации  
 Кластеризованные индексы реализуются следующими методами.  
  
-   **Ограничениями PRIMARY KEY и UNIQUE**  
  
     Если кластеризованный индекс в таблице еще не создан, а уникальный некластеризованный индекс еще не указан, то при создании ограничения PRIMARY KEY в одном или нескольких столбцах автоматически создается уникальный кластеризованный индекс. В первичном ключевом столбце недопустимы значения NULL.  
  
     При создании ограничения UNIQUE создается уникальный некластеризованный индекс. Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию. Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.  
  
     Индексу, создаваемому в составе ограничения, автоматически присваивается то же имя, что и имя ограничения. Дополнительные сведения см. в разделах [Primary and Foreign Key Constraints](../../relational-databases/tables/primary-and-foreign-key-constraints.md) и [Unique Constraints and Check Constraints](../../relational-databases/tables/unique-constraints-and-check-constraints.md).  
  
-   **Индекс, не зависящий от ограничения**  
  
     Можно создать кластеризованный индекс в столбце, отличном от первичного ключевого столбца, если задано ограничение некластеризованного первичного ключа.  
  
###  <a name="Restrictions"></a> Ограничения  
  
-   При создании кластеризованного индекса в соответствующих файлах и файловых группах требуется столько места на диске, сколько суммарно занимают старые (исходные) и новые (целевые) структуры. Старая структура не освобождается до тех пор, пока не зафиксирована вся транзакция создания индекса. Кроме того, для сортировки может временно потребоваться дополнительное место на диске. Дополнительные сведения см. в статье [Disk Space Requirements for Index DDL Operations](../../relational-databases/indexes/disk-space-requirements-for-index-ddl-operations.md).  
  
-   Если кластеризованный индекс создается в куче с несколькими существующими некластеризованными индексами, все некластеризованные индексы необходимо перестроить, чтобы они содержали значение ключа кластеризации, а не идентификатор строки (RID). Точно так же, если кластеризованный индекс удаляется из таблицы с несколькими некластеризованными индексами, некластеризованные индексы перестраиваются в ходе операции DROP. Для больших таблиц это может занять значительное время.  
  
     Предпочтительный способ построения индекса в больших таблицах — это начать с кластеризованного индекса, а затем построить некластеризованные. При создании индексов для существующих таблиц рассмотрите целесообразность присвоения параметру ONLINE значения ON. В этом случае длительные блокировки таблиц удерживаться не будут. Это позволит продолжить выполнение запросов или обновление базовых таблиц. Дополнительные сведения см. в статье [Perform Index Operations Online](../../relational-databases/indexes/perform-index-operations-online.md).  
  
-   Ключ кластеризованного индекса не может включать в себя столбцы **varchar** , для которых существуют данные в единице размещения ROW_OVERFLOW_DATA. Если кластеризованный индекс создается для столбца типа **varchar** и существующие данные располагаются в единице размещения IN_ROW_DATA, то все последующие операции вставки или обновления для данного столбца, выталкивающие данные за пределы строки, будут завершаться ошибкой. Для получения сведений о таблицах, которые могут содержать превышающие размер страницы данные строки, используется функция динамического управления [sys.dm_db_index_physical_stats (Transact-SQL)](../../relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql.md).  
  
###  <a name="Security"></a> безопасность  
  
####  <a name="Permissions"></a> Permissions  
 Необходимо разрешение ALTER для таблицы или представления. Пользователь должен быть членом предопределенной роли сервера **sysadmin** или предопределенных ролей базы данных **db_ddladmin** и **db_owner**.  
  
##  <a name="SSMSProcedure"></a> Использование среды SQL Server Management Studio  
  
#### <a name="to-create-a-clustered-index-by-using-object-explorer"></a>Создание кластеризованного индекса в обозревателе объектов  
  
1.  В обозревателе объектов разверните таблицу, в которой необходимо создать кластеризованный индекс.  
  
2.  Щелкните правой кнопкой мыши папку **Индексы**, наведите указатель на пункт **Создать индекс** и выберите пункт **Кластеризованный индекс**.  
  
3.  В диалоговом окне **Создание индекса** на странице **Общие** введите имя нового индекса в поле **Имя индекса** .  
  
4.  В разделе **Ключевые столбцы индекса** щелкните **Добавить…**.  
  
5.  В диалоговом окне **Выбор столбцов из**_имя\_таблицы_ установите флажок для столбца таблицы, который следует добавить в кластеризованный индекс.  
  
6.  Нажмите кнопку **ОК**.  
  
7.  В диалоговом окне **Создание индекса** нажмите кнопку **ОК**.  
  
#### <a name="to-create-a-clustered-index-by-using-the-table-designer"></a>Создание кластеризованного индекса с помощью конструктора таблиц  
  
1.  В обозревателе объектов разверните базу данных, в которой необходимо создать таблицу с кластеризованным индексом.  
  
2.  Щелкните правой кнопкой мыши папку **Таблицы** и выберите команду **Создать таблицу...**.  
  
3.  Создайте новую таблицу обычным способом. Дополнительные сведения см. в статье [Создание таблиц (компонент Database Engine)](../../relational-databases/tables/create-tables-database-engine.md).  
  
4.  Щелкните правой кнопкой мыши созданную таблицу и выберите пункт **Конструктор**.  
  
5.  В меню **Конструктор таблиц** выберите пункт **Индексы и ключи**.  
  
6.  В диалоговом окне **Индексы и ключи** нажмите **Добавить**.  
  
7.  Выберите новый индекс в текстовом поле **Выбранный первичный (уникальный) ключ или индекс** .  
  
8.  Выберите в сетке **Создать как кластеризованный**и из раскрывающегося списка справа от свойства выберите **Да** .  
  
9. Щелкните **Закрыть**.  
  
10. В меню **Файл** выберите **Сохранить**_имя\_таблицы_.  
  
##  <a name="TsqlProcedure"></a> Использование Transact-SQL  
  
#### <a name="to-create-a-clustered-index"></a>Создание кластеризованного индекса  
  
1.  В **обозревателе объектов**подключитесь к экземпляру компонента [!INCLUDE[ssDE](../../includes/ssde-md.md)].  
  
2.  На стандартной панели выберите пункт **Создать запрос**.  
  
3.  Скопируйте следующий пример в окно запроса и нажмите кнопку **Выполнить**.  
  
    ```  
    USE AdventureWorks2012;  
    GO  
    -- Create a new table with three columns.  
    CREATE TABLE dbo.TestTable  
        (TestCol1 int NOT NULL,  
         TestCol2 nchar(10) NULL,  
         TestCol3 nvarchar(50) NULL);  
    GO  
    -- Create a clustered index called IX_TestTable_TestCol1  
    -- on the dbo.TestTable table using the TestCol1 column.  
    CREATE CLUSTERED INDEX IX_TestTable_TestCol1   
        ON dbo.TestTable (TestCol1);   
    GO  
    ```  
  
 Дополнительные сведения см. в разделе [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md).  
  
## <a name="see-also"></a>См. также:  
 [Создание первичных ключей](../../relational-databases/tables/create-primary-keys.md)   
 [Создание ограничений уникальности](../../relational-databases/tables/create-unique-constraints.md)  
  
  
