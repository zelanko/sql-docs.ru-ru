---
title: Оценка размера кластеризованного индекса | Документация Майкрософт
description: Используйте эту процедуру для оценки размера пространства, требуемого для хранения кластеризованного индекса в SQL Server.
ms.custom: ''
ms.date: 03/01/2017
ms.prod: sql
ms.reviewer: ''
ms.prod_service: database-engine, sql-database
ms.technology: supportability
ms.topic: conceptual
helpviewer_keywords:
- space allocation [SQL Server], index size
- size [SQL Server], tables
- disk space [SQL Server], indexes
- predicting table size [SQL Server]
- table size [SQL Server]
- estimating table size
- space [SQL Server], indexes
- clustered indexes, table size
- nonclustered indexes [SQL Server], table size
- designing databases [SQL Server], estimating size
- calculating table size
ms.assetid: 2b5137f8-98ad-46b5-9aae-4c980259bf8d
author: stevestein
ms.author: sstein
monikerRange: = azuresqldb-current || >= sql-server-2016 || = sqlallproducts-allversions
ms.openlocfilehash: 986996ff2ec54ce6a7e43924fb94ede81593c212
ms.sourcegitcommit: da88320c474c1c9124574f90d549c50ee3387b4c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2020
ms.locfileid: "85756158"
---
# <a name="estimate-the-size-of-a-clustered-index"></a>Оценка размера кластеризованного индекса

[!INCLUDE [SQL Server Azure SQL Database](../../includes/applies-to-version/sql-asdb.md)]

  Для оценки места, необходимого для хранения данных в кластеризованном индексе, можно использовать следующие шаги:  
  
1.  Рассчитайте пространство, используемое для хранения данных на конечном уровне кластеризованного индекса.  
  
2.  Рассчитайте пространство, используемое для хранения сведений об индексе для кластеризованного индекса.  
  
3.  Сложите полученные значения.  
  
## <a name="step-1-calculate-the-space-used-to-store-data-in-the-leaf-level"></a>Шаг 1. Расчет пространства, используемого для хранения данных на конечном уровне  
  
1.  Укажите количество строк в новой таблице:  
  
     ***Num_Rows***  = число строк в таблице  
  
2.  Укажите количество столбцов с фиксированной и изменяемой длиной, а также рассчитайте необходимый размер места для их хранения.  
  
     Вычислите размер, занимаемый каждой из этих групп столбцов в строке данных. Размер столбца зависит от типа данных и длины.  
  
     ***Num_Cols***  = общее количество столбцов (фиксированной и переменной ширины)  
  
     ***Fixed_Data_Size***  = общий размер в байтах всех ключевых столбцов фиксированной длины  
  
     ***Num_Variable_Cols***  = количество включенных столбцов переменной длины  
  
     ***Max_Var_Size***  = максимальный размер в байтах всех столбцов переменной длины  
  
3.  Если кластеризованный индекс не является уникальным, учитывается столбец *uniquifier* :  
  
     Столбец uniquifier может принимать значение NULL и имеет переменную длину. Он будет иметь значение, отличное от NULL, и размер 4 байта для строк, имеющих неуникальные значения ключа. Это значение является частью ключа индекса и требует уникальности значения ключа во всех строках.  
  
     ***Num_Cols***  = ***Num_Cols*** + 1  
  
     ***Num_Variable_Cols***  = ***Num_Variable_Cols*** + 1  
  
     ***Max_Var_Size***  = ***Max_Var_Size*** + 4  
  
     Эти изменения предполагают, что все значения станут неуникальными.  
  
4.  Часть строки, называемая битовой картой NULL, зарезервирована для управления свойством столбца принимать значение NULL. Вычислите ее размер.  
  
     ***Null_Bitmap***  = 2 + ((***Num_Cols*** + 7) / 8)  
  
     Используется только целая часть предыдущего выражения, остальная часть отбрасывается.  
  
5.  Расчет размера данных с переменной длиной:  
  
     Если таблица содержит столбцы с переменной длиной, определите, сколько пространства потребуется для хранения столбцов в строке:  
  
     ***Variable_Data_Size***  = 2 + (***Num_Variable_Cols*** x 2) + ***Max_Var_Size***  
  
     Байты, добавляемые к ***Max_Var_Size*** , нужны для отслеживания каждого столбца переменных. Эта формула исходит из предположения, что все столбцы переменной длины заполнены на 100 %. Если предполагается, что будет использовано меньше места для хранения столбца изменяемой длины, можно изменить значение ***Max_Var_Size*** в процентах от общей изменяемой длины для более точного подсчета общего размера таблицы.  
  
    > [!NOTE]  
    >  Можно сочетать столбцы **varchar**, **nvarchar**, **varbinary**или **sql_variant** , в результате чего общая ширина определенной таблицы превысит 8 060 байт. Длина каждого из этих столбцов должна быть в пределах 8 000 байт для столбцов типа **varchar**, **varbinary**или **sql_variant** и 4 000 байт для столбцов типа **nvarchar** . Тем не менее их общая ширина в таблице может превышать предел в 8 060 байт.  
  
     Если в таблице нет столбцов переменной ширины, присвойте параметру ***Variable_Data_Size*** значение 0.  
  
6.  Вычислите общий размер строк:  
  
     ***Row_Size***  = ***Fixed_Data_Size*** + ***Variable_Data_Size*** + ***Null_Bitmap*** + 4  
  
     Значение 4 является размером заголовка строки.  
  
7.  Расчет количества строк на странице (8 096 свободных байт на страницу):  
  
     ***Rows_Per_Page***  = 8096 / (***Row_Size*** + 2)  
  
     Так как строки не могут разрываться на разные страницы, общее количество строк на страницу необходимо округлить до меньшего целого значения целой строки. Значение 2 в формуле соответствует записи строки в массиве областей памяти страницы.  
  
8.  Рассчет количества зарезервированных пустых строк на странице на основании указанного [коэффициента заполнения](../../relational-databases/indexes/specify-fill-factor-for-an-index.md) :  
  
     ***Free_Rows_Per_Page***  = 8096 x ((100 - ***Fill_Factor***) / 100) / (***Row_Size*** + 2)  
  
     Коэффициент заполнения, используемый в расчете, должен быть целым значением, а не процентным соотношением. Так как строки не могут разрываться на разные страницы, общее количество строк на страницу необходимо округлить до меньшего целого значения целой строки. При увеличении коэффициента заполнения на каждой странице будет сохранено больше данных и, соответственно, потребуется меньше страниц. Значение 2 в формуле соответствует записи строки в массиве областей памяти страницы.  
  
9. Вычислите количество страниц, необходимое для хранения всех строк:  
  
     ***Num_Leaf_Pages***  = ***Num_Rows*** / (***Rows_Per_Page*** - ***Free_Rows_Per_Page***)  
  
     Вычисленное количество страниц должно быть округлено в большую сторону до ближайшей целой страницы.  
  
10. Расчет количества места, необходимого для хранения данных на конечном уровне (всего 8 192 байт на страницу):  
  
     ***Leaf_space_used***  = 8192 x ***Num_Leaf_Pages***  
  
## <a name="step-2-calculate-the-space-used-to-store-index-information"></a>Шаг 2. Расчет пространства, используемого для хранения данных индекса  
 Для оценки места, необходимого для хранения верхних уровней индекса, можно использовать следующие шаги:  
  
1.  Укажите количество столбцов переменной и фиксированной длины в ключе индекса и рассчитайте объем необходимого места для их хранения:  
  
     Ключевые столбцы индекса могут включать в себя столбцы постоянной и переменной длины. Чтобы вычислить размер строки индекса на внутреннем уровне, нужно рассчитать, сколько места занимает в строке индекса каждая из этих групп столбцов. Размер столбца зависит от типа данных и длины.  
  
     ***Num_Key_Cols***  возвращает общее количество ключевых столбцов (фиксированной и переменной ширины).  
  
     ***Fixed_Key_Size***  возвращает общий размер в байтах всех ключевых столбцов фиксированной длины.  
  
     ***Num_Variable_Key_Cols***  возвращает количество ключевых столбцов переменной длины.  
  
     ***Max_Var_Key_Size***  возвращает максимальный размер в байтах ключевых столбцов переменной длины.  
  
2.  Если индекс является неуникальным, необходимо учитывать любой столбец uniquifier:  
  
     Столбец uniquifier может принимать значение NULL и имеет переменную длину. Он будет иметь значение, отличное от NULL, и размер 4 байта для строк, имеющих неуникальные значения ключа индекса. Это значение является частью ключа индекса и требует уникальности значения ключа во всех строках.  
  
     ***Num_Key_Cols***  = ***Num_Key_Cols*** + 1  
  
     ***Num_Variable_Key_Cols***  = ***Num_Variable_Key_Cols*** + 1  
  
     ***Max_Var_Key_Size***  = ***Max_Var_Key_Size*** + 4  
  
     Эти изменения предполагают, что все значения станут неуникальными.  
  
3.  Рассчет размера битовой карты NULL:  
  
     Если в ключе индекса существуют столбцы, допускающие значение NULL, то часть индексной строки резервируется для битовой карты NULL. Вычислите ее размер.  
  
     ***Index_Null_Bitmap***  = 2 + ((количество столбцов в строке индекса + 7) / 8)  
  
     Следует использовать только целую часть предшествующего выражения. Остаток должен быть отброшен.  
  
     Если нет ключевых столбцов, допускающих значения NULL, установите параметр ***Index_Null_Bitmap*** на 0.  
  
4.  Расчет размера данных с переменной длиной:  
  
     Если индекс содержит столбцы с переменной длиной, определим, сколько пространства потребуется для хранения этих столбцов в строке:  
  
     ***Variable_Key_Size***  = 2 + (***Num_Variable_Key_Cols*** x 2) + ***Max_Var_Key_Size***  
  
     Байты, добавляемые к ***Max_Var_Key_Size*** , нужны для отслеживания каждого столбца переменной длины. Эта формула исходит из предположения, что все столбцы переменной длины заполнены на 100 %. Если предполагается, что для хранения столбца переменной длины будет использовано меньше места, то для более точного подсчета общего размера таблицы можно задать значение ***Max_Var_Key_Size*** как процент от максимально возможной длины.  
  
     Если нет столбцов переменной ширины, установите значение ***Variable_Key_Size*** равным 0.  
  
5.  Расчет размера индексной строки:  
  
     ***Index_Row_Size***  = ***Fixed_Key_Size*** + ***Variable_Key_Size*** + ***Index_Null_Bitmap*** + 1 (для служебных данных строки заголовка индекса) + 6 (для указателя на идентификатор дочерней страницы)  
  
6.  Расчет количества индексных строк на страницу (8 096 свободных байт на страницу):  
  
     ***Index_Rows_Per_Page***  = 8096 / (***Index_Row_Size*** + 2)  
  
     Так как строка индекса не может быть разорвана на две страницы, общее количество строк индекса на странице необходимо округлить в меньшую сторону до ближайшего целого значения. Значение 2 в формуле соответствует записи строки в массиве слота страницы.  
  
7.  Расчет количества уровней в индексе.  
  
     ***Non-leaf_Levels***  = 1 + log (Index_Rows_Per_Page) (***Num_Leaf_Pages*** / ***Index_Rows_Per_Page***)  
  
     Данное значение округляется в большую сторону до ближайшего целого числа. Это значение не учитывает конечный уровень кластеризованного индекса.  
  
8.  Вычислите количество неконечных страниц индекса:  
  
     ***Num_Index_Pages =*** ∑Level ***(Num_Leaf_Pages / (Index_Rows_Per_Page***^Level ***))***  
  
     где 1 <= Уровень <= ***Non-leaf_Levels***  
  
     Округлите каждое слагаемое в большую сторону до ближайшего целого числа. Рассмотрим в качестве простого примера индекс, где ***Num_Leaf_Pages*** = 1000 and ***Index_Rows_Per_Page*** = 25. Первый уровень индекса над конечным уровнем содержит 1000 строк индекса, что составляет одну строку индекса на конечную страницу, а на одну страницу помещается 25 строк индекса. Это означает, что для хранения этих 1000 строк индекса требуется 40 страниц. Следующий уровень индекса должен хранить 40 строк. Это означает, что ему необходимо 2 страниц. Последний уровень индекса должен хранить 2 строки. Это означает, что ему необходима 1 страница. Это дает 43 неконечных страницы индекса. Использование этих значений в предыдущих формулах приводит к следующему результату:  
  
     ***Non-leaf_Levels***  = 1 + log(25) (1000 / 25) = 3  
  
     ***Num_Index_Pages*** = 1000/(25^3)+ 1000/(25^2) + 1000/(25^1) = 1 + 2 + 40 = 43, что составляет число страниц, описанное в примере.  
  
9. Расчет размера индекса (всего 8 192 байт на страницу).  
  
     ***Index_Space_Used***  = 8192 x ***Num_Index_Pages***  
  
## <a name="step-3-total-the-calculated-values"></a>Шаг 3. Сложение полученных значений  
 Необходимо сложить результаты, полученные на двух предыдущих шагах.  
  
 Размер кластеризованного индекса (в байтах) = ***Leaf_Space_Used*** + ***Index_Space_used***  
  
 Этот расчет не учитывает следующие факторы.  
  
-   Секционирование  
  
     Размер служебных данных секционирования минимален, но его сложно рассчитать. Он не столь важен, чтобы включать в расчеты.  
  
-   Страницы размещения  
  
     Предусмотрена по меньшей мере одна IAM-страница, используемая для отслеживания страниц, выделенных куче, но размер служебных данных минимален, и алгоритма точного детерминированного вычисления количества используемых IAM-страниц не существует.  
  
-   Значения LOB  
  
     Алгоритм точного определения места, используемого для хранения значений данных типа LOB **varchar(max)** , **varbinary(max)** , **nvarchar(max)** , **text**, **ntext**, **xml**и **image** сложен. Достаточно только добавить средний размер ожидаемого значения LOB, умножить на ***Число_строк***и добавить полученное значение к общему размеру кластеризованного индекса.  
  
-   Сжатие  
  
     Размер сжатого индекса нельзя вычислить заранее.  
  
-   Разреженные столбцы  
  
     Сведения о требованиях разреженных столбцов к месту на диске см. в разделе [Use Sparse Columns](../../relational-databases/tables/use-sparse-columns.md).  
  
## <a name="see-also"></a>См. также:  
 [Описания кластеризованных и некластеризованных индексов](../../relational-databases/indexes/clustered-and-nonclustered-indexes-described.md)   
 [Оценка размера таблицы](../../relational-databases/databases/estimate-the-size-of-a-table.md)   
 [Создание кластеризованных индексов](../../relational-databases/indexes/create-clustered-indexes.md)   
 [Создание некластеризованных индексов](../../relational-databases/indexes/create-nonclustered-indexes.md)   
 [Оценка размера некластеризованного индекса](../../relational-databases/databases/estimate-the-size-of-a-nonclustered-index.md)   
 [Оценка размера кучи](../../relational-databases/databases/estimate-the-size-of-a-heap.md)   
 [Оценка размера базы данных](../../relational-databases/databases/estimate-the-size-of-a-database.md)  
  
  
