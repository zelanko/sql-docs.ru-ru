---
title: "Статистика | Документация Майкрософт"
ms.custom: 
ms.date: 11/20/2017
ms.prod: sql-non-specified
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.service: 
ms.component: statistics
ms.reviewer: 
ms.suite: sql
ms.technology: dbe-statistics
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- statistical information [SQL Server], query optimization
- query performance [SQL Server], statistics
- query optimization statistics [SQL Server]
- statistical information [SQL Server], database options
- query optimization statistics [SQL Server], about query optimization statistics
- statistical information [SQL Server], guidelines
- statistical information [SQL Server]
- using statistics [SQL Server]
- statistical information [SQL Server], indexes
- index statistics [SQL Server]
- query optimizer [SQL Server], statistics
- statistics [SQL Server]
ms.assetid: b86a88ba-4f7c-4e19-9fbd-2f8bcd3be14a
caps.latest.revision: "70"
author: BYHAM
ms.author: rickbyh
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: 73102f9a2640a9d3481b9e5fd0b613d50c6b1710
ms.sourcegitcommit: 9fbe5403e902eb996bab0b1285cdade281c1cb16
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/27/2017
---
# <a name="statistics"></a>Statistics
[!INCLUDE[appliesto-ss-asdb-asdw-pdw-md](../../includes/appliesto-ss-asdb-asdw-pdw-md.md)] Оптимизатор запросов использует статистику для создания планов запросов, которые повышают производительность запросов. Для большинства запросов оптимизатор уже создает необходимую статистику, которая позволяет сформировать высококачественный план запроса. Но в некоторых случаях для достижения наилучших результатов нужно создать дополнительные статистические данные или изменить структуру запроса. В этом разделе обсуждаются основные статистические понятия и предоставляются рекомендации по эффективному использованию статистики для оптимизации запросов.  
  
##  <a name="DefinitionQOStatistics"></a> Компоненты и основные понятия  
### <a name="statistics"></a>Statistics  
 Статистика для оптимизации запросов — это объекты, содержащие статистические сведения о распределении значений в одном или нескольких столбцах таблицы или индексированного представления. Оптимизатор запросов использует эти статистические сведения для оценки *кратности* — числа строк в результатах запроса. Такая *оценка кратности* позволяет оптимизатору запросов создать высококачественный план запроса. Например, в зависимости от предикатов оптимизатор запросов может использовать оценку кратности, чтобы выбрать оператор index seek вместо оператора index scan, который потребляет больше ресурсов, и благодаря этому повысить производительность запроса.  
  
 Каждый объект статистики создается для списка из одного или нескольких столбцов таблицы и содержит *гистограмму*, на которой отображается распределение значений в первом столбце. Объекты статистики для нескольких столбцов также хранят статистические сведения о корреляции значений между столбцами. Эти статистические данные корреляции называются значениями *плотности*и получаются из числа уникальных строк значений столбцов. 

#### <a name="histogram"></a> Гистограмма  
**Гистограмма** измеряет частоту появления каждого различающегося значения в наборе данных. Оптимизатор запросов вычисляет гистограмму для значений столбца в первом ключевом столбце объекта статистики, выбирая значения столбцов путем статистической выборки строк или при помощи полного просмотра всех строк в таблице или представлении. Если гистограмма создается на основе выбранного набора строк, то сохраняемые итоговые значения количества строк и количества различающихся значений являются приблизительными и не всегда выражаются целыми числами.

> [!NOTE]
> Гистограммы в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] создаются только для одного столбца, которым является первый столбец в наборе ключевых столбцов объекта статистики.
  
Чтобы создать гистограмму, оптимизатор запросов сортирует значения столбцов, вычисляет количество значений, совпадающих с каждым различающимся значением столбца, а затем осуществляет статистическую обработку значений столбцов с получением непрерывных шагов гистограммы, максимальное количество которых составляет 200. Каждый шаг гистограммы включает диапазон значений столбцов, за которым следует значение столбца, представляющее собой верхнюю границу. В этот диапазон входят все возможные значения столбца между граничными значениями, за исключением самих граничных значений. Наименьшим из отсортированных значений столбца является верхнее граничное значение первого шага гистограммы.

Если говорить подробнее, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] создает **гистограмму** на основе упорядоченного набора значений столбцов за три шага:

- **Инициализация гистограммы**: на первом шаге обрабатывается последовательность значений, начиная с начала сортированного набора; собирается до 200 значений *range_high_key*, *equal_rows*, *range_rows* и *distinct_range_rows* (*range_rows* и *distinct_range_rows* всегда равны нулю на этом шаге). Первый шаг заканчивается, когда все входные значения обработаны или найдено 200 значений. 
- **Сканирование со слиянием корзин**: каждое дополнительное значение из первого столбца ключа статистики обрабатывается на втором шаге в порядке сортировки; каждое последующее значение либо добавляется в последний диапазон, либо в конце создается новый диапазон (это возможно, потому что входные значения сортированы). Если создается новый диапазон, одна пара существующих, расположенных по соседству диапазонов сворачивается в один. Эта пара диапазонов выбирается с целью уменьшения информационных потерь. Этот способ использует алгоритм *максимальной разности* для сведения к минимуму числа шагов в гистограмме и вместе с тем максимального увеличения разницы между граничными значениями. Число шагов после сворачивания диапазонов на протяжении этого шага остается равным 200.
- **Консолидация гистограммы**: на третьем шаге могут быть свернуты дополнительные диапазоны, если это не приведет к значительной потере данных. Число шагов гистограммы может быть меньше, чем количество различающихся значений, даже для столбцов, в которых число граничных точек меньше 200. Таким образом, даже если в столбце содержится более 200 уникальных значений, гистограмма может содержать менее 200 шагов. Для столбца, состоящего только из уникальных значений, консолидированная гистограмма будет содержать как минимум три шага.

> [!NOTE]
> Если гистограмма была построена на основе выборки, а не полного сканирования, значения *equal_rows*, *range_rows*, *distinct_range_rows* и *average_range_rows* будут рассчитаны и не обязательно будут являться целыми числами.

На следующей диаграмме показана гистограмма с шестью шагами. Первый шаг — это область слева от первого верхнего граничного значения.
  
![](../../relational-databases/system-dynamic-management-views/media/a0ce6714-01f4-4943-a083-8cbd2d6f617a.gif "a0ce6714-01f4-4943-a083-8cbd2d6f617a")
  
Для каждого шага гистограммы (см. выше):
-   Полужирной линией обозначено верхнее граничное значение (*range_high_key*) и количество его вхождений (*equal_rows*).  
  
-   Закрашенная область слева от *range_high_key* обозначает диапазон значений столбца и среднее количество вхождений каждого значения столбца (*average_range_rows*). В первом шаге гистограммы значение *average_range_rows* всегда равно 0.  
  
-   Пунктирные линии обозначают выбранные значения, которые используются для оценки общего числа различающихся значений (*distinct_range_rows*) и общего числа значений в диапазоне (*range_rows*). Оптимизатор запросов использует *range_rows* и *distinct_range_rows* для вычисления *average_range_rows* и не хранит выбранные значения.   
  
#### <a name="density"></a> Вектор плотностей  
**Плотность** определяет число дубликатов в заданных столбце или комбинации столбцов и рассчитывается как 1/(число уникальных значений). Оптимизатор запросов использует плотности для улучшения оценок количества элементов для запросов, которые возвращают данные нескольких столбцов из одной таблицы или индексированного представления. Вектор плотностей содержит по одной плотности для каждого префикса столбцов объекта статистики. 

> [!NOTE]
> Частота определяет число вхождений каждого уникального значения в первый ключевой столбец объекта статистики и рассчитывается как (число строк) * плотность. В столбцах с уникальными значениями максимальная частота равна 1.

Например, если объект статистики имеет ключевые столбцы `CustomerId`, `ItemId` и `Price`, плотность вычисляется для каждого из следующих префиксов столбцов.
  
|Префикс столбца|Префикс, по которому вычисляется плотность|  
|---|---|
|(CustomerId)|Строки с совпадающими значениями CustomerId|  
|(CustomerId, ItemId)|Строки с совпадающими значениями CustomerId и ItemId.|  
|(CustomerId, ItemId, Price)|Строки с совпадающими значениями CustomerId, ItemId и Price.| 

### <a name="filtered-statistics"></a>Отфильтрованная статистика  
 Отфильтрованная статистика может повысить производительность запросов, которые выполняют выборку из четко определенных подмножеств данных. Отфильтрованная статистика использует предикат фильтра для выбора подмножества данных, включенных в статистику. Грамотно отфильтрованная статистика может улучшить план выполнения запроса по сравнению со статистикой по полной таблице. Дополнительные сведения о предикате фильтра см. в статье [CREATE STATISTICS &#40;Transact-SQL&#41;](../../t-sql/statements/create-statistics-transact-sql.md). Дополнительные сведения об условиях создания отфильтрованной статистики см. в подразделе [Условия создания статистики](#CreateStatistics) этого раздела.  
  
### <a name="statistics-options"></a>Параметры статистики  
 Предусмотрены три параметра, которые влияют на условия и методы создания и обновления статистики. Эти параметры задаются только на уровне базы данных.  
  
#### <a name="autocreatestatistics-option"></a>Параметр AUTO_CREATE_STATISTICS  
 Если включен параметр [AUTO_CREATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_create_statistics) (автоматическое создание статистики), оптимизатор запросов при необходимости создает статистику по отдельным столбцам в предикате запроса, чтобы улучшить оценку кратности для плана запроса. Такая статистика по отдельным столбцам создается для столбцов, в которых отсутствует [гистограмма](#histogram) в существующем объекте статистики. Параметр AUTO_CREATE_STATISTICS не определяет, создается ли статистика для индексов. Кроме того, этот параметр не создает отфильтрованную статистику. Он применяется строго к статистике по отдельным столбцам для всей таблицы.  
  
 Если оптимизатор запросов создает статистику при помощи параметра AUTO_CREATE_STATISTICS, имя статистики начинается с `_WA`. Воспользовавшись запросом ниже, можно определить, создал ли оптимизатор запросов статистику для столбца предиката запроса.  
  
```t-sql  
SELECT OBJECT_NAME(s.object_id) AS object_name,  
    COL_NAME(sc.object_id, sc.column_id) AS column_name,  
    s.name AS statistics_name  
FROM sys.stats AS s 
INNER JOIN sys.stats_columns AS sc  
    ON s.stats_id = sc.stats_id AND s.object_id = sc.object_id  
WHERE s.name like '_WA%'  
ORDER BY s.name;  
```  
  
#### <a name="autoupdatestatistics-option"></a>Параметр AUTO_UPDATE_STATISTICS  
 Если включен параметр [AUTO_UPDATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_update_statistics) (автоматическое обновление статистики), оптимизатор запросов определяет, устарела ли статистика, и при необходимости обновляет ее, если она используется в запросе. Статистика становится устаревшей, после того как операции вставки, обновления, удаления или слияния изменяют распределение данных в таблице или индексированном представлении. Оптимизатор запросов определяет, устарела ли статистика, подсчитывая операции изменения данных с момента последнего обновления статистики и сравнивая число изменений с пороговым значением. Пороговое значение основано на количестве строк в таблице или индексированном представлении.  
  
* Если используется версия до [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)], [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] применяет пороговое значение в зависимости от процента измененных строк. Это значение не зависит от числа строк в таблице. Пороговое значение:
    * Если на момент оценки статистических данных кратность в таблице не превышала 500, обновление выполняется для каждых 500 модификаций.
    * Если на момент оценки статистических данных кратность в таблице превышала 500, обновление выполняется для каждых 500 + 20 % модификаций.

* Начиная с версии [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] и при [уровне совместимости базы данных](../../relational-databases/databases/view-or-change-the-compatibility-level-of-a-database.md) 130 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] используется пороговое значение для динамического обновления статистических данных по убыванию. Значение изменяется в зависимости от числа строк в таблице. Оно вычисляется как квадратный корень из 1000, умноженный на текущее значение кратности в таблице. Благодаря этому изменению статистика для больших таблиц будет обновляться чаще. Но если уровень совместимости для базы данных ниже 130, применяется пороговое значение [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)].  

  > [!IMPORTANT]
  > Начиная с версии [!INCLUDE[ssKilimanjaro](../../includes/ssKilimanjaro-md.md)] и до [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] или с [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] и до [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] при [уровне совместимости базы данных](../../relational-databases/databases/view-or-change-the-compatibility-level-of-a-database.md) ниже 130 применяется [флаг трассировки 2371](../../t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql.md) и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] используется пороговое значение для динамического обновления статистических данных по убыванию. Значение изменяется в зависимости от числа строк в таблице.
  
Оптимизатор запросов проверяет наличие устаревшей статистики перед компиляцией запроса и до выполнения кэшированного плана запроса. Перед компиляцией запроса оптимизатор запросов с помощью столбцов, таблиц и индексированных представлений в предикате запроса определяет статистические данные, которые могли устареть. Перед выполнением кэшированного плана запроса компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] проверяет, ссылается ли план запроса на актуальную статистику.  
  
Параметр AUTO_UPDATE_STATISTICS применяется к объектам статистики, создаваемым для индексов, отдельных столбцов в предикатах запросов, и к статистике, создаваемой инструкцией [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md) . Этот параметр также применяется к отфильтрованной статистике.  
 
Дополнительные сведения см. в разделе об [управлении поведением Autostat (AUTO_UPDATE_STATISTICS) в SQL Server](http://support.microsoft.com/help/2754171).
  
#### <a name="autoupdatestatisticsasync"></a>AUTO_UPDATE_STATISTICS_ASYNC  
 Параметр [AUTO_UPDATE_STATISTICS_ASYNC](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_update_statistics_async) (асинхронное обновление статистики) определяет, какой режим обновления статистики использует оптимизатор запросов: синхронный или асинхронный. По умолчанию параметр асинхронного обновления статистики отключен, и оптимизатор запросов обновляет статистику синхронно. Параметр AUTO_UPDATE_STATISTICS_ASYNC применяется к объектам статистики, создаваемым для индексов, отдельных столбцов в предикатах запросов, и к статистике, создаваемой инструкцией [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md) .  
 
 > [!NOTE]
 > Чтобы задать параметр асинхронного обновления статистических данных в [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)], нужно установить значение **True** для параметров *Автоматическое обновление статистики* и *Асинхронное автоматическое обновление статистики* в разделе *Параметры* окна *Свойства базы данных*.
  
 Обновление статистики может выполняться синхронно (режим по умолчанию) или асинхронно. При синхронном обновлении статистики запросы всегда компилируются и выполняются с актуальной статистикой. Если статистика оказывается устаревшей, оптимизатор запросов ожидает появления обновленной статистики, прежде чем начать компиляцию и выполнение запроса. При асинхронном обновлении статистики запросы компилируются с существующей статистикой, даже если она устарела. Если на момент компиляции запроса статистика оказывается устаревшей, оптимизатор запросов может выбрать неоптимальный план запроса. Запросы, которые компилируются после выполнения асинхронного обновления, будут усовершенствованы благодаря использованию обновленной статистики.  
  
 Использовать синхронную статистику рекомендуется при выполнении операций, изменяющих распределение данных, таких как усечение таблицы или массовое обновление большой процентной доли строк. Если после выполнения операции статистика не будет обновлена, то использование синхронной статистики обеспечит создание актуальной статистики перед выполнением запросов к изменившимся данным.  
  
 Асинхронная статистика рекомендуется для достижения более прогнозируемого времени ответа на запросы в следующих сценариях.  
  
* Приложение часто выполняет один и тот же запрос, схожие запросы или схожие кэшированные планы запроса. Асинхронное обновление статистики может обеспечить более прогнозируемое время ответа на запрос по сравнению с синхронным, так как оптимизатор запросов может выполнять входящие запросы, не ожидая появления актуальной статистики. Это устраняет задержку в некоторых запросах, но не влияет на другие запросы.  
  
* Были случаи, когда в приложении истекало время ожидания клиентских запросов в результате ожидания обновленной статистики. В некоторых случаях ожидание синхронной статистики может вызвать аварийное завершение приложений, в которых задано малое время ожидания.  
  
#### <a name="incremental-stats"></a>INCREMENTAL STATS  
 При значении ON статистики создаются как статистики отдельно по секциям. При значении OFF дерево статистик удаляется и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] повторно вычисляет статистики. Значение по умолчанию — OFF. Этот параметр переопределяет свойство уровня базы данных INCREMENTAL.  
  
 Когда в большую таблицу добавляются новые секции, статистики должны быть обновлены для включения новых секций. Однако время, требуемое для сканирования всей таблицы (параметр FULLSCAN или SAMPLE) может быть весьма большим. Кроме того, в сканировании всей таблицы нет необходимости, поскольку могут требоваться только статистики для новых секций. Параметр добавочных статистик создает и хранит статистические данные для каждой из секций и при обновлении обновляет статистику только для тех секций, которым требуются новые статистики  
  
 Если статистики по секциям не поддерживаются, параметр пропускается и выводится предупреждение. Добавочные статистики не поддерживаются для следующих типов статистических данных.  
  
* Статистики, созданные с индексами, не выровненными по секциям для базовой таблицы.  
  
* Статистики, созданные в доступных для чтения базах данных-получателях AlwaysOn.  
  
* Статистики, созданные в базах данных, доступных только для чтения.  
  
* Статистики, созданные по фильтрованным индексам.  
  
* Статистика, созданная по представлениям.  
  
* Статистики, созданные по внутренним таблицам.  
  
* Статистики, созданные с пространственными индексами или XML-индексами.  
  
**Область применения**: начиная с [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] до [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
## <a name="CreateStatistics"></a> Условия создания статистики  
 Оптимизатор запросов самостоятельно создает статистику следующим образом:  
  
1.  Оптимизатор запросов создает статистику для индексов таблиц или представлений в момент создания индекса. Такая статистика создается по ключевым столбцам индекса. Если индекс является отфильтрованным, оптимизатор запросов создает отфильтрованную статистику по подмножеству строк, которое указано для отфильтрованного индекса. Дополнительные сведения об отфильтрованных индексах см. в статье [Создание отфильтрованных индексов](../../relational-databases/indexes/create-filtered-indexes.md) и [CREATE INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/create-index-transact-sql.md).  
  
2.  Если включен параметр [AUTO_CREATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_create_statistics), оптимизатор запросов создает статистику для отдельных столбцов в предикатах запросов.  
  
Для большинства запросов эти два метода создания статистики обеспечивают создание высококачественного плана запроса. В некоторых случаях план запроса можно усовершенствовать, создав дополнительную статистику с помощью инструкции [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md) . Эта дополнительная статистика может фиксировать статистическую корреляцию, которую не учитывает оптимизатор запросов при создании статистики для индексов или отдельных столбцов. Приложение может иметь дополнительные статистические корреляции в данных таблицы. Если учитывать такие корреляции в объекте статистики, оптимизатор запросов сможет усовершенствовать планы запросов. Например, план запроса можно улучшить путем использования отфильтрованной статистики по подмножеству строк данных или статистики по нескольким столбцам предиката запроса.  
  
Если статистика создается инструкцией CREATE STATISTICS, рекомендуем оставлять параметр AUTO_CREATE_STATISTICS включенным, чтобы оптимизатор запросов продолжал регулярно создавать статистику по отдельным столбцам предиката запроса. Дополнительные сведения о предикатах запросов см. в разделе [Условие поиска (Transact-SQL)](../../t-sql/queries/search-condition-transact-sql.md).  
  
Создание статистики с помощью инструкции CREATE STATISTICS рекомендуется, когда выполняется любое из следующих условий.  

* Помощник по настройке ядра СУБД ( [!INCLUDE[ssDE](../../includes/ssde-md.md)] ) рекомендует создание статистики.  

* Предикат запроса содержит несколько коррелирующих столбцов, которые еще не включены в один индекс.  

* Запрос выполняет выборку из подмножества данных.  

* Для запроса отсутствует статистика.  
  
### <a name="query-predicate-contains-multiple-correlated-columns"></a>Предикат запроса содержит несколько коррелирующих столбцов  
Если предикат запроса содержит несколько столбцов, между которыми есть связи и зависимости, то статистика по нескольким столбцам может усовершенствовать план запроса. Статистика по нескольким столбцам содержит статистику корреляции между столбцами, называемую *плотностью*, которая недоступна в статистике по отдельным столбцам. Плотность может повысить точность оценки количества элементов, если результаты запроса зависят от связей между данными из нескольких столбцов.  
  
Если столбцы уже принадлежат одному индексу, то объект статистики по нескольким столбцам уже существует и его не нужно создавать вручную. Если столбцы не принадлежат одному индексу, можно создать статистику по нескольким столбцам, создав индекс по столбцам или воспользовавшись инструкцией [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md). На поддержание индекса расходуется больше системных ресурсов по сравнению с объектом статистики. Если приложению не нужен индекс по нескольким столбцам, можно сэкономить системные ресурсы, создав объект статистики и не создавая индекс.  
  
Во время создания статистики по нескольким столбцам порядок столбцов в определении объекта статистики влияет на эффективность применения плотности для оценки количества элементов. Объект статистики хранит значения плотности для каждого префикса ключевых столбцов в определении объекта статистики. Дополнительные сведения о плотности см. в разделе [Вектор плотности](#density) на этой странице.  
  
Чтобы получить значения плотности, полезные для оценки количества элементов, столбцы в предикате запроса должны совпадать с одним из префиксов столбцов в определении объекта статистики. Например, следующий код создает объект статистики по столбцам `LastName`, `MiddleName`и `FirstName`.  
  
```t-sql  
USE AdventureWorks2012;  
GO  
IF EXISTS (SELECT name FROM sys.stats  
    WHERE name = 'LastFirst'  
    AND object_ID = OBJECT_ID ('Person.Person'))  
DROP STATISTICS Person.Person.LastFirst;  
GO  
CREATE STATISTICS LastFirst ON Person.Person (LastName, MiddleName, FirstName);  
GO  
```  
  
В этом примере объект статистики `LastFirst` содержит значения плотности для префиксов следующих столбцов: `(LastName)`, `(LastName, MiddleName)` и `(LastName, MiddleName, FirstName)`. Для `(LastName, FirstName)` плотность недоступна. Если в запросе используются `LastName` и `FirstName` , но не используется `MiddleName`, то плотность будет недоступна для оценки количества элементов.  
  
### <a name="query-selects-from-a-subset-of-data"></a>При запросе выполняется выборка из подмножества данных  
Когда оптимизатор запросов создает статистику по отдельным столбцам и индексам, она создается по значениям во всех строках. Если запросы выполняют выборку из подмножества строк и в этом подмножестве присутствует уникальное распределение данных, то отфильтрованная статистика может улучшить планы запросов. Отфильтрованную статистику можно создать с помощью инструкции [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md) с предложением [WHERE](../../t-sql/queries/where-transact-sql.md), чтобы определить выражение предиката фильтра.  
  
Например, при использовании [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] каждый продукт в таблице `Production.Product` относится к одной из четырех категорий в таблице `Production.ProductCategory`: велосипеды, запасные части, одежда и аксессуары. Каждая из этих категорий содержит различные данные, распределенные по весу: вес велосипеда находится в диапазоне от 13,77 до 30,0, вес запчастей — в диапазоне от 2,12 до 1050,00, иногда встречаются значения NULL, значения веса одежды и аксессуаров также равны NULL.  
  
В примере с категорией Bikes отфильтрованная статистика по весу всех велосипедов предоставит оптимизатору запросов более точную статистику, а также повысит качество плана запроса по сравнению с полнотабличной статистикой или отсутствующей статистикой по столбцу Weight. Столбец с весами велосипедов будет хорошим образцом для отфильтрованной статистики, но необязательно окажется удачным выбором для отфильтрованного индекса, если число уточняющих запросов веса относительно мало. Прирост производительности уточняющих запросов, обеспечиваемый отфильтрованным индексом, может оказаться меньше, чем дополнительные расходы на хранение и сопровождение, сопряженные с добавлением отфильтрованного индекса в базу данных.  
  
Следующая инструкция создает отфильтрованную статистику `BikeWeights` по всем подкатегориям из категории Bikes. Отфильтрованное выражение предиката определяет велосипеды, выполняя перечисление всех подкатегорий велосипедов со сравнением `Production.ProductSubcategoryID IN (1,2,3)`. В предикате нельзя использовать имя категории Bikes, поскольку оно хранится в таблице Production.ProductCategory, а все столбцы в критерии фильтра должны быть в одной таблице.  
  
[!code-sql[StatisticsDDL#FilteredStats2](../../relational-databases/statistics/codesnippet/tsql/statistics_1.sql)]  
  
Оптимизатор запросов может использовать отфильтрованную статистику `BikeWeights` для улучшения плана запроса в следующем запросе, при котором выбираются все велосипеды с весом более `25`.  
  
```t-sql  
SELECT P.Weight AS Weight, S.Name AS BikeName  
FROM Production.Product AS P  
    JOIN Production.ProductSubcategory AS S   
    ON P.ProductSubcategoryID = S.ProductSubcategoryID  
WHERE P.ProductSubcategoryID IN (1,2,3) AND P.Weight > 25  
ORDER BY P.Weight;  
GO  
```  
  
### <a name="query-identifies-missing-statistics"></a>При запрос определяется пропущенная статистика  
Если в результате ошибки или другого события оптимизатору запросов не удается создать статистику, он формирует план запроса, не используя статистику. Оптимизатор запросов помечает статистику как отсутствующую и пытается восстановить ее перед следующим выполнением запроса.  
  
Потерянная статистика отображается в виде предупреждений (имя таблицы красным шрифтом) на графическом отображении плана выполнения запроса в среде [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]. Кроме того, определить отсутствие статистики можно с помощью наблюдения за классом событий **Missing Column Statistics** с помощью приложения [!INCLUDE[ssSqlProfiler](../../includes/sssqlprofiler-md.md)]. Дополнительные сведения см. в статье [Категория событий "Ошибки и предупреждения" (компонент Database Engine)](../../relational-databases/event-classes/errors-and-warnings-event-category-database-engine.md).  
  
 Если статистика отсутствует, выполните следующие действия.  
  
* Убедитесь, что включены параметры [AUTO_CREATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_create_statistics) и [AUTO_UPDATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_update_statistics).  
  
* Убедитесь, что база данных доступна не только для чтения. Если база данных доступна только для чтения, новый объект статистики сохранить нельзя.  
  
* Создайте отсутствующую статистику с помощью инструкции [CREATE STATISTICS](../../t-sql/statements/create-statistics-transact-sql.md).  
  
Если статистика для доступной только для чтения базы данных или доступного только для чтения моментального снимка отсутствует или устарела, компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] создаст и будет поддерживать временную статистику в базе данных **tempdb**. Когда компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] создает временную статистику, перед именем статистики добавляется суффикс *_readonly_database_statistic*, чтобы временную статистику можно было отличить от постоянной. Суффикс *_readonly_database_statistic* зарезервирован для статистики, создаваемой [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Скрипты для временной статистики могут создаваться и воспроизводиться в базе данных для чтения и записи. При создании скрипта [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] изменяет суффикс имени статистики с *_readonly_database_statistic* на *_readonly_database_statistic_scripted*.  
  
Только [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] может создавать и обновлять временную статистику. Тем не менее можно удалять временную статистику и наблюдать за свойствами статистики с помощью тех же инструментов, которые используются для постоянной статистики:  
  
* Удаление временной статистики осуществляется с использованием инструкции [DROP STATISTICS](../../t-sql/statements/drop-statistics-transact-sql.md).  
  
* Мониторинг статистики ведется с помощью представлений каталога **[sys.stats](../../relational-databases/system-catalog-views/sys-stats-transact-sql.md)** и **[sys.stats_columns](../../relational-databases/system-catalog-views/sys-stats-columns-transact-sql.md)**. **sys_stats** включает столбец **is_temporary** для указания на то, какая статистика является постоянной, а какая временной.  
  
 Поскольку временная статистика хранится в базе данных **tempdb**, перезапуск службы [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] приведет к удалению всей временной статистики.  
    
## <a name="UpdateStatistics"></a> Условия обновления статистики  
 Оптимизатор запросов определяет, устарела ли статистика, а затем при необходимости обновляет ее, если она требуется для плана запроса. В некоторых случаях можно улучшить план запроса и тем самым повысить производительность запроса, обновляя статистику чаще, чем она обновляется при включенном параметре [AUTO_UPDATE_STATISTICS](../../t-sql/statements/alter-database-transact-sql-set-options.md#auto_update_statistics). Статистику можно обновлять инструкцией UPDATE STATISTICS или хранимой процедурой sp_updatestats.  
  
 Обновление статистики гарантирует, что запросы будут компилироваться с актуальной статистикой. Однако обновление статистики вызывает перекомпиляцию запросов. Рекомендуется не обновлять статистику слишком часто, поскольку необходимо найти баланс между выигрышем в производительности за счет усовершенствованных планов запросов и потерей времени на перекомпиляцию запросов. Критерии выбора компромиссного решения зависят от приложения.  
  
 При обновлении статистики с помощью инструкции UPDATE STATISTICS или хранимой процедуры sp_updatestats рекомендуем оставлять параметр AUTO_UPDATE_STATISTICS включенным, чтобы оптимизатор запросов продолжал регулярно обновлять статистику. Дополнительные сведения об обновлении статистики по столбцу, индексу, таблице или индексированному представлению см. в разделе [UPDATE STATISTICS &#40;Transact-SQL&#41;](../../t-sql/statements/update-statistics-transact-sql.md). Сведения об обновлении статистики по всем определяемым пользователем таблицам и внутренним таблицам в базе данных см. в описании хранимой процедуры [sp_updatestats &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-updatestats-transact-sql.md).  
  
 Чтобы определить время последнего обновления статистики, используйте функцию [sys.dm_db_stats_properties](../../relational-databases/system-dynamic-management-views/sys-dm-db-stats-properties-transact-sql.md) или [STATS_DATE](../../t-sql/functions/stats-date-transact-sql.md).  
  
 Обновление статистики рекомендуется в следующих ситуациях.  
  
* Запросы выполняются медленно.  
  
* Выполняются операции вставки в ключевые столбцы, отсортированные по возрастанию или по убыванию.  
  
* После операций обслуживания.  
  
### <a name="query-execution-times-are-slow"></a>Запросы выполняются медленно  
 Если время ответа на запросы велико или непрогнозируемо, убедитесь, что для запросов есть актуальная статистика, и только потом выполняйте дальнейшие шаги по диагностике.  
  
### <a name="insert-operations-occur-on-ascending-or-descending-key-columns"></a>Выполняются операции вставки в ключевые столбцы, отсортированные по возрастанию или по убыванию  
 Для статистики по ключевым столбцам, отсортированным по возрастанию или убыванию (например, столбец IDENTITY или столбцы отметок реального времени), может понадобиться выполнять обновление чаще, чем это делает оптимизатор запросов. Операции вставки добавляют новые значения в столбцы, отсортированные по возрастанию или по убыванию. Число добавляемых строк может оказаться слишком маленьким и не вызвать обновление статистики. Если статистика не является актуальной и запросы выполняют выборку из недавно добавленных строк, то в текущей статистике не будет оценки количества элементов для этих новых значений. Это может привести к неправильной оценке количества элементов и замедлить выполнение запроса.  
  
 Например, запрос, который выполняет выборку из дат самых последних заказов на продажу, будет иметь неправильную оценку количества элементов, если статистика не обновлена и не содержит оценки количества элементов для дат самых последних заказов на продажу.  
  
### <a name="after-maintenance-operations"></a>После операций обслуживания  
 Обновление статистики рекомендуется после выполнения процедур обслуживания, которые изменяют распределение данных, таких как усечение таблицы или массовая вставка большого количества строк (в процентном отношении). В будущем это может предотвратить задержки в обработке запросов, вызванные ожиданием автоматического обновления статистики.  
  
 Такие операции, как перестроение, дефрагментация и реорганизация индекса, не изменяют распределение данных, и поэтому после выполнения операций [ALTER INDEX REBUILD](../../t-sql/statements/alter-index-transact-sql.md#rebuilding-indexes), [DBCC DBREINDEX](../../t-sql/database-console-commands/dbcc-dbreindex-transact-sql.md), [DBCC INDEXDEFRAG](../../t-sql/database-console-commands/dbcc-indexdefrag-transact-sql.md) и [ALTER INDEX REORGANIZE](../../t-sql/statements/alter-index-transact-sql.md#reorganizing-indexes) не нужно обновлять статистику. Но оптимизатор запросов обновляет статистику, когда выполняется перестройку индекса для таблицы или представления с помощью инструкции ALTER INDEX REBUILD или DBCC DBREINDEX. Такое обновление статистики является побочным эффектом повторного создания индекса. Оптимизатор запросов не обновляет статистику после операций DBCC INDEXDEFRAG и ALTER INDEX REORGANIZE. 
 
> [!TIP]
> Начиная с версии [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] с пакетом обновления 1 и накопительным пакетом обновления 4 используйте параметр PERSIST_SAMPLE_PERCENT для [CREATE STATISTICS &#40;Transact-SQL&#41;](../../t-sql/statements/create-statistics-transact-sql.md) или [UPDATE STATISTICS &#40;Transact-SQL&#41;](../../t-sql/statements/update-statistics-transact-sql.md), чтобы задать и сохранить определенный процент выборки для последующих обновлений статистических данных, в которых такой процент явно не указан.
  
##  <a name="DesignStatistics"></a> Запросы, при которых эффективно используется статистика  
 Некоторые особенности реализации запросов, например использование локальных переменных и сложных выражений в предикате запроса, могут привести к созданию неоптимальных планов запросов. Этого можно избежать, если следовать рекомендациям по конструированию запросов. Дополнительные сведения о предикатах запросов см. в разделе [Условие поиска (Transact-SQL)](../../t-sql/queries/search-condition-transact-sql.md).  
  
 Планы запросов можно усовершенствовать, если выполнить рекомендации по конструированию запросов. Они эффективно применяют статистику для улучшения *оценки количества элементов* для выражений, переменных и функций, используемых в предикатах запросов. Если оптимизатору запросов неизвестно значение выражения, переменной или функции, он не может определить значение для уточняющего запроса в гистограмме и поэтому не может получить из гистограммы наилучшую оценку кратности. Вместо этого оптимизатор запросов выполняет оценку кратности на основании среднего числа строк на каждое уникальное значение для всех строк гистограммы, включенных в выборку. В результате оценка количества элементов оказывается неоптимальной и производительность запросов может снизиться. Дополнительные сведения о гистограммах см. в разделе [Гистограмма](#histogram) на этой странице или в статье [sys.dm_db_stats_histogram (Transact-SQL)](../../relational-databases/system-dynamic-management-views/sys-dm-db-stats-histogram-transact-sql.md).
  
 Следующие рекомендации показывают, как составлять запросы, чтобы усовершенствовать планы запроса благодаря улучшению оценки количества элементов.  
  
### <a name="improving-cardinality-estimates-for-expressions"></a>Улучшение оценки кратности для выражений  
Чтобы улучшить оценку количества элементов для выражений, выполните следующие рекомендации.  
  
* По возможности упрощайте выражения, содержащие константы. Оптимизатор запросов не вычисляет все функции и выражения, содержащие константы, перед оценкой кратности. Например, следует упростить выражение `ABS(-100)` до `100`.  
  
* Если в выражении используется несколько переменных, рекомендуется создать вычисляемый столбец для выражения, а затем создать статистику или индекс по вычисляемому столбцу. Например, предикат запроса `WHERE PRICE + Tax > 100` может иметь лучшую оценку количества элементов, если создать вычисляемый столбец для выражения `Price + Tax`.  
  
### <a name="improving-cardinality-estimates-for-variables-and-functions"></a>Улучшение оценки кратности для переменных и функций  
Чтобы улучшить оценку количества элементов для переменных и функций, выполните следующие рекомендации.  
  
* Если в предикате запроса используется локальная переменная, рекомендуется переписать запрос так, чтобы вместо локальной переменной в нем использовался параметр. Значение локальной переменной неизвестно в момент, когда оптимизатор запросов создает план выполнения запросов. Если в запросе используется параметр, оптимизатор запросов оценивает кратность для первого фактического значения параметра, передаваемого хранимой процедуре.  
  
* Для хранения результатов функции с табличным значением с несколькими инструкциями рекомендуем использовать стандартную или временную таблицу (mstvf). Оптимизатор запросов не создает статистику для функций с табличным значением с несколькими инструкциями. Такой подход позволяет оптимизатору запросов создавать статистику по столбцам таблицы и использовать ее для формирования улучшенного плана запроса.  
  
* Вместо табличных переменных рекомендуется использовать стандартную или временную таблицу. Оптимизатор запросов не создает статистику для табличных переменных. Такой подход позволяет оптимизатору запросов создавать статистику по столбцам таблицы и использовать ее для формирования улучшенного плана запроса. При выборе между временной таблицей и табличной переменной следует учитывать, что табличные переменные, используемые в хранимых процедурах, вызывают меньше перекомпиляций хранимой процедуры, чем временные таблицы. В зависимости от приложения использование временной таблицы вместо табличной переменной не обязательно приведет к повышению производительности.  
  
* Если хранимая процедура содержит запрос, в котором используется переданный параметр, не следует изменять значение параметра в рамках хранимой процедуры до того, как он будет использоваться в запросе. Оценка количество элементов для запроса основывается на значение переданного параметра, а не на обновленном значении. Чтобы исключить изменение значения параметра, можно переписать запрос так, чтобы использовать две хранимые процедуры.  
  
     Например, хранимая процедура `Sales.GetRecentSales` изменяет значение параметра `@date`, если `@date` имеет значение NULL.  
  
    ```t-sql  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
    AS BEGIN  
        IF @date IS NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
     Если при первом вызове хранимой процедуры `Sales.GetRecentSales` для параметра `@date` передается значение NULL, оптимизатор запросов выполнит компиляцию хранимой процедуры с оценкой кратности для `@date = NULL`, даже если при вызове предиката запроса не указывалось `@date = NULL`. Такая оценка количества элементов может значительно отличаться от количества строк в фактическом результате запроса. В итоге оптимизатор запросов может выбрать неоптимальный план запроса. Чтобы избежать подобной ситуации, можно переписать хранимую процедуру, разбив ее на две процедуры следующим образом:  
  
    ```t-sql  
    USE AdventureWorks2012;  
    GO  
    IF OBJECT_ID ( 'Sales.GetNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNullRecentSales (@date datetime)  
    AS BEGIN  
        IF @date is NULL  
            SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
        EXEC Sales.GetNonNullRecentSales @date;  
    END  
    GO  
    IF OBJECT_ID ( 'Sales.GetNonNullRecentSales', 'P') IS NOT NULL  
        DROP PROCEDURE Sales.GetNonNullRecentSales;  
    GO  
    CREATE PROCEDURE Sales.GetNonNullRecentSales (@date datetime)  
    AS BEGIN  
        SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
        WHERE h.SalesOrderID = d.SalesOrderID  
        AND h.OrderDate > @date  
    END  
    GO  
    ```  
  
### <a name="improving-cardinality-estimates-with-query-hints"></a>Улучшение оценки кратности с помощью указаний запросов  
 Чтобы улучшить оценку кратности для локальных переменных, можно использовать указания запросов `OPTIMIZE FOR <value>` или `OPTIMIZE FOR UNKNOWN` с параметром RECOMPILE. Дополнительные сведения см. в разделе [Указания запросов (Transact-SQL)](../../t-sql/queries/hints-transact-sql-query.md).  
  
 Для некоторых приложений повторная компиляция запроса при каждом выполнении может занять слишком продолжительное время. Указание запроса `OPTIMIZE FOR` может повысить производительность даже в случае, когда параметр `RECOMPILE` не используется. Например, можно добавить параметр `OPTIMIZE FOR` к хранимой процедуре Sales.GetRecentSales, чтобы указать определенную дату. В следующем примере параметр `OPTIMIZE FOR` добавляется к процедуре Sales.GetRecentSales.  
  
```t-sql  
USE AdventureWorks2012;  
GO  
IF OBJECT_ID ( 'Sales.GetRecentSales', 'P') IS NOT NULL  
    DROP PROCEDURE Sales.GetRecentSales;  
GO  
CREATE PROCEDURE Sales.GetRecentSales (@date datetime)  
AS BEGIN  
    IF @date is NULL  
        SET @date = DATEADD(MONTH, -3, (SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader))  
    SELECT * FROM Sales.SalesOrderHeader h, Sales.SalesOrderDetail d  
    WHERE h.SalesOrderID = d.SalesOrderID  
    AND h.OrderDate > @date  
    OPTION ( OPTIMIZE FOR ( @date = '2004-05-01 00:00:00.000'))  
END;  
GO  
```  
  
### <a name="improving-cardinality-estimates-with-plan-guides"></a>Улучшение оценки кратности с помощью структур плана  
 Для некоторых приложений рекомендации по конструированию запросов могут не действовать, поскольку запрос невозможно изменить или указание запроса RECOMPILE может вызвать слишком много повторных компиляций. С помощью структур плана можно задавать другие указания, такие как USE PLAN, чтобы управлять работой запроса, пока идет согласование изменений приложения с поставщиком приложения. Дополнительные сведения о структурах планов см. в разделе [Руководства планов](../../relational-databases/performance/plan-guides.md).  
  
  
## <a name="see-also"></a>См. также:  
 [CREATE STATISTICS (Transact-SQL)](../../t-sql/statements/create-statistics-transact-sql.md)   
 [UPDATE STATISTICS (Transact-SQL)](../../t-sql/statements/update-statistics-transact-sql.md)   
 [sp_updatestats (Transact-SQL)](../../relational-databases/system-stored-procedures/sp-updatestats-transact-sql.md)   
 [DBCC SHOW_STATISTICS (Transact-SQL)](../../t-sql/database-console-commands/dbcc-show-statistics-transact-sql.md)   
 [Параметры ALTER DATABASE SET (Transact-SQL)](../../t-sql/statements/alter-database-transact-sql-set-options.md)   
 [DROP STATISTICS (Transact-SQL)](../../t-sql/statements/drop-statistics-transact-sql.md)   
 [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md)   
 [ALTER INDEX (Transact-SQL)](../../t-sql/statements/alter-index-transact-sql.md)   
 [Создание отфильтрованных индексов](../../relational-databases/indexes/create-filtered-indexes.md)   
 [Controlling Autostat (AUTO_UPDATE_STATISTICS) behavior in SQL Server](http://support.microsoft.com/help/2754171)  (Управление поведением Autostat (AUTO_UPDATE_STATISTICS) в SQL Server)  
 [STATS_DATE &#40;Transact-SQL&#41;](../../t-sql/functions/stats-date-transact-sql.md)   
 [sys.dm_db_stats_properties &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-db-stats-properties-transact-sql.md)   
 [sys.dm_db_stats_histogram &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-db-stats-histogram-transact-sql.md)  
 
