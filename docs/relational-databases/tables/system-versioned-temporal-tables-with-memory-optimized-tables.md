---
title: Темпоральные таблицы с системным управлением версиями и таблицы, оптимизированные для памяти | Документация Майкрософт
ms.custom: ''
ms.date: 07/12/2016
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
ms.assetid: 23274522-e5cf-4095-bed8-bf986d6342e0
author: CarlRabeler
ms.author: carlrab
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: cd143092a666a9e1fd661651d0bfe9620db7cc8c
ms.sourcegitcommit: b57d98e9b2444348f95c83a24b8eea0e6c9da58d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/21/2020
ms.locfileid: "86554539"
---
# <a name="system-versioned-temporal-tables-with-memory-optimized-tables"></a>темпоральные таблицы с системным управлением версиями и таблицы с оптимизацией памяти

[!INCLUDE [sqlserver2016-asdb-asdbmi](../../includes/applies-to-version/sqlserver2016-asdb-asdbmi.md)]

Темпоральные таблицы с системным управлением версиями для [таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/memory-optimized-tables.md) — это экономичное решение для сценариев, в которых требуется [аудит и анализ на момент времени данных](https://msdn.microsoft.com/library/mt631669.aspx) для данных, собранных из рабочих нагрузок In-Memory OLTP. Они обеспечивают высокую скорость обработки транзакций, параллелизм без блокировки и в то же время возможность хранения большого объема данных журнала, которые легко можно запросить.

## <a name="overview"></a>Обзор

Темпоральные таблицы с системным управлением версиями автоматически сохраняют полный журнал изменений данных и предоставляют удобные расширения Transact-SQL для анализа на момент времени. В типичном сценарии журнал данных хранится в течение длительного времени (несколько месяцев и даже лет) несмотря на то, что они не запрашиваются регулярно.

Аудит и анализ данных на основе времени можно запросить в различных средах, особенно в системах OLTP, которые обрабатывают очень много запросов и используют технологию In-Memory OLTP. Однако использование таблиц, оптимизированных для памяти, в темпоральных сценариях весьма сложно, поскольку огромный объем созданных данных журнала обычно превышает доступный объем ОЗУ. В то же время неоптимально использовать ОЗУ для хранения журнала данных только для чтения, доступ к которым осуществляется все реже по мере их старения.

Темпоральные таблицы с системным управлением версиями для таблиц, оптимизированных для памяти, обеспечивают высокую скорость обработки транзакций, параллелизм без блокировки и в то же время позволяют хранить большой объем данных журнала с помощью таблиц в памяти для хранения текущих данных (темпоральная таблица) и таблиц на диске — для данных журнала. Влияние на операции DML сводится к минимуму за счет использования внутренней, автоматически созданной промежуточной таблицы, оптимизированной для памяти, в которой хранится журнал последних действий и которая позволяет выполнять DML из собственного кода.

Следующая диаграмма иллюстрирует такую архитектуру. ![Темпоральная архитектура в памяти](../../relational-databases/tables/media/temporal-in-memory-architecture.png "Темпоральная архитектура, выполняющаяся в памяти")

## <a name="implementation-details"></a>Сведения о реализации

Следующие факты о темпоральных таблицах с системным управлением версиями и оптимизированными для памяти таблицами необходимо учитывать при создании таблицы с системным управлением версиями, оптимизированной для операций в памяти. Параметры синтаксиса и примеры см. в разделе [CREATE TABLE (Transact-SQL)](../../t-sql/statements/create-table-transact-sql.md).

- Только долговечные, оптимизированные для памяти таблицы могут поддерживать системное управление версиями (**DURABILITY = SCHEMA_AND_DATA**).
- Таблица журнала для оптимизированной для памяти таблицы с системным управлением версиями должна размещаться на диске независимо от того, была ли она создана конечным пользователем или системой.
- Запросы, относящиеся только к текущей таблице (в памяти), можно использовать в [модулях, скомпилированных в T-SQL](https://msdn.microsoft.com/library/dn133184.aspx). Темпоральные запросы, использующие предложение FOR SYSTEM TIME, не поддерживаются в модулях, скомпилированных в собственном коде. Использование предложения FOR SYSTEM TIME поддерживается с оптимизированными для памяти таблицами в нерегламентированных запросах и в модулях с несобственным кодом.
- Если **SYSTEM_VERSIONING = ON**, внутренняя промежуточная таблица, оптимизированная для памяти, создается автоматически для принятия последних изменений с системным управлением версиями, которые являются результатами операций обновления и удаления в текущей таблице, оптимизированной для памяти.
- Данные из этой внутренней промежуточной таблицы регулярно перемещаются в таблицу журнала на диске асинхронной задачей сброса данных. Цель этого механизма — сохранить размер внутренних буферов памяти на уровне менее 10 % от потребляемой памяти родительских объектов. Вы можете отслеживать общее потребление памяти темпоральной таблицей, оптимизированной для памяти, с системным управлением версиями, запрашивая [sys.dm_db_xtp_memory_consumers (Transact-SQL)](../../relational-databases/system-dynamic-management-views/sys-dm-db-xtp-memory-consumers-transact-sql.md) и получая сводные данные для внутренней промежуточной таблицы, оптимизированной для памяти, и текущей темпоральной таблицы.
- Вы можете принудительно выполнить сброс данных, вызвав [sp_xtp_flush_temporal_history](../../relational-databases/system-stored-procedures/temporal-table-sp-xtp-flush-temporal-history.md).
- Если **SYSTEM_VERSIONING = OFF** или схема таблицы с системным управлением версиями изменяется (столбцы добавляются, удаляются или изменяются), все содержимое промежуточного внутреннего буфера перемещается в таблицу журнала на диске.
- Запрос данных журнала выполняется на уровне изоляции моментального снимка и всегда возвращает объединение промежуточного буфера в памяти и дисковой таблицы без дубликатов.
- Операции**ALTER TABLE** , которые изменяют схему таблицы внутренне, должны выполнить сброс данных, что может увеличить время выполнения операции.

## <a name="the-internal-memory-optimized-staging-table"></a>Внутренняя промежуточная таблица, оптимизированная для памяти

Внутренняя промежуточная таблица, оптимизированная для памяти, — это внутренний объект, созданный системой для оптимизации операций DML.

- Имя таблицы создается в следующем формате: **Memory_Optimized_History_Table_<ИД_объекта>** , где *<ИД_объекта>*  — это идентификатор текущей темпоральной таблицы.
- Таблица реплицирует схему текущей темпоральной таблицы, а также один столбец типа BIGINT. Этот дополнительный столбец гарантирует уникальность строк, перемещаемых во внутренний буфер.
- Для имени дополнительного столбца используется следующий формат: **Change_ID[_<суффикс>]** , где *_\<suffix>* добавляется в том случае, если в таблице уже есть столбец *Change_ID*.
- Максимальный размер строки таблицы с системным управлением версиями, оптимизированной для памяти, уменьшается на восемь байт из-за дополнительного столбца BIGINT в промежуточной таблице. Новое максимальное значение — 8052 байт.
- Внутренняя промежуточная таблица, оптимизированная для памяти, не представлена в обозревателе объектов SQL Server Management Studio.
- Метаданные этой таблицы, а также ее связь с текущей темпоральной таблицей можно найти в [sys.internal_tables (Transact-SQL)](../../relational-databases/system-catalog-views/sys-internal-tables-transact-sql.md).

## <a name="the-data-flush-task"></a>Задачи сброса данных

Сброс данных — это регулярно выполняемая задача, которая проверяет, соответствует ли оптимизированная для памяти таблица условиям по размеру для перемещения данных. Перемещение данных начинается, когда потребление памяти внутренней промежуточной таблицы достигнет 8 % от потребления памяти текущей темпоральной таблицы.

Задача сброса данных активируется регулярно по расписанию, которое меняется в зависимости от текущей рабочей нагрузки. При высокой нагрузке она может выполняться каждые пять секунд, а при небольшой нагрузке — каждую минуту. Для каждой внутренней промежуточной таблицы, оптимизированной для памяти, требующей сброса, создается один поток.

При сбросе данных удаляются все записи из внутреннего буфера в памяти, которые старше самой старой выполняемой в текущий момент транзакции, чтобы переместить эти записи в таблицу журнала на диске.

Можно принудительно выполнить сброс данных, вызвав [sp_xtp_flush_temporal_history](../../relational-databases/system-stored-procedures/temporal-table-sp-xtp-flush-temporal-history.md) и указав схему и имя таблицы: **sys.sp_xtp_flush_temporal_history @schema_name, @object_name** . При выполнении этой команды пользователем происходит тот же процесс перемещения данных, что и при вызове сброса данных по внутреннему расписанию системы.

## <a name="see-also"></a>См. также:

- [Темпоральные таблицы](../../relational-databases/tables/temporal-tables.md)
- [Приступая к работе c темпоральными таблицами с системным управлением версиями](../../relational-databases/tables/getting-started-with-system-versioned-temporal-tables.md)
- [Сценарии использования темпоральных таблиц](../../relational-databases/tables/temporal-table-usage-scenarios.md)
- [Проверка согласованности системной темпоральной таблицы](../../relational-databases/tables/temporal-table-system-consistency-checks.md)
- [Секционирование с помощью темпоральных таблиц](../../relational-databases/tables/partitioning-with-temporal-tables.md)
- [Рекомендации и ограничения для темпоральной таблицы](../../relational-databases/tables/temporal-table-considerations-and-limitations.md)
- [Безопасность темпоральной таблицы](../../relational-databases/tables/temporal-table-security.md)
- [Управление хранением данных журнала в темпоральных таблицах с системным управлением версиями](../../relational-databases/tables/manage-retention-of-historical-data-in-system-versioned-temporal-tables.md)
- [Представления и функции метаданных для временной таблицы](../../relational-databases/tables/temporal-table-metadata-views-and-functions.md)
