---
title: Создание поставщика связанного сервера (ядро СУБД SQL Server) | Документация Майкрософт
ms.custom: ''
ms.date: 07/01/2019
ms.prod: sql
ms.technology: ''
ms.prod_service: database-engine
ms.reviewer: MikeRayMSFT
ms.topic: conceptual
author: pmasl
ms.author: pelopes
manager: rothj
ms.openlocfilehash: 577de413c318f1f1e442ad86009a0237671e9104
ms.sourcegitcommit: ef7834ed0f38c1712f45737018a0bfe892e894ee
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/17/2019
ms.locfileid: "68301360"
---
# <a name="microsoft-sql-server-distributed-queries-ole-db-connectivity"></a>Распределенные запросы Microsoft SQL Server: подключение OLE DB

В этой статье описывается взаимодействие обработчика запросов Microsoft SQL Server с поставщиком OLE DB для обеспечения выполнения распределенных и разнородных запросов. Она предназначена в первую очередь для разработчиков поставщиков OLE DB и предполагает четкое понимание спецификации OLE DB. Основное внимание уделяется интерфейсу OLE DB между обработчиком запросов SQL Server и поставщиком OLE DB, а не самим распределенным запросам. Полное описание функции распределенных запросов см. в статье [Связанные серверы](../../relational-databases/linked-servers/linked-servers-database-engine.md).

## <a name="overview-and-terminology"></a>Общие сведения и терминология

 В Microsoft SQL Server распределенные запросы позволяют пользователям SQL Server обращаться к данным, находящимся на других серверах SQL Server или в других источниках данных, предоставляющих интерфейс OLE DB. OLE DB обеспечивает единообразный доступ к табличным данным из разнородных источников.

В этой статье распределенным запросом называется любая инструкция `SELECT`, `INSERT`, `UPDATE` или `DELETE`, которая ссылается на таблицы и наборы строк в одном или нескольких внешних источниках данных OLE DB.

Удаленная таблица — это таблица, которая хранится в источнике данных OLE DB и является внешней по отношению к серверу SQL Server, выполняющему запрос. Распределенный запрос обращается к одной или нескольким удаленным таблицам.

### <a name="ole-db-provider-categories"></a>Категории поставщиков OLE DB

Ниже приведена классификация поставщиков OLE DB в соответствии с их возможностями в плане выполнения распределенных запросов SQL Server. Категории по определению не являются взаимоисключающими. Поставщик может относиться сразу к нескольким из них.

- Поставщики команд SQL

- Поставщики индексов

- Поставщики простых таблиц

- Поставщики команд, отличных от SQL

#### <a name="sql-command-providers"></a>Поставщики команд SQL

К этой категории относятся поставщики, поддерживающие объект `Command` с диалектом стандарта SQL, который распознается SQL Server. Чтобы поставщик OLE DB определялся сервером SQL Server как поставщик команд SQL, он должен отвечать указанным ниже требованиям.

- Поставщик должен поддерживать объект `Command` и все его обязательные интерфейсы OLE DB: `ICommand`, `ICommandText`, `IColumnsInfo`, `ICommandProperties` и `IAccessor`.

- Поставщик должен поддерживать по крайней мере диалект SQL Subminimum. Поставщик должен сообщать диалект в свойстве `DBPROP_SQLSUPPORT`.

Примерами поставщиков команд SQL являются поставщик OLE DB для SQL Server (Майкрософт) и поставщик OLE DB для ODBC (Майкрософт).

#### <a name="index-providers"></a>Поставщики индексов

Поставщики индексов поддерживают индексы и предоставляют к ним доступ в соответствии со стандартом OLE DB, обеспечивая поиск базовых таблиц на основе индекса. Чтобы поставщик OLE DB определялся сервером SQL Server как поставщик индекса, он должен отвечать указанным ниже требованиям.

- Поставщик должен поддерживать интерфейс `IDBSchemaRowset` для наборов строк схем TABLES, COLUMNS и INDEXES.

- Поставщик должен поддерживать открытие набора строк на основе индекса через интерфейс `IOpenRowset` путем указания имени индекса и имени соответствующей базовой таблицы.

- Объект `Index` должен поддерживать все обязательные интерфейсы: `IRowset`, `IRowsetIndex`, `IAccessor`, `IColumnsInfo`, `IRowsetInfo` и `IConvertTypes`.

- Наборы строк, открываемые для индексированной базовой таблицы (посредством `IOpenRowset`), должны поддерживать интерфейс `IRowsetLocate` для позиционирования в строке по закладке.

Если поставщик OLE DB соответствует этим условиям, пользователи могут установить параметр поставщика `Index As Access Path`, чтобы разрешить SQL Server использовать индексы поставщика для выполнения запросов. По умолчанию SQL Server не пытается использовать индексы поставщика, если этот параметр не установлен.

>[!NOTE]
>SQL Server поддерживает различные параметры, влияющие на способ доступа SQL Server к поставщику OLE DB. Их можно настроить в диалоговом окне `Linked Server Properties` в SQL Server Enterprise Manager.

#### <a name="simple-table-providers"></a>Поставщики простых таблиц

Это поставщики, которые позволяют открывать набор строк на основе базовой таблицы через интерфейс `IOpenRowset`. Такие поставщики не являются ни поставщиками команд SQL, ни поставщиками индексов. Это простейший класс поставщиков, допускающих выполнение распределенных запросов SQL Server.

При работе с такими поставщиками во время оценки распределенных запросов SQL Server может выполнять только сканирование таблицы.

#### <a name="non-sql-command-providers"></a>Поставщики команд, отличных от SQL

К этой категории относятся поставщики, поддерживающие объект `Command` и его обязательные интерфейсы, но не поддерживающие диалект стандарта SQL, который распознается SQL Server.

Примерами поставщиков команд, отличных от SQL, являются поставщик OLE DB для службы индексирования (Майкрософт) и [поставщик OLE DB для службы Microsoft Active Directory (Майкрософт)](../../ado/guide/appendixes/microsoft-ole-db-provider-for-microsoft-active-directory-service.md).

### <a name="transact-sql-subset"></a>Подмножество Transact-SQL

Для распределенных запросов поддерживается каждый из указанных ниже классов инструкций Transact-SQL, если поставщик поддерживает необходимые интерфейсы OLE DB.

- Допускаются все инструкции `SELECT`, кроме инструкций `SELECT` INTO с удаленной таблицей в качестве конечной.

- Инструкции `INSERT` допускаются в отношении удаленных таблиц, если поставщик поддерживает интерфейсы, необходимые для вставки. Дополнительные сведения о требованиях OLE DB для инструкции INSERT см. в разделе \"Инструкция INSERT\" далее в этой статье.

- Инструкции `UPDATE` и DELETE допускаются в отношении удаленных таблиц, если поставщик соответствует требованиям интерфейса OLE DB для указанной таблицы. Требования интерфейса OLE DB и условия, при которых можно обновить или удалить удаленную таблицу, см. в разделе \"Инструкции UPDATE и DELETE\" далее в этой статье.

### <a name="cursor-support"></a>Поддержка курсоров

Для распределенных запросов поддерживаются курсоры, управляемые как моментальными снимками, так и наборами ключей, если поставщик поддерживает необходимые функциональные возможности OLE DB. Динамические курсоры не поддерживаются для распределенных запросов. Запрос динамического курсора для распределенного запроса преобразуется в запрос курсора, управляемого набором ключей.

Управляемые моментальными снимками курсоры заполняются при открытии. При этом результирующий набор остается неизменным: операции обновления, вставки и удаления, выполняемые с базовыми таблицами, не влияют на курсор.

Управляемые наборами ключей курсоры заполняются при открытии. При этом результирующий набор остается неизменным в течение всего времени существования курсора. Однако результаты операций обновления и удаления, выполняемых с базовыми таблицами, отображаются в курсоре при открытии строк. Результаты операций вставки в базовые таблицы, которые могут влиять на членство в курсоре, не отображаются.

Удаленная таблица может обновляться или удаляться посредством курсора, определенного для распределенного запроса и ссылающегося на удаленную таблицу, если поставщик соответствует условиям для обновления или удаления удаленной таблицы, например table `UPDATE` \| DELETE `<remote-table>` `WHERE` CURRENT OF `<cursor-name>`. Дополнительные сведения см. в разделе \"Инструкции UPDATE и DELETE\" далее в этой статье.

#### <a name="keyset-cursor-support-requirements"></a>Требования для поддержки курсоров, управляемых наборами ключей

Курсор, управляемый набором ключей, поддерживается в распределенном запросе, если выполняются все требования к синтаксису Transact-SQL и одно из указанных ниже условий.

- Поставщик OLE DB поддерживает многоразовые закладки во всех удаленных таблицах, указанных в запросе. Многоразовые закладки могут извлекаться из набора строк в данной таблице и использоваться в другом наборе строк той же таблицы. Поддержка многоразовых закладок определяется посредством строки схемы TABLES_INFO интерфейса `IDBSchemaRowset` путем присвоения столбцу BOOKMARK_DURABILITY уровня устойчивости BMK_DURABILITY_INTRANSACTION или более высокого уровня.

- Все удаленные таблицы предоставляют уникальный ключ посредством набора строк INDEXES интерфейса `IDBSchemaRowset`. В индексе должен быть элемент, в столбце UNIQUE которого содержится значение VARIANT_TRUE.

Курсоры, управляемые наборами ключей, не поддерживаются для распределенных запросов с функцией *OpenQuery*.

#### <a name="updatable-keyset-cursor-requirements"></a>Требования к обновляемому курсору, управляемому набором ключей

Удаленную таблицу можно обновить или удалить с помощью курсора, управляемого набором ключей, который определен в распределенном запросе, например `UPDATE` \| DELETE `<remote-table>` `WHERE` CURRENT OF `<cursor-name>`. Ниже перечислены условия, при которых обновляемые курсоры допустимы в распределенных запросах.

- Обновляемые курсоры допустимы, если поставщик также соответствует условиям для операций обновления и удаления в удаленной таблице. Дополнительные сведения см. в разделе \"Инструкции UPDATE и DELETE\" далее в этой статье.

- Все операции с обновляемым курсором, управляемым набором ключей, должны проводиться в определенной пользователем транзакции с уровнем изоляции повторяющегося чтения или более высоким. Кроме того, поставщик должен поддерживать распределенные транзакции посредством интерфейса `ITransactionJoin`.

## <a name="ole-db-provider-interaction-phases"></a>Этапы взаимодействия с поставщиком OLE DB

 Для всех сценариев выполнения распределенных запросов характерны шесть операций.

- Операции установления подключения и извлечения свойств определяют то, как SQL Server подключается к поставщику OLE DB и какие свойства поставщика используются.

- Операции разрешения имени таблицы и извлечения метаданных определяют то, как SQL Server разрешает имя удаленной таблицы (которое указывается одним из двух способов: имя на основе связанного сервера или нерегламентированное имя) в соответствующие объекты данных в поставщике. Сюда также относится получение сервером SQL Server метаданных таблицы от поставщика с целью компиляции и оптимизации распределенного запроса.

- Операции управления транзакциями определяют все действия по взаимодействию с поставщиком OLE DB посредством транзакций.

- Операции по обработке типов данных определяют то, как типы данных OLE DB обрабатываются сервером SQL Server, когда он получает данные от поставщика OLE DB или экспортирует их в поставщик во время обработки распределенного запроса.

- Операции по обработке ошибок определяют то, как сервер SQL Server использует подробные сведения об ошибках, полученные от поставщика.

- Операции, связанные с безопасностью, определяют то, как система безопасности SQL Server взаимодействует с системой безопасности поставщика.

### <a name="connection-establishment-and-property-retrieval"></a>Установление подключения и извлечение свойств

SQL Server поддерживает два соглашения об именовании удаленных объектов данных: четырехкомпонентные имена на основе связанных серверов и нерегламентированные имена на основе функции `OPENROWSET`.

#### <a name="linked-server-based-names"></a>Имена на основе связанных серверов

Связанный сервер служит абстракцией источника данных OLE DB. Имя на основе связанного сервера представляет собой четырехкомпонентное имя в следующей форме: `<linked-server>.<catalog>`. `<schema>.<object>`, где `<linked-server>` — это имя связанного сервера. SQL Server интерпретирует компонент `<linked-server>` для получения поставщика OLE DB и атрибутов подключения, которые идентифицируют источник данных для поставщика. Остальные три компонента интерпретируются источником данных OLE DB для идентификации конкретной удаленной таблицы. :::

#### <a name="ad-hoc-names"></a>Нерегламентированные имена

Нерегламентированное имя — это имя на основе функции `OPENROWSET` или `OPENDATASOURCE`. Оно включает в себя все сведения о подключении (то есть используемый поставщик OLE DB, атрибуты, необходимые для идентификации источника данных, идентификатор пользователя и пароль) при каждом обращении к удаленной таблице в распределенном запросе.

Использовать нерегламентированные имена по умолчанию разрешено только участникам роли sysadmin. Чтобы использовать нерегламентированные имена для поставщика OLE DB, необходимо присвоить параметру `DisallowAdhocAccess` поставщика значение `0`.

Если применяется имя на основе связанного сервера, SQL Server извлекает из определения связанного сервера имя поставщика OLE DB и свойства его инициализации. Если применяется нерегламентированное имя, SQL Server извлекает эти же сведения из аргументов функции `OPENROWSET`.

Подробные инструкции по настройке связанного сервера с использованием четырехкомпонентного имени и синтаксиса нерегламентированного имени см. в статье [Создание связанных серверов](create-linked-servers-sql-server-database-engine.md).

### <a name="connecting-to-an-ole-db-provider"></a>Подключение к поставщику OLE DB

Ниже описана общая последовательность действий, которые SQL Server выполняет при подключении к поставщику OLE DB.

1. SQL Server создает объект источника данных.

   SQL Server использует идентификатор `ProgID` поставщика для создания экземпляра его объекта источника данных. ProgID указывается как первый параметр `provider_name` в конфигурации связанного сервера или первый аргумент функции `OPENROWSET` в случае нерегламентированного имени.

   SQL Server создает экземпляр объекта источника данных посредством интерфейса `IDataInitialize` компонента-службы OLE DB. Это позволяет диспетчеру компонентов-служб агрегировать службы, такие как поддержка прокрутки и обновления, поверх собственной функциональности поставщика. Кроме того, создание экземпляра поставщика посредством интерфейса `IDataInitialize` позволяет компоненту-службе OLE DB объединять подключения к поставщику в пул, что сокращает некоторые временные затраты на подключение и инициализацию.

   Экземпляр поставщика может создаваться либо в одном процессе с SQL Server, либо в собственном процессе. Создание экземпляра в отдельном процессе защищает процесс SQL Server от ошибок в поставщике. Однако маршалинг вызовов OLE DB вне процесса SQL Server приводит к некоторому снижению производительности. Вы можете настроить внутрипроцессное или внепроцессное создание экземпляра поставщика, задав параметр `Allow In Process` поставщика. Дополнительные сведения см. в разделе, посвященном [настройке параметров поставщика](../../ado/guide/appendixes/microsoft-ole-db-provider-for-sql-server.md).

   Дополнительные сведения о компонентах-службах OLE DB и пулах сеансов см. в описании требований к поставщикам в документации по OLE DB.

2. Источник данных инициализируется.

   После создания объекта источника данных интерфейс `IDBProperties` задает свойство инициализации DBPROP_INIT_TIMEOUT, если параметр `remote login timeout` конфигурации сервера имеет значение больше 0. Это обязательное свойство.

   Следующие свойства задаются, если они используются явно или неявно в определении связанного сервера или во втором аргументе функции `OPENROWSET`:

   - `DBPROP_INIT_PROVIDERSTRING`

   - `DBPROP_INIT_DATASOURCE`

   - `DBPROP_INIT_LOCATION`

   - `DBPROP_INIT_CATALOG`

   - `DBPROP_AUTH_USERID`

   - `DBPROP_AUTH_PASSWORD`

   После задания этих свойств вызывается метод `IDBInitialize::Initialize` для инициализации объекта источника данных с указанными свойствами.

3. SQL Server собирает сведения о поставщике.

   SQL Server собирает несколько свойств поставщика, которые будут использоваться при оценке распределенного запроса. Их значения извлекаются с помощью метода `IDBProperties::GetProperties`. Все эти свойства являются необязательными. Однако их поддержка позволяет SQL Server использовать все возможности поставщика. Например, свойство `DBPROP_SQLSUPPORT` позволяет определить, может ли сервер SQL Server отправлять запросы поставщику. Если это свойство не поддерживается, SQL Server не будет использовать удаленный поставщик как поставщик команд SQL, даже если он им является. В приведенной ниже таблице в столбце "Значение по умолчанию" указано значение, используемой сервером SQL Server, если поставщик не поддерживает это свойство.

Свойство| Значение по умолчанию| Использовать |
|:----|:----|:----|
|`DBPROP_DBMSNAME`|None|Используется для сообщений об ошибках.|
|`DBPROP_DBMSVER` |None|Используется для сообщений об ошибках.|
|`DBPROP_PROVIDERNAME`|None|Используется для сообщений об ошибках.|
|`DBPROP_PROVIDEROLEDBVER1`|1.5|Определяет доступность возможностей версии 2.0.
|`DBPROP_CONCATNULLBEHAVIOR`|None|Определяет, совпадают ли способы объединения значений `NULL`, используемые поставщиком и сервером SQL Server.|
|`DBPROP_NULLCOLLATION`|None|Разрешает только сортировку и использование индекса, если `NULLCOLLATION` соответствует параметрам сортировки значений NULL экземпляра SQL Server.|
|`DBPROP_OLEOBJECTS`|None|Определяет, поддерживает ли поставщик интерфейсы структурированного хранилища для столбцов больших объектов данных.|
|`DBPROP_STRUCTUREDSTORAGE`|None|Определяет интерфейсы структурированного хранилища, поддерживаемые для типов больших объектов (`ILockBytes`, `Istream` и `ISequentialStream`).|
|`DBPROP_MULTIPLESTORAGEOBJECTS`|False|Определяет, можно ли одновременно открыть более одного столбца больших объектов.|
|`DBPROP_SQLSUPPORT`|None|Определяет, могут ли запросы SQL отправляться поставщику.|
|`DBPROP_CATALOGLOCATION`|`DBPROPVAL_CL_START`|Служит для построения многокомпонентных имен таблиц.
|`SQLPROP_DYNAMICSQL`|False|Свойство SQL Server. Значение `VARIANT_TRUE` означает, что маркеры параметров `?` поддерживаются при выполнении параметризированного запроса.
|`SQLPROP_NESTEDQUERIES`|False|Свойство SQL Server. Значение `VARIANT_TRUE` означает, что поставщик поддерживает вложенные инструкции `SELECT` в предложении `FROM`.
|`SQLPROP_GROUPBY`|False|Свойство SQL Server. Значение `VARIANT_TRUE` означает, что поставщик поддерживает предложение GROUP BY в инструкции `SELECT` согласно стандарту SQL-92.
|`SQLPROP_DATELITERALS `|False|Свойство SQL Server. Значение `VARIANT_TRUE` означает, что поставщик поддерживает литералы datetime согласно правилам синтаксиса Transact-SQL, принятым в SQL Server.
|`SQLPROP_ANSILIKE `|False|Свойство SQL Server. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum и оператор `LIKE` в соответствии с уровнем Entry Level стандарта SQL-92 (подстановочные знаки \'%\' и \'_\').
|`SQLPROP_SUBQUERIES `|False|Свойство SQL Server. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Указывает на то, что поставщик поддерживает вложенные запросы в соответствии с уровнем Entry Level стандарта SQL-92. Сюда относятся вложенные запросы в списке `SELECT` и в предложении `WHERE` с поддержкой связанных вложенных запросов, а также операторов `IN`, `EXISTS`, `ALL` и `ANY`.
|`SQLPROP_INNERJOIN`|False|Свойство SQL Server. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Указывает на поддержку объединения нескольких таблиц в предложении `FROM`. ------ ---

Метод `IDBInfo::GetLiteralInfo` возвращает следующие три литерала: `DBLITERAL_CATALOG_SEPARATOR`, `DBLITERAL_SCHEMA_SEPARATOR` (для формирования полного имени объекта из имен каталога, схемы и объекта) и `DBLITERAL_QUOTE` (для заключения имен идентификаторов в SQL-запросе, отправляемом поставщику, в кавычки).

Если поставщик не поддерживает литералы-разделители, SQL Server использует точку (.) в качестве знака разделения по умолчанию. Если поставщик поддерживает только знак разделения каталога, но не знак разделения схемы, SQL Server использует знак разделения каталога в качестве знака разделения схемы. Если поставщик не поддерживает литерал `DBLITERAL_QUOTE`, SQL Server использует символ одиночной кавычки (`'`).

>[!NOTE]
>Если литералы-разделители имен поставщика не соответствуют этим значениям по умолчанию, поставщик должен сообщить их через интерфейс `IDBInfo`, чтобы сервер SQL Server мог обращаться к таблицам поставщика по четырехкомпонентным именам. Если эти литералы не сообщаются, для поставщика можно использовать только запросы к серверу.

Сведения о предоставлении свойств `SQLPROP_DYNAMICSQL` и `SQLPROP_NESTEDQUERIES` см. в разделе [Свойства SQL Server](#appendixc).

### <a name="table-name-resolution-and-meta-data-retrieval"></a>Разрешение имени таблицы и извлечение метаданных

SQL Server разрешает имя удаленной таблицы в распределенном запросе в определенную таблицу или представление в источнике данных OLE DB. Схемы именования как на основе связанного сервера, так и на основе нерегламентированного имени предполагают интерпретацию трехкомпонентного имени поставщиком. В случае с именем на основе связанного сервера три последних компонента четырехкомпонентного имени определяют имена каталога, схемы и объекта. В случае с нерегламентированным именем в третьем аргументе функции `OPENROWSET` указывается трехкомпонентное имя, которое определяет имена каталога, схемы и объекта. Имена каталога и схемы могут быть пустыми. (Четырехкомпонентное имя с пустыми именами каталога и схемы будет выглядеть так: `<server-name>...<object-name>`.) В таком случае SQL Server использует `NULL` как соответствующее значение для поиска в таблицах набора строк схемы.

Правила разрешения имен и действия по извлечению метаданных, применяемые сервером SQL Server, зависят от того, поддерживает ли поставщик интерфейс `IDBSchemaRowset` объекта `Session`.

Если интерфейс `IDBSchemaRowset` поддерживается, наборы строк схемы `TABLES`, `COLUMNS`, `INDEXES` и `TABLES_INFO` используются из интерфейса `IDBSchemaRowset`. (Набор строк схемы `TABLES_INFO` определен в OLE DB 2.0.) В SQL Server наборы строк схемы, возвращаемые интерфейсом `IDBSchemaRowset`, ограничиваются: выполняется поиск строк схемы, которые соответствуют указанным компонентам имени удаленной таблицы. Ниже описываются правила, которые связаны с ограничениями, поддерживаемыми поставщиком для наборов строк схемы, и то, как SQL Server использует их для получения метаданных удаленной таблицы.

- Ограничения для столбцов `TABLE_NAME` и `COLUMN_NAME` являются обязательными.

- Если поставщик поддерживает ограничение для `TABLE_CATALOG` (или `TABLE_SCHEMA`), SQL Server использует это ограничение для `TABLE_CATALOG` (или `TABLE_SCHEMA`). Если имя каталога (или схемы) не указано в имени удаленной таблицы, значение `NULL` применяется в качестве соответствующего значения ограничения. Если имя каталога (или схемы) указано, поставщик должен поддерживать соответствующее ограничение для `TABLE_CATALOG` (или `TABLE_SCHEMA`).

- Поставщик должен поддерживать ограничение для столбца `TABLE_SCHEMA` либо в обоих наборах строк `TABLES` и `COLUMNS`, либо ни в одном из них. Поставщик должен поддерживать ограничение имени каталога либо в обоих наборах строк `TABLES` и `COLUMNS`, либо ни в одном из них.

- Если для набора строк INDEXES поддерживаются какие-либо ограничения, поставщик должен поддерживать ограничение схемы либо в обоих наборах строк `TABLES` и INDE`XES or support them on neither. The provider must either support catalog name restriction on both `TABLES` and `INDEXES, либо ни в одном из них.

Из набора строк схемы `TABLES` SQL Server извлекает столбцы `TABLE_CATALOG`, `TABLE_SCHEMA`, `TABLE_NAME`, `TABLE_TYPE` и `TABLE_GUID`, задавая ограничения в соответствии с указанными выше правилами.

Из набора строк схемы `COLUMNS` SQL Server извлекает столбцы `TABLE_CATALOG`, `TABLE_SCHEMA`, `TABLE_NAME`, `COLUMN_NAME`, `COLUMN_GUID`, `ORDINAL_POSITION`, `COLUMN_FLAGS`, `IS_NULLABLE`, `DATA_TYPE`, `TYPE_GUID`, `CHARACTER_MAXIMUM_LENGTH`, `NUMERIC_PRECISION` и `NUMERIC_SCALE`. `COLUMN_NAME`, `DATA_TYPE` и `ORDINAL_POSITION` должны возвращать допустимые значения, отличные от NULL. Если столбец `DATA_TYPE` содержит значение `DBTYPE_NUMERIC` или `DBTYPE_DECIMAL`, соответствующие столбцы `NUMERIC_PRECISION` и `NUMERIC_SCALE` должны содержать допустимые значения, отличные от NULL.

Из необязательного набора строк схемы `INDEXES` SQL Server ищет индексы в указанной удаленной таблице, задавая ограничения в соответствии с ранее описанными правилами. Из найденных соответствующих элементов индекса SQL Server извлекает столбцы `TABLE_CATALOG`, `TABLE_SCHEMA`, `TABLE_NAME`, `INDEX_CATALOG`, `INDEX_SCHEMA`, `INDEX_NAME`, `PRIMARY_KEY`, `UNIQUE`, `CLUSTERED`, `FILL_FACTOR`, `ORDINAL_POSITION`, `COLUMN_NAME`, `COLLATION`, `CARDINALITY` и `PAGES`.

В необязательном наборе строк `TABLES_INFO` SQL Server ищет дополнительные сведения об указанной удаленной таблице, например о поддержке закладок, их типе и длине. Используются все столбцы, кроме столбца `DESCRIPTION` набора строк `TABLES_INFO`. Сведения в наборе строк `TABLES_INFO` используются следующим образом:

- Столбец `BOOKMARK_DURABILITY` применяется для реализации более эффективных курсоров, управляемых наборами ключей. Если этот столбец содержит значение `BMK_DURABILITY_INTRANSACTION` или более высокое значение устойчивости, SQL Server использует извлечение и обновление на основе закладок для строк удаленной таблицы, чтобы реализовать курсор, управляемый набором ключей.

- Столбцы `BOOKMARK_TYPE`, `BOOKMARK_DATA TYPE` и `BOOKMARK_MAXIMUM_LENGTH` применяются для определения метаданных закладок во время компиляции запроса. Если эти столбцы не поддерживаются, SQL Server открывает набор строк базовой таблицы посредством интерфейса `IOpenRowset` во время компиляции, чтобы получить сведения о закладках.

Если интерфейс `IDBSchemaRowset` не поддерживается и имя удаленной таблицы включает в себя имя каталога или схемы, SQL Server возвращает ошибку, так как интерфейс `IDBSchemaRowset` необходим. Однако если не указано ни имя каталога, ни имя схемы, SQL Server открывает набор строк, соответствующий удаленной таблице, и извлекает метаданные столбца посредством обязательного интерфейса `IColumnsInfo` объекта набора строк.

SQL Server открывает набор строк, соответствующий таблице, вызывая метод `IOpenRowset::OpenRowset`. Имя таблицы, передаваемое в метод `OPENROWSET`, формируется из имен каталога, схемы и объекта.

- Каждый компонент имени (`catalog`, `schema`, `object name`) заключается в кавычки с использованием символа кавычек поставщика (`DBLITERAL_QUOTE`), после чего компоненты сцепляются с добавлением символов `DBLITERAL_CATALOG_SEPARATOR` и `DBLITERAL_SCHEMA_SEPARATOR` между ними. Имя строится согласно правилам OLE DB в `IOpenRowset`.

- Метаданные столбца для таблицы извлекаются с помощью метода `IColumnsInfo::GetColumnInfo` после открытия объекта набора строк.

Если интерфейс `IDBSchemaRowset` не поддерживается для наборов строк TABLES, COLUMNS и TABLES_INFO, SQL Server открывает набор строк для базовой таблицы два раза: один раз во время компиляции запроса для получения метаданных и еще раз — во время выполнения запроса. Поставщики, для которых открытие набора строк вызывает побочные эффекты (например, выполнение кода, который изменяет состояние устройства в реальном времени, отправка сообщения электронной почты или выполнение произвольного кода, предоставленного пользователем), должны учитывать эту особенность.

### <a name="statistics-retrieval"></a>Получение статистики

Если поставщик поддерживает статистику распределения в базовых таблицах, SQL Server будет использовать эти статистические данные. Для обработчика запросов SQL Server представляют интерес статистические данные двух типов.

- **Кратность столбцов (или кортежей)** . Это количество уникальных значений, содержащихся в столбце (или сочетании столбцов) таблицы. Оно позволяет оценить избирательность предикатов по столбцам. Для поддержки статистики распределения поставщик должен поддерживать по крайней мере один тип кратности.

- **Гистограммы**. Если распределение значений неоднородно, количества уникальных значений недостаточно для точной оценки избирательности предикатов. В этом случае может быть предоставлена гистограмма, содержащая более детальные сведения о распределении значений столбцов в таблице.

Если статистика доступна, оптимизатор запросов SQL Server может лучше оценить кратность промежуточных операций запроса, что позволяет построить для них более эффективные планы выполнения.

Поставщик OLE DB должен обеспечивать следующую поддержку статистики распределения:

- **Обязательно**. Поддержка свойства (1) `DBPROP_TABLESTATISTICS`, которое указывает, поддерживается ли кратность столбцов или кортежей и поддерживаются ли гистограммы, и свойства (2) `DBPROP_OPENROWSETSUPPORT`, которое с помощью бита `DBPROPVAL_ORS_HISTOGRAM` указывает, поддерживаются ли гистограммы.

- **Обязательно**. Набор строк схемы `TABLE_STATISTICS`. В наборе строк схемы `TABLE_STATISTICS` перечислены данные статистики, доступные в этой базе данных. В нем также содержится кратность столбцов и кортежей и указывается, поддерживаются ли гистограммы для отдельных столбцов. Чтобы сервер SQL Server мог использовать статистику, в этом наборе строк схемы должны присутствовать столбцы `TABLE_NAME`, `STATISTICS_NAME`, `STATISTICS_TYPE`, `COLUMN_NAME` и `ORDINAL_POSITION`. Обязателен по крайней мере один из следующих столбцов: `COLUMN_CARDINALITY` или `TUPLE_CARDINALITY`. Если гистограммы поддерживаются, столбец `NO_OF_RANGES` также обязателен.

- **Необязательно**. Если поставщик поддерживает гистограммы, он также должен поддерживать расширение метода `IOpenRowset::OpenRowset`, которое позволяет открывать набор строк гистограммы путем указания идентификатора `DBID` соответствующей статистики.

Полные сведения об интерфейсах статистики см. в спецификации OLE DB 2.6.

### <a name="constraints"></a>Ограничения

Оптимизатор запросов SQL Server также использует ограничения `CHECK`, определенные в базовых таблицах удаленного источника данных, если поставщик OLE DB поддерживает набор строк схемы OLE DB 2.6 `CHECK_CONSTRAINTS_BY_TABLE`. Столбец `CHECK_CLAUSE` набора строк схемы должен возвращать предикат предложения `CHECK` с использованием синтаксиса, совместимого со стандартом SQL-92. Оптимизатор запросов использует сведения об ограничениях для исключения или упрощения предикатов, которые, как известно, всегда имеют значение false или true из-за применения ограничения CHECK к таблице.

### <a name="transaction-management"></a>Управление транзакциями

SQL Server поддерживает доступ к распределенным данным на основе транзакций с помощью интерфейсов OLE DB `ITransactionLocal` (для локальных транзакций) и `ITransactionJoin` (для распределенных транзакций) поставщика. Инициируя локальную транзакцию применительно к поставщику, SQL Server обеспечивает выполнение атомарных операций записи. При использовании распределенных транзакций SQL Server обеспечивает одинаковый результат (фиксация или откат) во всех узлах для транзакции, включающей в себя несколько узлов. Если поставщик не поддерживает требуемые интерфейсы OLE DB, связанные с транзакциями, операции обновления для этого поставщика запрещаются в зависимости от локального контекста транзакции.

В таблице ниже описывается, что происходит, когда пользователь выполняет распределенный запрос, с учетом возможностей поставщика и локального контекста транзакции. Под операцией чтения в поставщике понимается либо инструкция `SELECT`, либо считывание удаленной таблицы во входную часть инструкции `SELECT INTO`, `INSERT`, `UPDATE` или `DELETE`. Под операцией записи в поставщике понимается инструкция `INSERT`, `UPDATE` или `DELETE` с удаленной таблицей в качестве конечной.

Результаты распределенного запроса в зависимости от возможностей поставщика и контекста транзакции:

|Где происходит распределенный запрос|Поставщик не поддерживает `ITransactionLocal`|Поставщик поддерживает `ITransactionLocal`, но не `ITransactionJoin`|Поставщик поддерживает как `ITransactionLocal`, так и `ITransactionJoin`|
|:-----|:-----|:-----|:-----|
| В самой транзакции (без пользовательской транзакции).|По умолчанию разрешены только операции чтения. Если включен параметр `Nontransacted Updates` на уровне поставщика, разрешены операции записи. (Когда этот параметр включен, SQL Server не может гарантировать атомарность и целостность данных поставщика. Это может привести к тому, что в удаленном источнике данных результаты операции записи будут отражены частично и отменить их будет невозможно.)| Применительно к удаленным данным допустимы любые инструкции. Курсоры, управляемые наборами ключей, доступны только для чтения. Локальная транзакция начинается в поставщике с текущим уровнем изоляции сеанса SQL Server и фиксируется по успешном завершении вычисления инструкции. (Уровень изоляции по умолчанию для сеанса SQL Server — `READ COMMITTED`, если он не был изменен с помощью инструкции `SET TRANSACTION ISOLATION LEVEL`. Поставщик должен поддерживать запрошенный уровень изоляции.) | Допустимы все инструкции. Курсоры, управляемые наборами ключей, доступны только для чтения. Локальная транзакция начинается в поставщике с текущим уровнем изоляции сеанса SQL Server и фиксируется по успешном завершении вычисления инструкции. |
| В пользовательской транзакции (то есть между `BEGIN TRAN` или `BEGIN DISTRIBUTED TRAN` и `COMMIT`). | Если уровень изоляции транзакции — `READ COMMITTED` (по умолчанию) или ниже, допустимы операции чтения. Если уровень изоляции выше, распределенные запросы не допускаются. | Разрешены только операции чтения. Распределенные транзакции начинаются в поставщике с текущим уровнем изоляции сеанса SQL Server. |Допустимы все инструкции. Распределенная транзакция начинается в поставщике с текущим уровнем изоляции сеанса SQL Server и фиксируется при фиксации пользовательской транзакции. Для инструкций изменения SQL Server по умолчанию запускает вложенную транзакцию в рамках распределенной транзакции, чтобы при возникновении некоторых ошибок выполнение инструкции изменения данных можно было остановить, не останавливая содержащую транзакцию. Если включен параметр `XACT_ABORT SET`, SQL Server не требует поддержки вложенных транзакций и останавливает содержащую транзакцию в случае возникновения ошибок во время выполнения инструкции изменения данных. |
|  |  |  |

### <a name="data-type-handling-in-distributed-queries"></a>Обработка типов данных в распределенных запросах

Поставщики OLE DB предоставляют данные с использованием типов данных, определенных в OLE DB (обозначаются префиксом `DBTYPE`). На сервере SQL Server внешние данные обрабатываются как собственные типы SQL Server. По этой причине при получении данных сервером SQL Server или их экспорте происходит сопоставление типов данных OLE DB с собственными типами SQL Server и наоборот. Такое сопоставление производится неявно, если не указано иное.

Типы данных в распределенных запросах обрабатываются с использованием одного из двух методов сопоставления.

- Типы данных OLE DB сопоставляются с собственными типами данных SQL Server на получающей стороне, когда удаленные таблицы указываются в инструкциях `SELECT` или во входной части инструкций INSERT, UPDATE и DELETE.

- Типы данных SQL Server сопоставляются с типами данных OLE DB на стороне экспорта, когда удаленная таблица указывается в инструкции `INSERT` или `UPDATE` как конечная.

Таблица сопоставления типов данных SQL Server и OLE DB

| Тип OLE DB | `DBCOLUMNFLAG` | Тип данных SQL Server |
|-----|-----|-----|
|`DBTYPE_I1`*| |`numeric(3, 0)`|
|`DBTYPE_I2`| |`smallint`|
|`DBTYPE_I4`| |`int`|
|`DBTYPE_I8`| |`numeric(19,0)`|
|`DBTYPE_UI1`| |`tinyint`|
|`DBTYPE_UI2`*| |`numeric(5,0)`|
|`DBTYPE_UI4`*| |`numeric(10,0)`|
|`DBTYPE_UI8`*| |`numeric(20,0)`|
|`DBTYPE_R4`| |`float`|
|`DBTYPE_R8`| |`real`|
|`DBTYPE_NUMERIC`| |`numeric`|
|`DBTYPE_DECIMAL`| |`decimal`|
|`DBTYPE_CY`| |`money`|
|`DBTYPE_BSTR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true`<br>или диспетчер конфигурации служб<br> Максимальная длина > 4000 символов|ntext|
|`DBTYPE_BSTR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true`|NCHAR|
|`DBTYPE_BSTR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=false`|NVARCHAR|
|`DBTYPE_IDISPATCH`| |Ошибка|
|`DBTYPE_ERROR`| |Ошибка|
|`DBTYPE_BOOL`| |`bit`|
|`DBTYPE_VARIANT`*| |NVARCHAR|
|`DBTYPE_IUNKNOWN`| |Ошибка|
|`DBTYPE_GUID`| |`uniqueidentifier`|
|`DBTYPE_BYTES`|`DBCOLUMNFLAGS_ISLONG=true` <br>или диспетчер конфигурации служб<br> Максимальная длина > 8000|`image`|
|`DBTYPE_BYTES`|`DBCOLUMNFLAGS_ISROWVER=true`, `DBCOLUMNFLAGS_ISFIXEDLENGTH=true`, размер столбца = 8 <br>или диспетчер конфигурации служб<br> Максимальная длина не сообщается. | `timestamp` |
|`DBTYPE_BYTES`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true` | `binary` |
|`DBTYPE_BYTES`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true` | `varbinary`|
|`DBTYPE_STR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true` | `char`|
|`DBTYPE_STR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true` | `varchar` |
|`DBTYPE_STR`| `DBCOLUMNFLAGS_ISLONG=true` <br>или диспетчер конфигурации служб<br> Максимальная длина > 8000 символов <br>или диспетчер конфигурации служб<br>   Максимальная длина не сообщается. | `text`|
|`DBTYPE_WSTR`| `DBCOLUMNFLAGS_ISFIXEDLENGTH=true` |`nchar`|
|`DBTYPE_WSTR` | `DBCOLUMNFLAGS_ISFIXEDLENGTH=false`|`nvarchar`|
|`DBTYPE_WSTR`| `DBCOLUMNFLAGS_ISLONG=true` <br>или диспетчер конфигурации служб<br> Максимальная длина > 4000 символов <br>или диспетчер конфигурации служб<br>   Максимальная длина не сообщается. | `ntext`|
|`DBTYPE_UDT`| |Ошибка|
|`DBTYPE_DATE`* | | `datetime` |
|`DBTYPE_DBDATE` | | `datetime` (требуется явное преобразование)|
|`DBTYPE_DBTIME`| | `datetime` (требуется явное преобразование)|
|`DBTYPE_DBTIMESTAMP`* | | `datetime`|
|`DBTYPE_ARRAY` | |Ошибка|
|`DBTYPE_BYREF` | | Не учитывается |
|`DBTYPE_VECTOR` | |Ошибка|
|`DBTYPE_RESERVED`| |Ошибка|

\* Укажите какое-либо преобразование в представление типа SQL Server, так как точного эквивалента этого типа данных в SQL Server нет. Преобразование может привести к потере точности, переполнению или потере значимости. Неявные сопоставления по умолчанию могут измениться в будущем, если соответствующие типы данных станут поддерживаться в будущих версиях SQL Server.

>[!NOTE]
>`numeric(p,s)` указывает на тип данных SQL Server `numeric` с точностью `p` и масштабом `s`. Максимальная допустимая точность для `DBTYPE_NUMERIC` и `DBTYPE_DECIMAL` равна 38. Поставщик должен поддерживать привязку к столбцу `DBTYPE_BSTR` как к `DBTYPE_WSTR` при создании метода доступа. Столбцы `DBTYPE_VARIANT` используются как строки символов Юникода `nvarchar`. Для этого поставщик должен поддерживать преобразование `DBTYPE_VARIANT` в `DBTYPE_WSTR`. Это преобразование должно реализовываться согласно определению в спецификации OLE DB. Дополнительные сведения см. в [списке типов данных, определенных в спецификации OLE DB](#appendixa).

#### <a name="interpreting-data-type-mapping"></a>Интерпретация сопоставления типов данных

Сопоставление с типом SQL Server определяется типом данных OLE DB и значениями DBCOLUMNFLAGS, которые описывают значение столбца или скаляра. В случае с набором строк схемы `COLUMNS` эти значения представлены столбцами `DATA_TYPE` и `COLUMN_FLAGS`. В случае с интерфейсом `IColumnsInfo::GetColumnInfo` эти сведения представлены элементами `wType` и `dwFlags` структуры `DBCOLUMNINFO`.

Чтобы использовать сопоставление на получающей стороне для столбца с определенными значениями `DBTYPE` и `DBCOLUMNFLAG`, найдите соответствующий тип SQL Server в таблице. Правила типов для столбцов из удаленных таблиц в выражениях можно описать так:

>Значение удаленного столбца допустимо в выражении языка Transact-SQL, если соответствующий сопоставленный тип данных SQL Server в таблице является допустимым в этом контексте.

Таблица и правило определяют следующее:

- Сравнения и выражения.

В общем случае `X <op> <remote-column>` является допустимым выражением, если `<op>` — это допустимый оператор для типа данных `X` и типа данных, с которым сопоставляется `<remote-column>`.

- Явные преобразования.

`Convert(X, <remote-column>)` допустимо, если тип `DBTYPE` столбца `<remote-column>` сопоставляется с собственным типом данных `Y` (согласно приведенной выше таблице) и допустимо явное преобразование `Y` в `X`.

Если пользователю необходимо преобразовать удаленные данные в нестандартный собственный тип данных, требуется явное преобразование.

Чтобы использовать сопоставление на стороне экспорта в случае с инструкциями `UPDATE` и `INSERT`, применяемыми к удаленным таблицам, необходимо сопоставить собственные типы данных SQL Server с типами данных OLE DB по той же таблице. Сопоставление типа SQL Server `S1` с определенным типом OLE DB `T` допустимо, если выполняется одно из указанных ниже условий.

- Соответствующее сопоставление может быть найдено непосредственно в таблице сопоставлений.

- Существует допустимое неявное преобразование типа `S1` в другой тип SQL Server `S2`, причем тип `S2` сопоставляется с типом `T` в таблице сопоставлений.

#### <a name="large-object-lob-handling"></a>Обработка больших объектов (LOB)

Как указано в таблице сопоставлений, если столбец типа `DBTYPE_STR`, `DBTYPE_WSTR` или `DBTYPE_BSTR` также имеет значение `DBCOLUMNFLAGS_ISLONG` или если его максимальная длина превышает 4000 символов (либо если максимальная длина не сообщается), SQL Server интерпретирует его как столбец `text` или `ntext`. Аналогичным образом, если столбец `DBTYPE_BYTES` имеет значение `DBCOLUMNFLAGS_ISLONG` или если его максимальная длина превышает 8000 байтов (либо не сообщается), он интерпретируется как столбец `image`. Столбцы `Text`, `ntext` и `image` называются столбцами больших объектов (LOB).

Для больших объектов, полученных от поставщика OLE DB, SQL Server предоставляет не все функции работы с текстами и изображениями. Для таких объектов не поддерживаются функции `TEXTPTRS`, поэтому также не поддерживаются все связанные с ними возможности, такие как системная функция `TEXTPTR`, а также инструкции `READTEXT`, `WRITETEXT` и `UPDATETEXT`. Инструкции `SELECT`, извлекающие целые столбцы LOB, поддерживаются, так же как и инструкции `UPDATE` и `INSERT` для целых столбцов больших объектов в удаленных таблицах.

SQL Server использует интерфейсы структурированного хранилища для столбцов LOB, если их поддерживает поставщик. Интерфейсы структурированного хранилища в порядке повышения приоритета и функциональности следуют так: `ISequentialStream`, `Istream` и `ILockBytes`. Если поддерживается хотя бы один из них, поставщик должен возвращать DBPROPVAL_OO_BLOB в качестве значения свойства `DBPROP_OLEOBJECTS` при его запросе через интерфейс `IDBProperties`. Кроме того, поставщик должен сообщать поддерживаемые интерфейсы в свойстве `DBPROP_STRUCTUREDSTORAGE`.

Если поставщик не поддерживает ни один интерфейс структурированного хранилища для столбцов LOB, SQL Server материализует такой интерфейс самостоятельно и предоставляет эти столбцы как `text`, `ntext` или `image`.

#### <a name="accessing-lob-columns"></a>Доступ к столбцам LOB

Если поставщик поддерживает один из интерфейсов структурированного хранилища, SQL Server выполняет указанные ниже действия для получения столбцов LOB во время выполнения запроса.

1. Перед открытием набора строк с помощью метода `IOpenRowset::OpenRowset` SQL Server запрашивает интерфейсы структурированного хранилища (`ISequentialStream`, `Istream` и `ILockBytes`), поддерживаемые для столбцов больших объектов. Первый интерфейс, поддерживаемый поставщиком, является обязательным. Дополнительные интерфейсы запрашиваются, если они \"не требуют много ресурсов\". Для этого элементу *dwOptions* соответствующей структуры DBPROP присваивается значение DBPROPOPTIONS_SETIFCHEAP. Например, если поставщик поддерживает как интерфейс `ISequentialStream`, так и интерфейс `ILockBytes`, `ISequentialStream` является обязательным, а `ILockBytes` используется, если \"не требует много ресурсов\".

4. После открытия набора строк SQL Server определяет, какие именно интерфейсы доступны в нем, с помощью метода `IRowsetInfo::GetProperties`. Используется последний или наиболее предпочтительный интерфейс, возвращенный поставщиком. Когда SQL Server создает метод доступа к столбцу больших объектов, столбец привязывается как DBTYPE_IUNKNOWN, причем элементу *iid* структуры DBOBJECT в привязке присваивается интерфейс.

#### <a name="reading-from-lob-columns"></a>Чтение данных из столбцов LOB

Для чтения данных из столбца больших объектов используйте указатель на запрошенный интерфейс структурированного хранилища, возвращенный в буфере строк из `IRowset::GetData`. Если поставщик не поддерживает несколько одновременно открытых объектов LOB (то есть не поддерживает `DBPROP_MULTIPLE_STORAGEOBJECTS`) и строка имеет несколько столбцов больших объектов, SQL Server копирует столбцы LOB в локальную рабочую таблицу.

#### <a name="update-and-insert-statements-on-lob-columns"></a>Использование инструкций `UPDATE` и `INSERT` со столбцами LOB

SQL Server передает поставщику указатель на новый объект хранилища вместо использования предоставляемого поставщиком интерфейса для изменения объекта хранилища. Для каждого столбца LOB значение, которое обновляется или вставляется в объект хранилища, создается с помощью выбранного интерфейса структурированного хранилища. В зависимости от типа операции (`UPDATE` или `INSERT`) указатель на объект хранилища передается поставщику через `IRowsetChange::SetData` или `IRowsetChange::InsertRow` соответственно.

### <a name="error-handling"></a>Обработка ошибок

Когда вызов метода применительно к поставщику OLE DB возвращает код ошибки, SQL Server ищет расширенные сведения об ошибке поставщика перед возвратом пользователю сведений о состоянии ошибки.

SQL Server использует объект ошибки OLE DB, определенный в спецификации OLE DB. Ниже описывается общий порядок действий.

1. Когда вызов метода возвращает код ошибки от поставщика, SQL Server ищет интерфейс `ISupportErrorInfo`. Если этот интерфейс поддерживается, SQL Server вызывает `ISupportErrorInfo::InterfaceSupportsErrorInfo`, чтобы проверить, поддерживаются ли объекты ошибок интерфейсом, выдавшим код ошибки.

<!-- -->

5. Если интерфейс поддерживает объекты ошибок, SQL Server вызывает функцию `GetErrorInfo`, чтобы получить указатель интерфейса `IErrorInfo` для текущего объекта ошибки.

6. SQL Server использует интерфейс `IErrorInfo` для получения указателя на интерфейс `IErrorRecords`.

7. SQL Server использует `IErrorRecords` для перебора всех записей об ошибках в объекте и получения текста сообщения об ошибке, соответствующего каждой записи.

Дополнительные сведения об использовании объекта-ошибки поставщика см. в документации по OLE DB.

### <a name="security"></a>безопасность

Когда объект-получатель подключается к поставщику OLE DB, поставщик обычно требует идентификатор пользователя и пароль, если только объект-получатель не хочет пройти проверку подлинности в качестве встроенного пользователя безопасности. В случае распределенных запросов SQL Server выступает в качестве объекта-получателя поставщика OLE DB с учетными данными SQL Server, используемыми для выполнения распределенного запроса. SQL Server сопоставляет текущие учетные данные SQL Server с идентификатором пользователя и паролем на связанном сервере.

Эти сопоставления могут указываться пользователем для данного связанного сервера и могут настраиваться и управляться системными хранимыми процедурами `sp_addlinkedsrvlogin` и `sp_droplinkedsrvlogin`. В результате задания свойств группы инициализации DBPROP_AUTH_USERID и DBPROP_AUTH_PASSWORD с помощью метода `IDBProperties::SetProperties` идентификатор пользователя и пароль, определяемые сопоставлением, передаются поставщику во время установки соединения.

Если клиент подключается к SQL Server с использованием проверки подлинности Windows и если для учетных данных настроено сопоставление `self` с помощью `sp_addlinkedsrvlogin`, SQL Server пытается олицетворить контекст безопасности клиента и задает свойство `DBPROP_AUTH_INTEGRATED` в поставщике во время установки соединения. Этот процесс называется *делегированием*.

После определения контекста безопасности, используемого для соединения, проверка подлинности этого контекста безопасности и проверка разрешений на объекты данных в источнике данных для этого контекста полностью зависит от поставщика OLE DB.

Дополнительные сведения см. в разделах [`sp_addlinkedsrvlogin`](../../relational-databases/system-stored-procedures/sp-addlinkedserver-transact-sql.md) и [`sp_droplinkedsrvlogin`](../../relational-databases/system-stored-procedures/sp-droplinkedsrvlogin-transact-sql.md).

## <a name="query-execution-scenarios"></a>Сценарии выполнения запросов

 При вычислении распределенного запроса возможны следующие сценарии взаимодействия SQL Server с поставщиком OLE DB:

- удаленный запрос;

- доступ к индексам;

- сканирование таблицы;

- инструкции `UPDATE` и DELETE;

- инструкция `INSERT`

- транзитные запросы.

### <a name="remote-query"></a>Remote Query

SQL Server создает SQL-запрос, вычисляющий часть исходного запроса, который может быть полностью вычислен поставщиком. Этот сценарий возможен только для поставщиков команд SQL. Степень, в которой SQL Server перелагает выполнение операций на поставщик путем создания SQL-запроса, зависит от грамматики SQL, поддерживаемой поставщиком. Поставщик должен указать уровень поддержки SQL одним из указанных ниже способов.

1. Путем указания уровня поддержки SQL Minimum, ODBC Core или SQL-92 Entry Level в свойстве `DBPROP_SQLSUPPORT`. Уровень синтаксиса SQL Minimum — это новый уровень, поддерживаемый в SQL Server, который позволяет SQL Server отправлять удаленные запросы простым поставщикам, поддерживающим простое подмножество SQL. Этот уровень включает в себя базовую инструкцию `SELECT` без вложенных запросов, несколько таблиц в предложении `FROM` (без соединений) и GROUP BY. Сведения о подмножестве грамматики SQL, используемой SQL Server для создания удаленных запросов к поставщикам каждого из этих уровней синтаксиса, см. в разделе [Подмножество SQL, используемое для создания удаленных запросов](#appendixb).

1. С помощью различных свойств SQL Server, используемых для указания поддержки отдельных функций SQL, которые не включены в уровень синтаксиса, передаваемый в свойстве DBPROP_SQLSUPPORT. Список свойств и описание их использования в SQL Server приводятся далее в этом разделе.

SQL Server использует выполнение параметризированного запроса с вопросительным знаком (?) в качестве маркера параметра в строке Transact-SQL. Выполнение параметризированных запросов используется для поставщиков OLE DB SQL Server, Microsoft Jet и Oracle. Для других поставщиков выполнение параметризированных запросов используется, если поставщик поддерживает интерфейс `ICommandWithParameters` объекта `Command` и соблюдается по крайней мере одно из указанных ниже условий.

- Поставщик сообщает о поддержке уровня ODBC Core SQL Server посредством свойства `DBPROP_SQLSUPPORT`.

- Поставщик поддерживает маркер параметра в виде вопросительного знака (?), о чем свидетельствует поддержка свойства SQL Server SQLPROP_DYNCMICSQL интерфейса `IDBPProperties`. Дополнительные сведения см. в следующем разделе, посвященном свойствам поставщика.

- Администратор задает параметр поставщика `Dynamic Parameters`, чтобы SQL Server создавал параметризированные запросы.

Когда SQL Server создает текст SQL для удаленного выполнения, имена таблиц и столбцов заключаются в кавычки с использованием символа, указанного поставщиком посредством литерала `DBLITERAL_QUOTE` интерфейса `IDBInfo`. Если этот литерал не поддерживается, имена таблиц и столбцов не заключаются в кавычки.

Если поставщик поддерживает выполнение параметризированных запросов, SQL Server оценивает соединение удаленной таблицы с локальной таблицей на основе стратегии выполнения параметризированных запросов. Параметризированный запрос выполняется повторно для значений параметров, созданных из каждой строки локальной таблицы. Такая стратегия сокращает количество строк, получаемых от поставщика, и выгодна, когда локальная таблица с небольшим числом строк соединяется с удаленной таблицей с большим количеством строк. Эту стратегию удаленного соединения можно применить с помощью указания оптимизатора соединений `REMOTE`. Дополнительные сведения о выполнении параметризированных запросов см. в статье [Практическое руководство. Выполнение параметризованных запросов](../../connect/php/how-to-perform-parameterized-queries.md).

Ниже представлены общие действия, выполняемые применительно к поставщику в сценарии удаленного запроса.

1. SQL Server создает объект `Command` на основе объекта `Session` с помощью `IDBCreateCommand::CreateCommand`.

9. Если параметр конфигурации сервера `Remote Query Timeout` имеет значение >` 0, SQL Server sets the DBPROP_COMMANDTIMEOUT property on the `Command` object to the same value by using `ICommandProperties::SetProperties`; `ICommand::SetCommandText`, должен быть вызван Transact-SQL для созданной строки в качестве текста команды.

10. SQL Server вызывает `ICommandPrepare::Prepare` для подготовки команды. Если поставщик не поддерживает этот интерфейс, SQL Server переходит к шагу 4.

11. Если созданный запрос является параметризированным, SQL Server использует `ICommandWithParameters::SetParameterInfo` для описания параметров и `IAccessor::CreateAccessor` для создания методов доступа для параметров.

12. SQL Server вызывает `ICommand::Execute` для выполнения команды и создания набора строк.

13. SQL Server использует интерфейс `IRowset` для перехода к строкам таблицы и их использования. Используйте `IRowset::GetNextRows` для получения строк, `IRowset::RestartPosition` для возврата к началу набора строк и `IRowset::ReleaseRows` для высвобождения строк.

#### <a name="provider-properties-of-interest-for-remote-query-execution"></a>Свойства поставщика, имеющие отношение к выполнению удаленных запросов

Если поставщик поддерживает функции SQL, которые не включены в уровень синтаксиса, указанный в свойстве DBPROP_SQLSUPPORT, он может сообщить их с помощью различных свойств поставщика.

- SQLPROP_GROUPBY. Это свойство имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Оно указывает, что поставщик поддерживает предложения GROUP BY и HAVING в инструкции `SELECT`. Кроме того, это свойство указывает, что поставщик поддерживает следующие пять агрегатных функций: MIN, MAX, SUM, COUNT и AVG. Поставщик может не поддерживать DISTINCT в аргументах этих агрегатных функций.

- SQLPROP_SUBQUERIES. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Указывает на то, что поставщик поддерживает вложенные запросы в соответствии с уровнем Entry Level стандарта SQL-92. Сюда относятся вложенные запросы в списке `SELECT` и в предложении `WHERE` с поддержкой связанных вложенных запросов, а также операторов `IN`, `EXISTS`, `ALL` и `ANY`.

- SQLPROP_DATELITERALS. Это свойство имеет значение для любого поставщика (в том числе поддерживающего уровень Entry Level стандарта SQL-92). Поддержка стандартного синтаксиса для литералов datetime не является частью уровня Entry Level стандарта SQL-92. Это свойство SQL Server указывает, что поставщик поддерживает синтаксис литералов datetime в соответствии со стандартом SQL-92.

- SQLPROP_ANSILIKE. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Это свойство указывает, что поставщик, поддерживает оператор `LIKE` в соответствии с уровнем Entry Level стандарта SQL-92 (подстановочные знаки \'%\' и \'_\'). Применимо для поставщика, который поддерживает уровень SQL-Minimum, так как уровень SQL-Minimum не включает в себя поддержку `LIKE`.

- SQLPROP_INNERJOIN. Имеет значение для поставщика, поддерживающего уровень SQL-Minimum. Указывает на поддержку нескольких таблиц в предложении `FROM`. Применимо для поставщика, который поддерживает только уровень SQL-Minimum, так как уровень SQL-Minimum не включает в себя поддержку соединений. Не означает поддержку явных ключевых слов JOIN и внешних соединений. Указывает только на поддержку неявных соединений посредством списка таблиц в предложении `FROM`.

- SQLPROP_DYNAMICSQL. Указывает на поддержку `?` в качестве маркера параметра. Маркер параметра должен поддерживаться вместо скалярного элемента в предложении `WHERE` или списке `SELECT`. Поддержка маркеров параметров `?` позволяет SQL Server отправлять поставщику параметризированные запросы.

- SQLPROP_NESTEDQUERIES. Указывает на поддержку вложенных инструкций SELECT в предложении `FROM` (например, `SELECT * FROM (SELECT * FROM T))`. SQL Server часто использует вложенные инструкции `SELECT` в предложении `FROM` запроса при формировании строк запроса для удаленного выполнения. Так как поддержка вложенных инструкций `SELECT` не требуется на уровне Entry Level стандарта SQL-92, SQL Server не делегирует запросы с вложенными инструкциями `SELECT` поставщику, если это свойство не задается поставщиком. Администратор также может задать параметр поставщика `Nested Queries`, чтобы SQL Server создавал вложенные запросы к поставщику.

Поставщик может поддерживать эти свойства с помощью набора свойств SQL Server `SQLPROPSET_OPTHINTS` с определенными значениями `PROPID`. Набор свойств `SQLPROPSET_OPTHINTS` и два его свойства определяются с помощью следующих констант:

```
extern const GUID `SQLPROPSET_OPTHINTS` = { 0x2344480c, 0x33a7, 0x11d1, { 0x9b, 0x1a, 0x0, 0x60, 0x8, 0x26, 0x8b, 0x9e } };
enum SQLPROPERTIES {
SQLPROP_NESTEDQUERIES = 0x4,
SQLPROP_DYNAMICSQL = 0x5,
SQLPROP_GROUPBY = 0x6,
SQLPROP_DATELITERALS = 0x7,
SQLPROP_ANSILIKE = 0x8,
SQLPROP_INNERJOIN = 0x9,
SQLPROP_SUBQUERIES = 0x10
};
```

#### <a name="character-set-and-sort-order-implications"></a>Кодировка или порядок сортировки

SQL Server поддерживает указание параметров сортировки для символьных данных на уровне столбца. Параметры сортировки включают как кодировку, так и порядок сортировки для символьных данных не в Юникоде (столбцы `char` и `varchar`). Для данных Юникода (столбцы `nchar` и `nvarchar`) в параметрах сортировки указывается только порядок сортировки.

SQL Server делегирует сравнение строк поставщику, только если кодировка (для данных не в Юникоде), порядок сортировки и семантика сравнения строк, используемые связанным сервером, совпадают с используемыми на локальном сервере.

В случае со связанными серверами SQL Server автоматически определяет совместимость параметров сортировки. Для других поставщиков администратор должен указать для SQL Server параметры сортировки символьных данных со связанного сервера. В SQL Server поддерживается новый параметр связанного сервера `Collation Name`. Если администратор определяет, что семантика параметров сортировки, используемая на связанном сервере, совпадает с одними из стандартных параметров сортировки SQL Server, он может задать это название параметров сортировки в качестве параметра `Collation Name`. Параметр `Collation Name` можно задать с помощью системной хранимой процедуры `sp_serveroption`. Этот параметр следует задавать, только если выполняются оба указанных ниже условия.

- Порядок сортировки и кодировка удаленных данных совпадают с указанными параметрами сортировки SQL Server.

- Семантика сравнения строк, используемая поставщиком OLE DB, соответствует стандартным спецификациям SQL-92 или эквивалентна семантике сравнения SQL Server.

Параметр "Совместимые параметры сортировки", использовавшийся в SQL Server 7.0, по-прежнему поддерживается в целях обратной совместимости. Присвоение ему значения true равнозначно присвоению параметру "Имя параметров сортировки" параметров сортировки по умолчанию для базы данных master SQL Server. Новые приложения должны использовать параметр "Имя параметров сортировки" вместо параметра "Совместимые параметры сортировки".

### <a name="indexed-access"></a>Доступ к индексам

SQL Server использует индекс, предоставляемый поставщиком, для оценки определенных предикатов распределенного запроса. Этот сценарий возможен только для поставщиков индексов и когда пользователь задает параметр поставщика `Index as Access Path`. Ниже описываются основные действия, которые SQL Server выполняет применительно к поставщику при использовании индекса для выполнения запроса.

1. Открывает набор строк индекса с помощью метода `IOpenRowset::OpenRowset` с указанием полных имен таблицы и индекса. Полные имена таблицы и индекса формируются, как описано выше в сценарии удаленного запроса.

1. Открывает набор строк базовой таблицы с помощью метода `IOpenRowset::OpenRowset` с указанием полного имени таблицы.

1. Задает диапазоны для набора строк индекса на основе предиката запроса с помощью метода `IRowsetIndex::SetRange`.

1. Сканирует строки из набора строк индекса с помощью интерфейса `IRowset` этого набора строк.

1. Использует столбец закладок из полученных строк индекса для получения соответствующих строк из набора строк базовой таблицы с помощью метода `IRowsetLocate::GetRowsByBookmark`.

Свойства набора строк `DBPROP_IRowsetLocate` и `DBPROP_BOOKMARKS` требуются для набора строк, открытого для базовой таблицы.

### <a name="pure-table-scans"></a>Сканирование таблицы

SQL Server сканирует всю удаленную таблицу от поставщика и выполняет все операции по вычислению запроса локально. Набор строк, соответствующий таблице, открывается путем вызова метода `IOpenRowset::OpenRowset`. SQL Server формирует имя таблицы, передаваемое в метод `OPENROWSET`, из имен каталога, схемы и объекта указанным ниже образом.

1. Каждый компонент имени заключается в кавычки с использованием символа кавычек поставщика (`DBLITERAL_QUOTE`), после чего компоненты сцепляются с добавлением символа `DBLITERAL_CATALOG_SEPARATOR` между ними.

1. После открытия объекта набора строк SQL Server использует интерфейс `IColumnsInfo` для проверки того, что метаданные времени выполнения совпадают с метаданными времени компиляции для таблицы.

1. SQL Server использует интерфейс `IRowset` для перехода к строкам таблицы и их использования. Используйте `IRowset::GetNextRows` для получения строк, `IRowset::RestartPosition` для возврата к началу набора строк и `IRowset::ReleaseRows` для высвобождения строк.

### <a name="update-and-delete-statements"></a>Инструкции `UPDATE` и `DELETE`

Чтобы удаленную таблицу можно было обновить или удалить в распределенном запросе SQL Server, должны выполняться указанные ниже условия.

- Поставщик должен поддерживать закладки в наборе строк, открытом посредством интерфейса `IOpenRowset` в обновляемой или удаляемой таблице.

- Поставщик должен поддерживать интерфейсы `IRowsetLocate` и `IRowsetChange` для набора строк, открытого посредством интерфейса `IOpenRowset` в обновляемой или удаляемой таблице.

- Интерфейс `IRowsetChange` должен поддерживать методы обновления (`SetData`) и удаления (`DeleteRows`).

- Если поставщик не поддерживает интерфейс `ITransactionLocal`, инструкции `UPDATE` и `DELETE` разрешены только в том случае, если для этого поставщика задан параметр `Non-transacted` и инструкция не включена в пользовательскую транзакцию.

- Если поставщик не поддерживает интерфейс `ITransactionJoin`, инструкции `UPDATE` и `DELETE` разрешены только в том случае, если они не включены в пользовательскую транзакцию.

Для набора строк, открытого в обновляемой таблице, являются обязательными следующие свойства набора строк: `DBPROP_IRowsetLocate`, `DBPROP_IRowsetChange` и `DBPROP_BOOKMARKS`. Свойство набора строк `DBPROP_UPDATABILITY` устанавливается в значение `DBPROPVAL_UP_CHANGE` или `DBPROPVAL_UP_DELETE` в зависимости от того, выполняется ли операция `UPDATE` или `DELETE` соответственно.

Ниже представлены общие действия, выполняемые применительно к поставщику для обработки операции `UPDATE` или `DELETE`.

1. SQL Server открывает набор строк базовой таблицы посредством интерфейса `IOpenRowset`. SQL Server требует наличия указанных выше свойств набора строк.

1. SQL Server определяет набор подходящих строк для обновления или удаления.

1. SQL Server использует закладки для перехода к соответствующим строкам посредством интерфейса `IRowsetLocate`.

1. Используйте `IRowsetChange::SetData` для операций `UPDATE` или `IRowsetChange::DeleteRows` для операций удаления, чтобы внести необходимые изменения в соответствующие строки.

### <a name="insert-statement"></a>Инструкция `INSERT`

Условия для поддержки инструкций `INSERT` применительно к удаленной таблице менее строгие, чем для инструкций `UPDATE` и `DELETE`.

- Поставщик должен поддерживать метод `IRowsetChange::InsertRow` для набора строк, открываемого в базовой таблице, в которую выполняется вставка.

- Если поставщик не поддерживает интерфейс `ITransactionLocal`, инструкции `INSERT` разрешены только в том случае, если для этого связанного сервера задан параметр `Non-transacted updates` и инструкция не включена в пользовательскую транзакцию.

- Если поставщик не поддерживает интерфейс `ITransactionJoin`, инструкции `INSERT` разрешены только в том случае, если они не включены в пользовательскую транзакцию.

SQL Server использует метод `IOpenRowset::OpenRowset` для открытия набора строк в базовой таблице и вызывает `IRowsetChange::InsertRow` для вставки новых строк в базовый набор строк.

### <a name="pass-through-queries"></a>Транзитные запросы

Этот сценарий похож на сценарий удаленного запроса за тем исключением, что текст команды, передаваемый в `ICommand`, является строкой команды, указанной пользователем, и не интерпретируется сервером SQL Server. SQL Server использует `DBGUID_DEFAULT` в качестве идентификатора диалекта при вызове `ICommandText::SetCommandText`. `DBGUID_DEFAULT` указывает, что поставщик должен использовать диалект по умолчанию. Если этот текст команды возвращает более одного результирующего набора, например, если команда вызывает хранимую процедуру, возвращающую несколько результирующих наборов, SQL Server будет использовать только первый результирующий набор из команды.

Список всех интерфейсов OLE DB, которые использует SQL Server, см. в разделе [Интерфейсы OLE DB, используемые SQL Server](#appendixa).

### <a name="conclusion"></a>Заключение

Microsoft SQL Server предлагает наиболее эффективный набор средств для доступа к данным из разнородных источников данных. Умея пользоваться интерфейсами OLE DB, предоставляемыми SQL Server, разработчики могут выполнять сложные распределенные запросы с высокой степенью контроля.

## <a name="appendixa"></a> Интерфейсы OLE DB, используемые SQL Server

В приведенной ниже таблице перечислены все интерфейсы OLE DB, используемые SQL Server. В столбце "Обязательный" указано, является ли интерфейс частью основных возможностей OLE DB, которые требуются SQL Server, или он является необязательным. Если интерфейс не помечен как обязательный, SQL Server может обращаться к поставщику, но некоторые функции или возможности оптимизации SQL Server недоступны для него.

Для необязательных интерфейсов в столбце "Сценарии" указывается один или несколько из шести сценариев, в которых применяется данный интерфейс. Например, интерфейс `IRowsetChange` для наборов строк базовой таблицы является необязательным; он используется в сценариях с инструкциями `UPDATE` и DELETE и инструкцией `INSERT`. Если этот интерфейс не поддерживается, инструкции UPDATE, DELETE и `INSERT` для этого поставщика также не поддерживаются. Для некоторых других необязательных интерфейсов в столбце "Сценарии" указано \"производительность\", что означает, что интерфейс повышает общий уровень производительности. Например, если интерфейс `IDBSchemaRowset` не поддерживается, SQL Server должен открыть набор строк два раза: один раз для метаданных и еще раз для выполнения запроса. Благодаря поддержке `IDBSchemaRowset` повышается производительность SQL Server.

|Объект|Интерфейс|Обязательно|Комментарии|Сценарии|
|:-----|:-----|:-----|:-----|:-----|
|Объект источника данных|`IDBInitialize`|Да|Инициализирует и настраивает данные и контекст безопасности.| |
| |`IDBCreateSession`|Да|Создает объект сеанса базы данных.| |
| |`IDBProperties`|Да|Получает сведения о возможностях поставщика, задает свойства инициализации, обязательное свойство: DBPROP_INIT_TIMEOUT.| |
| |`IDBInfo`|нет|Получает литерал кавычек, имя каталога, символ-разделитель и т. д.|Удаленный запрос.|
|Объект сеанса базы данных|`IDBSchemaRowset`|нет|Получает метаданные таблицы или столбца. Требуемые наборы строк: `TABLES`, `COLUMNS`, `PROVIDER_TYPES`; другие наборы строк, используемые в случае наличия: `INDEXES`, `TABLE_STATISTICS`.|Производительность, доступ к индексам.|
| |`IOpenRowset`|Да|Открывает набор строк в таблице, индексе или гистограмме.| |
| |`IGetDataSource`|Да|Используется для возврата к DSO из объекта сеанса базы данных.| |
| |`IDBCreateCommand`|нет|Используется для создания объекта команды (запроса) для поставщиков, которые поддерживают запросы.|Удаленный запрос, транзитный запрос.|
| |`ITransactionLocal`|нет|Используется для транзакционных обновлений.|Инструкции `UPDATE`, `DELETE` и `INSERT`.|
| |`ITransactionJoin`|нет|Используется для поддержки распределенных транзакций.|Инструкции `UPDATE`, `DELETE` и `INSERT` в пользовательской транзакции.|
|Объект набора строк.|IRowset|Да|Сканирует строки.| |
| |`IAccessor`|Да|Выполняет привязку к столбцам в наборе строк.| |
| |`IColumnsInfo`|Да|Получает сведения о столбцах в наборе строк.| |
| |`IRowsetInfo`|Да|Получает сведения о свойствах набора строк.| |
| |`IRowsetLocate`|нет|Необходим для операций `UPDATE`/`DELETE`, а также для уточняющего запроса на основе индекса; используется для поиска строк по закладкам.|Доступ к индексам, инструкции `UPDATE` и `DELETE`.|
| |`IRowsetChange`|нет|Необходим для операций `INSERTS`/`UPDATES`/ `DELETES` с набором строк. Наборы строк в базовых таблицах должны поддерживать этот интерфейс для инструкций `INSERT`, `UPDATE` и `DELETE`.|Инструкции `UPDATE`, `DELETE` и `INSERT`.|
| |`IConvertType`|Да|Проверяет, поддерживает ли набор строк преобразование определенных типов данных в столбцах.| |
|Индекс|`IRowset`|Да|Сканирует строки.|Доступ к индексам, производительность.|
| |`IAccessor`|Да|Выполняет привязку к столбцам в наборе строк.|Доступ к индексам, производительность.|
| |`IColumnsInfo`|Да|Получает сведения о столбцах в наборе строк.|Доступ к индексам, производительность.|
| |`IRowsetInfo`|Да|Получает сведения о свойствах набора строк.|Доступ к индексам, производительность.|
| |`IRowsetIndex`|Да|Необходим для наборов строк в индексе, применяется в функциях индексирования (настройка диапазона, поиск).|Доступ к индексам, производительность.|
|Command|`ICommand`|Да| |Удаленный запрос, транзитный запрос.|
| |`ICommandText`|Да|Применяется для определения текста запроса.|Удаленный запрос, транзитный запрос.|
| |`IColumnsInfo`|Да|Используется для получения метаданных столбца для результатов запроса.|Удаленный запрос, транзитный запрос.|
| |`ICommandProperties`|Да|Используется для указания обязательных свойств наборов строк, возвращаемых командой.|Удаленный запрос, транзитный запрос.|
| |`ICommandWithParameters`|нет|Применяется для выполнения параметризированных запросов.|Удаленный запрос, производительность.|
| |`ICommandPrepare`|нет|Используется для подготовки команды к получению метаданных (применяется в транзитных запросах в случае доступности).|Удаленный запрос, производительность.|
|Объект ошибки|`IErrorRecords`|Да|Используется для получения указателя на интерфейс `IErrorInfo`, соответствующий одной записи об ошибке.| |
| |`IErrorInfo`|Да|Используется для получения указателя на интерфейс `IErrorInfo`, соответствующий одной записи об ошибке.| |
|Любой объект|`ISupportErrorInfo`|нет|Служит для определения того, поддерживает ли указанный интерфейс объекты ошибок.| |
|  |  |  |  |  |

>[!NOTE]
>Объекты `Index`, `Command` и `Error` не являются обязательными. Однако если они поддерживаются, перечисленные интерфейсы являются обязательными, как указано в столбце "Обязательный".

## <a name="appendixb"></a>Подмножество SQL, используемое для создания удаленных запросов

Подмножество SQL, которое обработчик запросов SQL Server создает для поставщика команд SQL, зависит от уровня синтаксиса, поддерживаемого поставщиком и указываемого в свойстве `DBPROP_SQLSUPPORT`.

Поставщики команд SQL, поддерживающие уровень SQL Entry Level или ODBC Core

SQL Server использует приведенное ниже подмножество языка SQL для запросов, вычисляемых поставщиками команд SQL, которые поддерживают уровень Entry Level стандарта SQL-92 или ODBC Core.

1. Инструкции `SELECT` с предложениями `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `UNION`, `UNION ALL`, `ORDER BY DESC`, `ASC` и `HAVING`.

1. `UNION` и `UNION ALL` создаются только для поставщиков, поддерживающих уровень Entry Level стандарта SQL-92, но не для поставщиков, которые поддерживают ODBC Core.

1. Предложение `SELECT`:

   - скалярные вложенные запросы в списке `SELECT`;

   - псевдонимы столбцов без ключевого слова `AS`.

1. Предложение `FROM`:

   - явные ключевые слова JOIN не используются; имена таблиц с разделителями-запятыми применяются для указания внутренних соединений, внешние соединения не указываются в удаленных запросах;

   - вложенные запросы в формате `FROM` ( `<nested query>` ) `<alias>`;

   - псевдонимы таблиц без ключевого слова AS.

1. Предложение `WHERE` использует вложенные запросы с `NOT`, `EXISTS`, `ANY`, `ALL`.

1. Выражения:

   - используемые агрегатные функции: `MIN([DISTINCT])`, `MAX([DISTINCT])`, `COUNT([DISTINCT])`, `SUM([DISTINCT])`, `AVG([DISTINCT])` и `COUNT(*)`;

   - операторы сравнения: `<`, `=`, `<=`, `>`, `<>`, `>=`, `IS NULL` и `IS NOT NULL`;

   - логические операторы: `AND`, `OR` и `NOT`.

 - Арифметические операторы: `+`, `-`, `*` и `/`.

1. Константы:

- числовые и денежные литералы всегда заключаются в `( )`;

- символьные литералы заключаются в `' '`.

Поставщики команд SQL, поддерживающие уровень SQL Minimum

Для поставщиков команд SQL, которые поддерживают уровень SQL Minimum, SQL Server создает запросы SQL, используя представленную ниже грамматику.

Эта грамматика была получена из грамматики SQL Minimum, описанной в спецификации ODBC 3.0. Все отличия от этой грамматики выделены. Элементы, выделенные шрифтом `*bold italics`, добавлены к грамматике SQL Minimum, описанной в спецификации ODBC 3.0. Элементы, выделенные зеленым цветом, удалены из этой грамматики.

*select-statement* ::=

`SELECT [ALL | DISTINCT] *select-list* FROM *table-reference-list*[WHERE *search-condition*] [order-by-clause]`

Предложение `SELECT`

select-list ::= `*` | `select-sublist [, select-sublist]...`

select-sublist ::= expression * [`alias`]*

`*alias ::= user-defined-name`*

`FROM clause`

table-reference-list ::= table-reference

table-identifier ::= user-defined-name

table-name ::= table-identifier

table-reference ::= table-name

`WHERE clause`

search-condition ::= boolean-term \[OR search-condition\]

boolean-term ::= boolean-factor \[AND boolean-term\]

boolean-factor ::= \[NOT\] boolean-primary

boolean-primary ::= comparison-predicate \| ( search-condition )

comparison-predicate ::= expression comparison-operator expression

*\| `expression IS \[NOT\] NULL`*

comparison-operator ::= `< \| >` \| `<= \| >`= \| = \| `<>`

`ORDER BY clause`

order-by-clause ::= ORDER BY sort-specification \[, sort-specification\]\...

sort-specification ::= { \| column-name } \[ASC \| DESC\]

`Common syntactic elements`

expression ::= term \| expression {+\|--} term

term ::= factor \| term {\*\|/} factor

factor ::= \[+\|--\] primary

primary ::= column-name

Литерал \|

\| ( выражение )

column-name ::= \[table-name.\]column-identifier

literal ::= character-string-literal

*\| integer-literal*

*\| exact-numeric-literal*

character-string-literal ::= \'{character}...\'

(character — это любой символ из кодировки драйвера или источника данных. Чтобы включить одинарную литеральную кавычку (\') в character-string-literal, используйте два символа литеральной кавычки (\'\').)

`*integer-literal ::=* \[*+ \| -*\] *unsigned-integer`*

`*exact-numeric-literal::=* \[*+ \| -*\] *unsigned-integer* \[*period unsigned-integer*\]`

`*\| period unsigned-integer`*

base-table-name ::= base-table-identifier

base-table-identifier ::= user-defined-name

column-identifier ::= user-defined-name

user-defined-name ::= letter\[digit \| letter \| _\]\...

unsigned-integer ::= {digit}...

digit ::= 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9

period ::= . 

## <a name="appendixc"></a>Свойства SQL Server

```
enum SQLPROPERTIES
       {
       SQLPROP_NOHPNEEDED = 0x1,
       SQLPROP_FREETHREADED = 0x2,
       SQLPROP_UMSENABLED = 0x3,
       SQLPROP_NESTEDQUERIES = 0x4,
       SQLPROP_DYNAMICSQL = 0x5,
       SQLPROP_GROUPBY = 0x6,
       SQLPROP_DATELITERALS = 0x7,
       SQLPROP_ANSILIKE = 0x8,
       SQLPROP_INNERJOIN = 0x9,
       SQLPROP_SUBQUERIES = 0x10, 
       SQLPROP_PARALLELSCAN = 0x11,
       SQLPROP_COLUMNCOLLATION = 0x12,
       SQLPROP_CARDINALITY = 0x13,
       SQLPROP_SIMPLEUPDATES = 0x14,
       SQLPROP_SQLLIKE = 0x15,
       SQLPROP_BITREMOTING = 0x16,
       SQLPROP_UNICODELITERALS = 0x17,
       SQLPROP_USELATESTCOLLATIONVERSION = 0x18
       };

```