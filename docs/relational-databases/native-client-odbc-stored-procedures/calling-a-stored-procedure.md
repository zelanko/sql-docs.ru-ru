---
title: "Вызов хранимой процедуры | Документы Microsoft"
ms.custom: 
ms.date: 03/16/2017
ms.prod: sql-non-specified
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.service: 
ms.component: native-client-odbc-stored-procedures
ms.reviewer: 
ms.suite: sql
ms.technology: docset-sql-devref
ms.tgt_pltfrm: 
ms.topic: reference
helpviewer_keywords:
- calling stored procedures
- ODBC, stored procedures
- stored procedures [ODBC], calling
- SQL Server Native Client ODBC driver, stored procedures
- ODBC CALL escape sequence
- escape sequences [SQL Server]
- CALL statement
ms.assetid: d13737f4-f641-45bf-b56c-523e2ffc080f
caps.latest.revision: "41"
author: JennieHubbard
ms.author: jhubbard
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: a5e9efb687e9a554841e945f7575a75a5ac3d4ad
ms.sourcegitcommit: 44cd5c651488b5296fb679f6d43f50d068339a27
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/17/2017
---
# <a name="calling-a-stored-procedure"></a>Вызов хранимой процедуры
[!INCLUDE[appliesto-ss-asdb-asdw-pdw-md](../../includes/appliesto-ss-asdb-asdw-pdw-md.md)]
[!INCLUDE[SNAC_Deprecated](../../includes/snac-deprecated.md)]

  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Драйвер ODBC для собственного клиента поддерживает оба escape-последовательность ODBC CALL и [!INCLUDE[tsql](../../includes/tsql-md.md)] [EXECUTE](../../t-sql/language-elements/execute-transact-sql.md) инструкции для выполнения хранимых процедур; предпочтительным методом является управляющая последовательность ODBC CALL. Использование синтаксиса ODBC позволяет приложению получать коды возврата хранимых процедур, а драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] оптимизирован в целях использования протокола, первоначально разработанного для отправки вызовов удаленных процедур (RPC) между компьютерами, на которых выполняется [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Этот протокол RPC повышает производительность, устраняя большую часть обработки параметров и синтаксической проверки инструкций на сервере.  
  
> [!NOTE]  
>  При вызове [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранимых процедур с именованными параметрами ODBC (Дополнительные сведения см. в разделе [привязка параметров по имени (именованные параметры)](http://go.microsoft.com/fwlink/?LinkID=209721)), имена параметров должны начинаться с "@" символов. Это ограничение, характерное для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В драйвере ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] это ограничение контролируется строже, чем в компонентах доступа к данным MDAC.  
  
 Управляющая последовательность ODBC CALL для вызова процедуры такова:  
  
 {[**? =**]**вызвать***имя_процедуры*[([*параметр*] [**,**[*параметр*]] ...)]}  
  
 где *имя_процедуры* указывает имя процедуры и *параметр* указывает параметр процедуры. Именованные параметры поддерживаются только в инструкциях, использующих escape-последовательности ODBC CALL.  
  
 Процедура может иметь параметры или не иметь их. Она также может возвращать значение (на что указывает необязательный маркер параметра «?=» в начале синтаксической конструкции). Если параметр является входным или входным-выходным, то может представлять собой литерал или маркер параметра. Если параметр является выходным, то должен быть маркером параметра, поскольку выходной параметр неизвестен. Маркеры параметров должен быть связан с [SQLBindParameter](../../relational-databases/native-client-odbc-api/sqlbindparameter.md) до вызова процедуры выполнения инструкции.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается со скобками, но без параметров, то драйвер передает источнику данных указание, что для первого параметра должно использоваться значение по умолчанию. Например:  
  
 {**вызвать** *имя_процедуры***()**}  
  
 Если процедура не имеет ни одного параметра, ее вызов завершается ошибкой. Если процедура вызывается без скобок, драйвер не передает какие-либо значения параметров. Например:  
  
 {**вызвать** *procedure_name*}  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, процедура InsertOrder имеет пять входных параметров. В следующем вызове процедуры InsertOrder пропущен первый параметр, указан литерал для второго параметра и используется маркер параметра для третьего, четвертого и пятого параметра. (Параметры нумеруются последовательно, начиная с 1.)  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}  
```  
  
 Обратите внимание, что даже если параметр пропущен, запятая, отделяющая его от других параметров, должна присутствовать. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другие способы задать значение по умолчанию для входного или входного-выходного параметра таковы: присвоить значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM, или использовать ключевое слово DEFAULT.  
  
 Если входной-выходной параметр пропущен или в качестве параметра выступает литерал, то драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
## <a name="delimiters-in-call-statements"></a>Разделители в инструкциях CALL  
 Драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию поддерживает также параметр совместимости для управляющей последовательности ODBC { CALL }. Он принимает инструкции CALL только с одним набором двойных кавычек, ограничивающих все имя хранимой процедуры:  
  
```  
{ CALL "master.dbo.sp_who" }  
```  
  
 По умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] принимает также инструкции CALL, которые соответствуют правилам ISO, и заключает каждый идентификатор в двойные кавычки:  
  
```  
{ CALL "master"."dbo"."sp_who" }  
```  
  
 Но при выполнении с настройками по умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не поддерживает использование ни одной из форм представления идентификаторов, заключенных в кавычки, применительно к идентификаторам, которые содержат символы, не указанные как допустимые в стандарте ISO. Например, драйвер не может получить доступ к хранимую процедуру с именем **«My.Proc»** с использованием инструкции CALL с заключенные в кавычки идентификаторы:  
  
```  
{ CALL "MyDB"."MyOwner"."My.Proc" }  
```  
  
 Эта инструкция интерпретируется драйвером следующим образом:  
  
```  
{ CALL MyDB.MyOwner.My.Proc }  
```  
  
 Сервер выдает ошибку, связанный сервер с именем **MyDB** не существует.  
  
 При использовании идентификаторов, заключенных в квадратные скобки, эта инструкция интерпретируется правильно:  
  
```  
{ CALL [MyDB].[MyOwner].[My.Table] }  
```  
  
## <a name="see-also"></a>См. также:  
 [Выполнение хранимых процедур](../../relational-databases/native-client-odbc-stored-procedures/running-stored-procedures.md)  
  
  
