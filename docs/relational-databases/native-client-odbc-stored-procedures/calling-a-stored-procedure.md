---
title: Вызов хранимой процедуры | Документация Майкрософт
description: Сведения о escape-последовательности ODBC CALL, предпочтительном методе выполнения хранимых процедур. Драйвер ODBC для собственного клиента также поддерживает Transact-SQLEXECUTE.
ms.custom: ''
ms.date: 03/16/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- calling stored procedures
- ODBC, stored procedures
- stored procedures [ODBC], calling
- SQL Server Native Client ODBC driver, stored procedures
- ODBC CALL escape sequence
- escape sequences [SQL Server]
- CALL statement
ms.assetid: d13737f4-f641-45bf-b56c-523e2ffc080f
author: markingmyname
ms.author: maghan
monikerRange: '>=aps-pdw-2016||=azuresqldb-current||=azure-sqldw-latest||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current'
ms.openlocfilehash: 2a8ebd8eb539190c65e1e1a97ce55579eb93f180
ms.sourcegitcommit: f3321ed29d6d8725ba6378d207277a57cb5fe8c2
ms.contentlocale: ru-RU
ms.lasthandoff: 07/06/2020
ms.locfileid: "86004650"
---
# <a name="calling-a-stored-procedure"></a>Вызов хранимой процедуры
[!INCLUDE[SQL Server Azure SQL Database Synapse Analytics PDW ](../../includes/applies-to-version/sql-asdb-asdbmi-asa-pdw.md)]

  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]Драйвер ODBC для собственного клиента поддерживает как escape-последовательность ODBC CALL, так и [!INCLUDE[tsql](../../includes/tsql-md.md)] инструкцию [EXECUTE](../../t-sql/language-elements/execute-transact-sql.md) для выполнения хранимых процедур; в качестве предпочтительного метода используется escape-последовательность вызова ODBC. Использование синтаксиса ODBC позволяет приложению получать коды возврата хранимых процедур, а драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] оптимизирован в целях использования протокола, первоначально разработанного для отправки вызовов удаленных процедур (RPC) между компьютерами, на которых выполняется [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Этот протокол RPC повышает производительность, устраняя большую часть обработки параметров и синтаксической проверки инструкций на сервере.  
  
> [!NOTE]  
>  При вызове [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранимых процедур с использованием именованных параметров с помощью ODBC (Дополнительные сведения см. в разделе [Привязка параметров по имени (именованные параметры)](https://go.microsoft.com/fwlink/?LinkID=209721)). имена параметров должны начинаться с \@ символа "". Это ограничение, характерное для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В драйвере ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] это ограничение контролируется строже, чем в компонентах доступа к данным MDAC.  
  
 Управляющая последовательность ODBC CALL для вызова процедуры такова:  
  
 {[**? =**]**вызовите**_procedure_name_[([*параметр*] [**,**[*параметр*]]...)]}  
  
 где *procedure_name* указывает имя процедуры, а *параметр* — параметр процедуры. Именованные параметры поддерживаются только в инструкциях, использующих escape-последовательности ODBC CALL.  
  
 Процедура может иметь параметры или не иметь их. Она также может возвращать значение (на что указывает необязательный маркер параметра «?=» в начале синтаксической конструкции). Если параметр является входным или входным-выходным, то может представлять собой литерал или маркер параметра. Если параметр является выходным, то должен быть маркером параметра, поскольку выходной параметр неизвестен. Маркеры параметров должны быть привязаны к [SQLBindParameter](../../relational-databases/native-client-odbc-api/sqlbindparameter.md) перед выполнением инструкции вызова процедуры.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается со скобками, но без параметров, то драйвер передает источнику данных указание, что для первого параметра должно использоваться значение по умолчанию. Пример:  
  
 {**call** _procedure_name_**()**}  
  
 Если процедура не имеет ни одного параметра, ее вызов завершается ошибкой. Если процедура вызывается без скобок, драйвер не передает какие-либо значения параметров. Пример:  
  
 {**call** _procedure_name_}  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, процедура InsertOrder имеет пять входных параметров. В следующем вызове процедуры InsertOrder пропущен первый параметр, указан литерал для второго параметра и используется маркер параметра для третьего, четвертого и пятого параметра. (Параметры нумеруются последовательно, начиная с 1.)  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}  
```  
  
 Обратите внимание, что даже если параметр пропущен, запятая, отделяющая его от других параметров, должна присутствовать. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другие способы задать значение по умолчанию для входного или входного-выходного параметра таковы: присвоить значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM, или использовать ключевое слово DEFAULT.  
  
 Если входной-выходной параметр пропущен или в качестве параметра выступает литерал, то драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
## <a name="delimiters-in-call-statements"></a>Разделители в инструкциях CALL  
 Драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию поддерживает также параметр совместимости для управляющей последовательности ODBC { CALL }. Он принимает инструкции CALL только с одним набором двойных кавычек, ограничивающих все имя хранимой процедуры:  
  
```  
{ CALL "master.dbo.sp_who" }  
```  
  
 По умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] принимает также инструкции CALL, которые соответствуют правилам ISO, и заключает каждый идентификатор в двойные кавычки:  
  
```  
{ CALL "master"."dbo"."sp_who" }  
```  
  
 Но при выполнении с настройками по умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не поддерживает использование ни одной из форм представления идентификаторов, заключенных в кавычки, применительно к идентификаторам, которые содержат символы, не указанные как допустимые в стандарте ISO. Например, драйвер не может получить доступ к хранимой процедуре с именем **"My. proc"** с помощью инструкции Call с заключенными в кавычки идентификаторами:  
  
```  
{ CALL "MyDB"."MyOwner"."My.Proc" }  
```  
  
 Эта инструкция интерпретируется драйвером следующим образом:  
  
```  
{ CALL MyDB.MyOwner.My.Proc }  
```  
  
 Сервер вызывает ошибку, связанную с тем, что связанный сервер с именем **myDB** не существует.  
  
 При использовании идентификаторов, заключенных в квадратные скобки, эта инструкция интерпретируется правильно:  
  
```  
{ CALL [MyDB].[MyOwner].[My.Table] }  
```  
  
## <a name="see-also"></a>См. также  
 [Выполнение хранимых процедур](../../relational-databases/native-client-odbc-stored-procedures/running-stored-procedures.md)  
  
  
