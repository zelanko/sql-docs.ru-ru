---
title: "Создание переменных и столбцов типа данных XML | Документация Майкрософт"
ms.custom: 
ms.date: 03/16/2017
ms.prod: sql-non-specified
ms.prod_service: database-engine
ms.service: 
ms.component: xml
ms.reviewer: 
ms.suite: sql
ms.technology: dbe-xml
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- xml data type [SQL Server], variables
- xml data type [SQL Server], columns
ms.assetid: 8994ab6e-5519-4ba2-97a1-fac8af6f72db
caps.latest.revision: "13"
author: douglaslMS
ms.author: douglasl
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: 71657218912add2fd3b44297e0a4b82cb7b655a5
ms.sourcegitcommit: 6c54e67818ec7b0a2e3c1f6e8aca0fdf65e6625f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="create-xml-data-type-variables-and-columns"></a>Создание переменных и столбцов типа данных XML
[!INCLUDE[tsql-appliesto-ss2008-xxxx-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-xxxx-xxxx-xxx-md.md)] Тип данных **xml** — это встроенный в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] тип данных, несколько напоминающий другие встроенные типы данных, такие как **int** и **varchar**. Как и другие встроенные типы данных, тип данных **xml** можно использовать как тип столбца при создании таблицы, как тип переменной, параметра, тип возвращаемого функцией значения, а также в инструкциях [CAST и CONVERT](../../t-sql/functions/cast-and-convert-transact-sql.md).  
  
## <a name="creating-columns-and-variables"></a>Создание столбцов и переменных  
 Чтобы создать в таблице столбец типа `xml` , воспользуйтесь инструкцией `CREATE TABLE` , приведенной в следующем примере:  
  
```  
CREATE TABLE T1(Col1 int primary key, Col2 xml)   
```  
  
 Функция `DECLARE statement` , приведенная в следующем примере, позволяет создать переменную типа `xml` .  
  
```  
DECLARE @x xml   
```  
  
 Создайте типизированную переменную `xml` , указав коллекцию XML-схем, как показано в следующем примере.  
  
```  
DECLARE @x xml (Sales.StoreSurveySchemaCollection)  
```  
  
 Чтобы передать параметр типа `xml` хранимой процедуре, воспользуйтесь инструкцией `CREATE PROCEDURE` , как показано в следующем примере.  
  
```  
CREATE PROCEDURE SampleProc(@XmlDoc xml) AS ...   
```  
  
 Чтобы выполнять запросы к экземплярам XML, хранимым в столбцах, параметрах и переменных, можно использовать XQuery. Чтобы обновлять экземпляры XML, также можно использовать язык XML DML. Поскольку стандарт XQuery на момент разработки не определял язык XQuery DML, в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] были введены расширения [языка XML DML](../../t-sql/xml/xml-data-modification-language-xml-dml.md) к XQuery. Эти расширения позволяют выполнять операции вставки, обновления и удаления.  
  
## <a name="assigning-defaults"></a>Назначение значений по умолчанию  
 В таблице столбцу типа **xml** можно назначить экземпляр XML по умолчанию. Экземпляр XML по умолчанию можно указать двумя способами: при помощи константы XML или явного приведения к типу **xml** .  
  
 Чтобы указать в качестве экземпляра XML по умолчанию константу XML, воспользуйтесь синтаксической конструкцией из следующего примера. Обратите внимание, что строка неявно приведена к типу **xml** .  
  
```  
CREATE TABLE T (XmlColumn xml default N'<element1/><element2/>')  
```  
  
 Чтобы указать экземпляр XML по умолчанию посредством явного преобразования `CAST` в тип `xml`, воспользуйтесь синтаксической конструкцией из следующего примера.  
  
```  
CREATE TABLE T (XmlColumn xml   
                  default CAST(N'<element1/><element2/>' AS xml))  
```  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживает ограничения NULL и NOT NULL для столбцов типа **xml** . Пример:  
  
```  
CREATE TABLE T (XmlColumn xml NOT NULL)  
```  
  
## <a name="specifying-constraints"></a>Указание ограничений  
 При создании столбцов типа **xml** можно устанавливать ограничения уровня столбца или уровня таблицы. Используйте ограничения в следующих ситуациях.  
  
-   Бизнес-правила не могут быть выражены в XML-схемах. Допустим, что адреса доставки заказов магазином цветов должны находиться не далее 90 километров от магазина. Это требование можно выразить в форме ограничения XML-столбца. Эти ограничения могут содержать методы для обработки данных типа **xml** .  
  
-   В ограничении фигурируют другие столбцы таблицы, имеющие тип XML или другой тип. В качестве примера можно привести требование, согласно которому идентификатор заказчика (`/Customer/@CustId`), хранимый в экземпляре XML, должен соответствовать значению из реляционного столбца CustomerID.  
  
 Ограничения можно указать для типизированных и нетипизированных столбцов **xml** . Однако использование [методов типа данных xml](../../t-sql/xml/xml-data-type-methods.md) при указании ограничений невозможно. Кроме того, обратите внимание, что тип данных **xml** не поддерживает следующие ограничения столбцов и таблиц:  
  
-   PRIMARY KEY и FOREIGN KEY  
  
-   UNIQUE  
  
-   COLLATE  
  
     XML использует свою собственную кодировку. Параметры сортировки применимы только к строковым типам. Тип данных **xml** к таковым не относится. Однако у него есть строковое представление, и его можно приводить к строковым типам данных и обратно.  
  
-   RULE  
  
 Помимо использования ограничений можно создать оболочку, то есть определяемую пользователем функцию, являющуюся интерфейсом к методу типа данных **xml** , и указать определяемую пользователем функцию в проверочном ограничении, как показано в следующем примере.  
  
 В этом примере ограничение на столбец `Col2` указывает, что каждый хранимый в этом столбце экземпляр XML должен иметь элемент `<ProductDescription>` , содержащий атрибут `ProductID` . Это ограничение принудительно применяется с помощью пользовательской функции:  
  
```  
CREATE FUNCTION my_udf(@var xml) returns bit  
AS BEGIN   
RETURN @var.exist('/ProductDescription/@ProductID')  
END  
GO  
```  
  
 Обратите внимание, что метод `exist()` типа данных `xml` возвращает значение `1` , если элемент `<ProductDescription>` в экземпляре содержит атрибут `ProductID` . В противном случае возвращается значение `0`.  
  
 Теперь возможно создание таблицы с ограничениями на уровне столбцов, как показано ниже:  
  
```  
CREATE TABLE T (  
    Col1 int primary key,   
    Col2 xml check(dbo.my_udf(Col2)=1))  
GO  
```  
  
 Эта операция вставки выполняется успешно:  
  
```  
INSERT INTO T values(1,'<ProductDescription ProductID="1" />')  
```  
  
 Из-за ограничения следующая операция вставки не будет выполнена:  
  
```  
INSERT INTO T values(1,'<Product />')  
```  
  
## <a name="same-or-different-table"></a>Та же таблица или другая  
 Столбец типа **xml** можно создать в таблице, содержащей другие реляционные столбцы, или в таблице, связанной посредством внешнего ключа с главной таблицей.  
  
 Столбец типа **xml** следует создавать в той же таблице, если выполняется одно из перечисленных ниже условий.  
  
-   Приложение извлекает данные из XML-столбца и не нуждается в том, чтобы для него был создан XML-индекс.  
  
-   Для столбца типа **xml** требуется создание XML-индекса, причем первичный ключ главной таблицы идентичен ее ключу кластеризации. Дополнительные сведения см в разделе [XML-индексы (SQL Server)](../../relational-databases/xml/xml-indexes-sql-server.md).  
  
 Столбец типа **xml** следует создавать в отдельной таблице, если выполняются перечисленные ниже условия.  
  
-   Для столбца типа **xml** требуется создание XML-индекса, но первичный ключ главной таблицы отличается от ее ключа кластеризации, главная таблица не имеет первичного ключа или главная таблица является кучей (нет ключа кластеризации). Это может иметь место, если главная таблица уже существует.  
  
-   Не требуется замедлять просмотр таблицы из-за наличия в ней XML-столбца. Он занимает место независимо от того, хранится ли он в строке или вне строки.  
  
  
