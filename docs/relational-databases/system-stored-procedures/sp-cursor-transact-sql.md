---
title: sp_cursor (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 03/03/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_cursor_TSQL
- sp_cursor
dev_langs:
- TSQL
helpviewer_keywords:
- sp_cursor
ms.assetid: 41ade0ca-5f11-469d-bd4d-c8302ccd93b3
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 7550a640b723e77f3bfbc9b3473e762962ae2da3
ms.sourcegitcommit: da88320c474c1c9124574f90d549c50ee3387b4c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/01/2020
ms.locfileid: "85646421"
---
# <a name="sp_cursor-transact-sql"></a>sp_cursor (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2008-xxxx-xxxx-xxx-md](../../includes/applies-to-version/sqlserver.md)]

  Запрашивает позиционированные обновления. Эта процедура выполняет операции с одной или несколькими строками в пределах буфера выборки курсора. sp_cursor вызывается путем указания ID = 1 в пакете потока табличных данных (TDS).  
  
||  
|-|  
|**Применимо к**: SQL Server ( [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] до [текущей версии](https://go.microsoft.com/fwlink/p/?LinkId=299658)).|  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
sp_cursor  cursor, optype, rownum, table  
    [ , value[...n]]]  
```  
  
## <a name="arguments"></a>Аргументы  
 *курсор*  
 Дескриптор курсора. *cursor* является обязательным параметром, который вызывает входное значение **int** . *cursor* — это значение *маркера* , созданное SQL Server и возвращаемое sp_cursoropen процедурой.  
  
 *optype*  
 Обязательный параметр, назначающий операцию, которую будет выполнять курсор. для *optype* требуется одно из следующих входных значений **int** .  
  
|Значение|Имя|Описание|  
|-----------|----------|-----------------|  
|0X0001|UPDATE|Используется для обновления одной или более строк в буфере выборки.  К строкам, указанным в *rownum* , осуществляется повторный доступ и обновление.|  
|0x0002|DELETE|Используется для удаления одной или более строк в буфере выборки. Строки, указанные в *rownum* , будут доступны и удалены.|  
|0X0004|INSERT|Вставляет данные без создания инструкции SQL **INSERT** .|  
|0X0008|REFRESH|Используется для повторного заполнения буфера из базовых таблиц. Может использоваться для обновления строки, если обновление или удаление не удалось провести из-за управления оптимистическим параллелизмом, или после выполнения UPDATE.|  
|0X10|LOCK|Приводит к получению SQL Server U-Lock на странице, содержащей указанную строку. Эта блокировка совместима с S-блокировками и несовместима с X-блокировками или другими U-блокировками. Может использоваться для краткосрочной блокировки.|  
|0X20|SETPOSITION|Используется только в том случае, если программа будет выдавать последующий SQL Server позиционированную инструкцию DELETE или UPDATE.|  
|0X40|ABSOLUTE|Может использоваться только совместно с UPDATE или DELETE.  ABSOLUTE используется только с курсорами KEYSET (не используется курсорами DYNAMIC, а курсоры STATIC не допускают обновления).<br /><br /> Примечание. Если в строке набора ключей, которая не была извлечена, указан АБСОЛЮТный, операция может завершиться ошибкой, а возвращаемый результат не будет гарантирован.|  
  
 *rownum*  
 Указывает, с какими строками в буфере выборки будет работать курсор, обновляя или удаляя их.  
  
> [!NOTE]  
>  Не оказывает влияния на точку начала любой операции выборки RELATIVE, NEXT или PREVIOUS, а также на операции обновления и удаления, выполняемые с помощью процедуры sp_cursor.  
  
 *rownum* — это обязательный параметр, который вызывает входное значение **int** .  
  
 1  
 Обозначает первую строку в буфере выборки.  
  
 2  
 Обозначает вторую строку в буфере выборки.  
  
 3, 4, 5  
 Обозначает третью строку и так далее.  
  
 n  
 Обозначает n-ю строку в буфере выборки.  
  
 0  
 Обозначает все строки в буфере выборки.  
  
> [!NOTE]  
>  Параметр допустим только для использования с ОБНОВЛЕНИЯми, УДАЛЕНИЕм, ОБНОВЛЕНИЕм или БЛОКИРОВКОЙ *optype* значений.  
  
 *table*  
 Имя таблицы, определяющее таблицу, к которой применяется *optype* , если определение курсора включает в себя имя столбца JOIN или неоднозначные имена столбцов, возвращаемых параметром *value* . Если таблица не назначена, то по умолчанию берется первая таблица в предложении FROM. *Table* является необязательным параметром, для которого требуется входное строковое значение. Строка может иметь любой символьный тип данных или Юникоде. *Таблица* может быть именем составной таблицы.  
  
 *value*  
 Используется для вставки или обновления значений. Параметр строки *значения* используется только с значениями *optype* для Update и INSERT. Строка может иметь любой символьный тип данных или Юникоде.  
  
> [!NOTE]  
>  Имена параметров для *значения* могут назначаться пользователем.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 При использовании RPC операция позиционированного удаления или обновления с буфером номер 0 будет возвращать ЗАВЕРШЕНное сообщение с количеством строк *0* (сбой) или 1 (успешно) для каждой строки в буфере выборки.  
  
## <a name="remarks"></a>Примечания  
  
## <a name="optype-parameter"></a>Параметр optype  
 За исключением сочетаний SETPOSITION с UPDATE, DELETE, REFRESH или LOCK; или АБСОЛЮТная с помощью UPDATE или DELETE, значения *optype* являются взаимоисключающими.  
  
 Предложение SET значения UPDATE формируется из параметра *value* .  
  
 Одним из преимуществ использования значения INSERT *optype* является то, что можно избежать преобразования несимвольных данных в символьный формат для вставок. Значения указываются так же, как в UPDATE. Если какие-либо обязательные столбцы не включены, то возникает ошибка INSERT.  
  
-   Значение SETPOSITION не влияет на начальную точку любой операции выборки RELATIVE, NEXT или PREVIOUS, так же как и любые обновления или удаления, выполненные с помощью интерфейса sp_cursor. Любое число, не указывающее строку в буфере выборки, приведет к установке позиции в значения 1, при этом сообщение об ошибке не выдается. После выполнения SETPOSITION она остается в силе до следующего sp_cursorfetch операции, операции T-SQL **Fetch** или SP_CURSOR операции SETPOSITION с помощью одного и того же курсора. Последующая операция sp_cursorfetch переместит позицию курсора на первую строку в новом буфере выборки, тогда как другие вызовы курсора не повлияют на его позицию. SETPOSITION можно связывать оператором OR с REFRESH, UPDATE, DELETE или LOCK, чтобы установить значение позиции на последнюю измененную строку.  
  
 Если строка в буфере выборки не указана с помощью параметра *rownum* , то устанавливается значение 1, а ошибка не возвращается. После задания позиции она действует до выполнения следующей операции sp_cursorfetch, команды T-SQL FETCH или операции sp_cursor SETPOSITION для того же курсора.  
  
 SETPOSITION можно связывать оператором OR с REFRESH, UPDATE, DELETE или LOCK, чтобы установить позицию курсора на последнюю измененную строку.  
  
## <a name="rownum-parameter"></a>Параметр rownum  
 При указании параметра *rownum* может интерпретироваться как номер строки в наборе ключей, а не номер строки в буфере выборки. Пользователь отвечает за управление параллелизмом. Это означает, что для курсоров SCROLL_LOCKS придется независимо поддерживать блокировку заданной строки (это можно сделать через транзакции). Для курсоров OPTIMISTIC надо предварительно извлечь строку, чтобы выполнить эту операцию.  
  
## <a name="table-parameter"></a>Параметр table  
 Если значение *optype* — Update или INSERT, а в качестве параметра *value* отправляется полное обновление или инструкция INSERT, то значение, указанное для *Table* , игнорируется.  
  
> [!NOTE]  
>  Для представлений могут изменяться только участвующие в них таблицы. Имена столбцов параметров *значений* должны отражать имена столбцов в представлении, но имя таблицы может быть именем базовой таблицы (в этом случае sp_cursor заменит имя представления).  
  
## <a name="value-parameter"></a>Параметр value  
 Существует два варианта применения правил для использования *значения* , как упоминалось ранее в разделе arguments:  
  
1.  Можно использовать имя, которое \@ заранее предваряется именем столбца в списке SELECT-List для любых параметров именованного *значения* . Одним из преимуществ такого варианта является то, что не обязательно преобразовывать данные.  
  
2.  Используйте параметр, чтобы отправить полную инструкцию UPDATE или INSERT или использовать несколько параметров для отправки частей инструкции UPDATE или INSERT, которые SQL Server затем будут построены в полной инструкции. Примеры можно найти далее в подразделе «Примеры» этого раздела.  
  
## <a name="examples"></a>Примеры  
  
### <a name="alternative-value-parameter-uses"></a>Альтернативы использованию параметра value  
 Для UPDATE:  
  
 Когда используется один параметр, инструкцию UPDATE можно передать с использованием следующего синтаксиса:  
  
 `[ [ UPDATE <table name> ] SET ] {<column name> = expression} [,...n]`  
  
> [!NOTE]  
>  Если \<table name> указано Update, любое значение, заданное для параметра *Table* , будет пропущено.  
  
 При использовании нескольких параметров первый параметр должен быть строкой в следующем формате:  
  
 `[ SET ] <column name> = expression  [,...n]`  
  
 Последующие параметры должны быть в формате:  
  
 `<column name> = expression  [,...n]`  
  
 В этом случае в \<table name> созданной инструкции UPDATE указана либо по умолчанию в параметре *Table* .  
  
 Для INSERT:  
  
 Если используется один параметр, то инструкцию INSERT можно передать с использованием следующего синтаксиса:  
  
 `[ [ INSERT [INTO] <table name> ] VALUES ] ( <expression> [,...n] )`  
  
> [!NOTE]  
>  Если *\<table name>* указан параметр INSERT, то любое значение, заданное для параметра *Table* , будет пропущено.  
  
 При использовании нескольких параметров первый параметр должен быть строкой в следующем формате:  
  
 `[ VALUES ( ] <expression>  [,...n]`  
  
 Последующие параметры должны быть в формате:  
  
 `expression [,...n]`  
  
 За исключением случаев, когда указан параметр VALUES, в этом случае после последнего выражения должен стоять символ ). В этом случае в *\<table name>* созданной инструкции UPDATE указана либо по умолчанию в параметре *Table* .  
  
> [!NOTE]  
>  Возможно передать один параметр как именованный, то есть «`@VALUES`». В этом случае другие параметры использовать нельзя.  
  
## <a name="see-also"></a>См. также  
 [sp_cursoropen &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursoropen-transact-sql.md)   
 [sp_cursorfetch &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursorfetch-transact-sql.md)   
 [Системные хранимые процедуры (Transact-SQL)](../../relational-databases/system-stored-procedures/system-stored-procedures-transact-sql.md)  
  
  
