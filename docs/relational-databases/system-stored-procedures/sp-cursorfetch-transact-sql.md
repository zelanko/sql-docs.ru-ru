---
description: sp_cursorfetch (Transact-SQL)
title: sp_cursorfetch (Transact-SQL) | Документация Майкрософт
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: system-objects
ms.topic: language-reference
f1_keywords:
- sp_cursorfetch
- sp_cursorfetch_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- sp_cursorfetch
ms.assetid: 14513c5e-5774-4e4c-92e1-75cd6985b6a3
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 7d68223e7ed12477b446934f01b600b840b6651a
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "88447365"
---
# <a name="sp_cursorfetch-transact-sql"></a>sp_cursorfetch (Transact-SQL)
[!INCLUDE [SQL Server](../../includes/applies-to-version/sqlserver.md)]

  Извлекает из базы данных буфер из одной или нескольких строк. Группа строк в этом буфере называется *буфером выборки*курсора. sp_cursorfetch вызывается путем указания ID = 7 в пакете потока табличных данных (TDS).  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
sp_cursorfetch cursor  
    [ , fetchtype[ , rownum [ , nrows] ]]   
```  
  
## <a name="arguments"></a>Аргументы  
 *курсор*  
 Значение *обработчика* , создаваемое [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и возвращаемое sp_cursoropen. *cursor* является обязательным параметром, который вызывает входное значение **int** . Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *fetchtype*  
 Указывает, какой буфер курсора выбирается. *fetchtype* — это необязательный параметр, для которого требуется одно из следующих целочисленных входных значений.  
  
|Значение|Имя|Описание|  
|-----------|----------|-----------------|  
|0x0001|FIRST|Извлекает первый буфер *nrows* строк. Если *nrows* равно 0, курсор помещается перед результирующим набором, а строки не возвращаются.|  
|0x0002|NEXT|Извлекает следующий буфер строк *nrows* .|  
|0x0004|PREV|Извлекает предыдущий буфер строк *nrows* .<br /><br /> Примечание. Использование функции onдля FORWARD_ONLY курсора возвращает сообщение об ошибке, так как FORWARD_ONLY поддерживает только прокрутку в одном направлении.|  
|0x0008|LAST|Извлекает последний буфер строк *nrows* . Если *nrows* равно 0, курсор помещается после результирующего набора и никакие строки не возвращаются.<br /><br /> Примечание. Использование функции LAST для FORWARD_ONLYного курсора возвращает сообщение об ошибке, поскольку FORWARD_ONLY поддерживает только прокрутку в одном направлении.|  
|0x10|ABSOLUTE|Извлекает буфер строк *nrows* , начиная со строки *rownum* .<br /><br /> Примечание. Использование ABSOLUTE для динамического курсора или курсора FORWARD_ONLY возвращает сообщение об ошибке, поскольку FORWARD_ONLY поддерживает только прокрутку в одном направлении.|  
|0x20|RELATIVE|Извлекает буфер строк *nrows* , начиная со строки, которая указана как *rownum* значение строк из первой строки в текущем блоке. В этом случае *rownum* может быть отрицательным числом.<br /><br /> Примечание. использование метода RELATIVE для FORWARD_ONLYного курсора возвращает сообщение об ошибке, так как FORWARD_ONLY поддерживает только прокрутку в одном направлении.|  
|0x80|REFRESH|Перезаполняет буфер из базовых таблиц.|  
|0x100|INFO|Извлекает сведения о курсоре. Эти сведения возвращаются с помощью параметров *rownum* и *nrows* . Поэтому, когда указаны сведения, *rownum* и *nrows* становятся выходными параметрами.|  
|0x200|PREV_NOADJUST|Используется как PREV. Но если вершина результирующего набора встретилась преждевременно, результаты могут отличаться.|  
|0x400|SKIP_UPDT_CNCY|Должен использоваться с одним из других значений *fetchtype* , за исключением info.|  
  
> [!NOTE]  
>  Поддержка значения 0x40 отсутствует.  
  
 Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *rownum*  
 — Необязательный параметр, который используется для указания расположения строки для значений ABSOLUTE и INFO *fetchtype* с использованием только целочисленных значений для входных или выходных данных или и того и другого. *rownum* выступает в качестве смещения строк для относительных битовых значений *fetchtype* . *rownum* игнорируется для всех остальных значений. Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
 *nrows*  
 Необязательный параметр, используемый для указания количества выбираемых строк. Если *nrows* не указан, по умолчанию используется значение 20 строк. Чтобы задать расположение без возврата данных, укажите значение 0. Когда *nrows* применяется к запросу INFO *fetchtype* , он возвращает общее количество строк в этом запросе.  
  
> [!NOTE]  
>  *nrows* игнорируется битовым значением обновления *fetchtype* .  
>   
>  Дополнительные сведения см. в подразделе «Примечания» далее в этом разделе.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 Если указано битовое значение INFO, то могут возвращаться значения, показанные в следующих таблицах.  
  
> [!NOTE]  
>  :   если строки не возвращаются, то содержимое буфера остается прежним.  
  
|*\<rownum>*|Установить в|  
|------------------|------------|  
|Если не открыт|0|  
|Если позиционирован перед результирующим набором|0|  
|Если позиционирован после результирующего набора|-1|  
|Для курсоров KEYSET и STATIC|Абсолютный номер строки в текущей позиции результирующего набора|  
|Для курсоров DYNAMIC|1|  
|Для ABSOLUTE|-1 возвращает последнюю строку в наборе.<br /><br /> -2 возвращает вторую от конца строку в наборе и так далее.<br /><br /> Примечание. Если в этом случае запрашиваются несколько строк, возвращаются две последние строки результирующего набора.|  
  
|*\<nrows>*|Установить в|  
|-----------------|------------|  
|Если не открыт|0|  
|Для курсоров KEYSET и STATIC|Обычно размер текущего набора ключей.<br /><br /> **-m** , если курсор находится в асинхронном создании с *m* строками, найденными до этого момента.|  
|Для курсоров DYNAMIC|-1|  
  
## <a name="remarks"></a>Remarks  
  
## <a name="cursor-parameter"></a>Параметр cursor  
 Перед началом операций выборки по умолчанию позиция курсора находится перед первой строкой результирующего набора.  
  
## <a name="fetchtype-parameter"></a>Параметр fetchtype  
 За исключением SKIP_UPD_CNCY, значения *fetchtype* являются взаимоисключающими.  
  
 Если указано значение SKIP_UPDT_CNCY, то значения столбца отметки времени не записываются в таблицу набора ключей при выборке или обновлении строки. При обновлении строки набора ключей значения столбцов отметки времени остаются в качестве предыдущего значения. При выполнении вставки строки набора ключей значения для столбцов отметки времени не определены.  
  
 Для курсоров типа KEYSET это означает, что в таблице набора ключей имеются значения, установленные во время последней выполненной операции FETCH, если таковая была. В противном случае в ней имеются значения, установленные во время заполнения.  
  
 Для курсоров типа DYNAMIC это означает, что переход с обновлением даст такие же результаты, что и для KEYSET. Для любого другого типа выборки таблица набора ключей усекается. Это означает, что строки будут вставлены с неопределенными значениями отметки времени для одного или нескольких столбцов. Поэтому при запуске процедуры sp_cursorfetch для курсоров DYNAMIC избегайте использования SKIP_UPDT_CNCY для любой операции, отличной от REFRESH.  
  
 Если операция выборки закончилась ошибкой по причине того, что позиция курсора оказалась за границами результирующего набора, позиция курсора устанавливается сразу после последней строки. Если операция выборки закончилась ошибкой по причине того, что позиция курсора оказалась перед результирующим набором, то позиция курсора устанавливается сразу перед первой строкой.  
  
## <a name="rownum-parameter"></a>Параметр rownum  
 При использовании *rownum*буфер заполняется, начиная с указанной строки.  
  
 АБСОЛЮТНОе значение *fetchtype* ссылается на положение *rownum* в пределах всего результирующего набора. Если задано значение ABSOLUTE, то отрицательное число указывает на то, что операция считала строки от конца результирующего набора.  
  
 ОТНОСИТЕЛЬНОе значение *fetchtype* ссылается на позицию *rownum* относительно положения курсора в начале текущего буфера. Если задано значение RELATIVE, то отрицательное число указывает на то, что курсор перемещается назад от текущей позиции курсора.  
  
## <a name="nrows-parameter"></a>Параметр nrows  
 Значения *FETCHTYPE* обновляются и info игнорируют этот параметр.  
  
 При указании значения *FETCHTYPE* First, имеющего *нров* значение 0, курсор помещается перед результирующим набором, не имеющим строк в буфере выборки.  
  
 При указании значения *FETCHTYPE* Last, имеющего значение *нров* , равное 0, курсор помещается после результирующего набора, не имеющего строк в текущем буфере выборки.  
  
 Для значений *FETCHTYPE* следующего, предыдущего, абсолютного, относительного и PREV_NOADJUST *нров* значение 0 недопустимо.  
  
## <a name="rpc-considerations"></a>Замечания по RPC  
 Состояние возврата RPC указывает, является ли параметр размера набора ключей окончательным, то есть заполняется ли набор ключей или временная таблица асинхронно.  
  
 Для параметра состояния RPC устанавливается одно из значений, приведенных в следующей таблице.  
  
|Значение|Описание|  
|-----------|-----------------|  
|0|Процедура успешно выполнена.|  
|0x0001|Процедура завершилась ошибкой.|  
|0x0002|Выборка в отрицательном направлении привела к тому, что позиция курсора оказалась в начале результирующего набора, когда выборка логически должна быть перед результатами.|  
|0x10|Курсор FAST_FORWARD автоматически закрыт.|  
  
 Строки возвращаются в виде типичного результирующего набора: формат столбцов (0x2a), строк (0xd1), за которым следует число обработанных (0xfd). Маркеры метаданных отправляются в том же формате, который указан для sp_cursoropen, то есть 0x81, 0xa5 и токенов 0xa4 для пользователей SQL Server 7,0 и т. д. Индикаторы состояния строк отправляются как скрытые столбцы, аналогично режиму BROWSE, в конце каждой строки с именем столбца rowstat и типом данных INT4. Столбец rowstat имеет одно из значений, приведенных в следующей таблице.  
  
|Значение|Описание|  
|-----------|-----------------|  
|0x0001|FETCH_SUCCEEDED|  
|0x0002|FETCH_MISSING|  
  
 Поскольку протокол TDS не предусматривает способа отправки завершающего столбца состояния без отправки предшествующих столбцов, в отсутствующих столбцах отправляются фиктивные данные (поля, допускающие значение NULL, заполняются этим значением, в поля фиксированной длины записывается 0, пробел или значение по умолчанию для этого столбца соответственно).  
  
 Счетчик строк DONE всегда будет содержать ноль. Сообщение DONE содержит реальное число строк результирующего набора, информационные сообщения или сообщения об ошибках могут появляться между любыми сообщениями TDS.  
  
 Чтобы в потоке TDS возвращались запрошенные метаданные о списке выбора курсора, установите входной флажок RPC RETURN_METADATA в значение 1.  
  
## <a name="examples"></a>Примеры  
  
### <a name="a-using-prev-to-change-a-cursor-position"></a>A. Использование PREV для изменения позиции курсора  
 Предположим, курсор h2 сформирует результирующий набор со следующим содержимым и текущей позицией следующим образом.  
  
```  
row 1 contents      
row 2 contents  
row 3 contents  
row 4 contents  <-- current position  
row 5 contents   
row 6 contents  
```  
  
 Далее, sp_cursorfetch в начале, у которого *nrows* значение 5, логически размещает курсор на две строки перед первой строкой результирующего набора. В таких случаях курсор настраивается так, чтобы начинаться у первой строки и возвращать запрошенное число строк. Часто это означает, что будут возвращены строки, которые были в буфере PRIOR.  
  
> [!NOTE]  
>  Это именно тот случай, когда параметр состояния RPC установлен в значение 2.  
  
### <a name="b-using-prev_noadjust-to-return-fewer-rows-than-prev"></a>Б. Использование PREV_NOADJUST для возврата меньшего числа строк, чем PREV  
 PREV_NOADJUST никогда не включает строки, находящиеся в позиции курсора или за ней в блоке строк, который он возвращает. В случаях, когда предыдущие строки возвращаются после текущей позицией, PREV_NOADJUST Возвращает меньшее количество строк, чем было запрошено в *nrows*. Если ранее в примере A задана текущая позиция, то при использовании PREV процедура sp_cursorfetch(h2, 4, 1, 5) выберет следующие строки:  
  
```  
row1 contents   
row2 contents  
row3 contents  
row4 contents  
row5 contents  
```  
  
 Но в том случае, если используется PREV_NOADJUST, хранимая процедура sp_cursorfetch(h2, 512, 6, 5) выберет только следующие строки:  
  
```  
row1 contents   
row2 contents  
row3 contents   
```  
  
## <a name="see-also"></a>См. также:  
 [sp_cursoropen &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-cursoropen-transact-sql.md)   
 [Системные хранимые процедуры (Transact-SQL)](../../relational-databases/system-stored-procedures/system-stored-procedures-transact-sql.md)  
  
  
