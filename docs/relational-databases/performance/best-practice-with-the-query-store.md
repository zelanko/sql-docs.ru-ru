---
title: Рекомендации по хранилищу запросов | Документация Майкрософт
ms.custom: ''
ms.date: 11/24/2016
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.suite: sql
ms.technology: database-engine
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- Query Store, best practices
ms.assetid: 5b13b5ac-1e4c-45e7-bda7-ebebe2784551
caps.latest.revision: 24
author: MikeRayMSFT
ms.author: mikeray
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017
ms.openlocfilehash: 9bc9c0f916a26a46d2bfc3aaed05ce8e4072f57a
ms.sourcegitcommit: 4cd008a77f456b35204989bbdd31db352716bbe6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2018
ms.locfileid: "39549534"
---
# <a name="best-practice-with-the-query-store"></a>Рекомендации по хранилищу запросов
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

  В этой статье приведены рекомендации по использованию хранилища запросов с вашей рабочей нагрузкой.  
  
##  <a name="SSMS"></a> Используйте последнюю версию [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]  
 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] включает в себя набор пользовательских интерфейсов, предназначенных для настройки хранилища запросов, а также для использования собранных данных о рабочей нагрузке.  
Скачайте последнюю версию [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] [здесь](https://docs.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms).  
  
 Краткое описание того, как использовать хранилище запросов в сценариях устранения неполадок, см. в [блогах @Azureпо хранилищу запросов в Azure](https://azure.microsoft.com/blog/query-store-a-flight-data-recorder-for-your-database/).  
  
##  <a name="Insight"></a> Используйте анализ производительности процессов в Базе данных SQL Azure  
 При запуске хранилища запросов в [!INCLUDE[ssSDS](../../includes/sssds-md.md)] можно использовать **анализ производительности запросов** для анализа потребления DTU в динамике.  
С помощью [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] вы можете получить подробные сведения о потреблении ресурсов всеми вашими запросами, а анализ производительности запросов обеспечивает быстрый и эффективный способ определить их влияние на общее использование DTU для базы данных.  
Дополнительные сведения см. в разделе [Анализ производительности запросов в базе данных SQL Azure](https://azure.microsoft.com/documentation/articles/sql-database-query-performance/).    

##  <a name="using-query-store-with-elastic-pool-databases"></a>Используйте хранилище запросов с пулом эластичных баз данных
Хранилище запросов можно без каких-либо опасений использовать во всех базах данных, даже в плотно упакованных пулах. Все проблемы, связанные с чрезмерным использованием ресурсов, которые могли возникать, когда хранилище запросов было включено для большого количества баз данных в эластичных пулах, были устранены.

##  <a name="Configure"></a> Постоянная адаптация хранилища запросов к вашей рабочей нагрузке  
 Настраивайте хранилище запросов в соответствии с вашей рабочей нагрузкой и требованиями к устранению проблем производительности.   
Параметры по умолчанию подходят для начального использования, но вы должны наблюдать за поведением хранилища запросов с течением времени и соответствующим образом настраивать его конфигурацию:  
  
 ![query-store-properties](../../relational-databases/performance/media/query-store-properties.png "query-store-properties")  
  
 Ниже приведены рекомендации по заданию значений параметров.  
  
 **Максимальный размер (МБ)** . Задает предельный объем пространства данных, который будет занимать хранилище запросов в базе данных.  Это наиболее важный параметр, который непосредственно влияет на режим работы хранилища запросов.  
  
 По мере того как хранилище запросов собирает запросы, планы выполнения и статистику, его размер в базе данных растет, пока не будет достигнут этот предельный объем. Когда это происходит, хранилище запросов автоматически изменяет режим работы на "только чтение" и останавливает сбор новых данных. Это означает, что анализ производительности больше не будет точным.  
  
 Значение по умолчанию (100 МБ) может быть недостаточным, если рабочая нагрузка создает большое количество различных запросов и планов или если вы хотите хранить журнал запросов за более длительный период времени. Отслеживайте текущее использование пространства и увеличивайте максимальный размер (МБ), чтобы предотвратить переход хранилища запросов в режим "только чтение".  Используйте [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] или выполните следующий скрипт, чтобы получить последние сведения о размере хранилища запросов.  
  
```sql 
USE [QueryStoreDB];  
GO  
  
SELECT actual_state_desc, desired_state_desc, current_storage_size_mb,   
    max_storage_size_mb, readonly_reason  
FROM sys.database_query_store_options;  
```  
  
 Следующий скрипт задает новый максимальный размер (МБ).  
  
```sql  
ALTER DATABASE [QueryStoreDB]  
SET QUERY_STORE (MAX_STORAGE_SIZE_MB = 1024);  
```  
  
 **Интервал сбора статистики** . Определяет уровень детализации для собираемой статистики среды выполнения (значение по умолчанию — 1 час). Рекомендуется использовать меньшее значение, если требуется большая степень детализации или меньшее время на обнаружение и устранение проблем, но помните, что это значение будет напрямую влиять на объем данных в хранилище запросов. Чтобы задать другое значение для интервала сбора статистики, используйте SSMS или Transact-SQL:  
  
```sql  
ALTER DATABASE [QueryStoreDB] SET QUERY_STORE (INTERVAL_LENGTH_MINUTES = 60);  
```  
  
 **Порог устаревания запросов (в днях)** . Политика очистки на основе времени, которая управляет сроком хранения статистики среды выполнения и неактивных запросов.  
По умолчанию для хранилища запросов настроено хранение данных в течение 30 дней, что может быть излишне долго для вашего сценария.  
  
 Старайтесь не хранить исторические данные, которые не планируется использовать. Это позволит снизить переходы в состояние только чтения. Объем данных в хранилище запросов, а также время на обнаружение и устранение проблем будут более предсказуемыми. Используйте [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] или следующий скрипт, чтобы настроить политику очистки на основе времени:  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 90));  
```  
  
 **Режим очистки на основе размера.** Указывает, должна ли происходить автоматическая очистка, когда объем данных в хранилище запросов достигнет предельного значения.  
  
 Настоятельно рекомендуется активировать очистку на основе размера, чтобы хранилище запросов всегда работало в режиме чтения и записи и собирало последние данные.  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (SIZE_BASED_CLEANUP_MODE = AUTO);  
```  
  
 **Режим записи хранилища запросов.** Задает политику записи запросов для хранилища запросов.  
  
-   **All** — записываются все запросы. Это параметр по умолчанию.  
  
-   **Auto** — редкие запросы и запросы с незначительной длительностью компиляции и выполнения игнорируются. Пороговые значения для числа выполнений, длительности компиляции и времени выполнения определяются внутренним образом.  
  
-   **None** — хранилище запросов прекращает запись новых запросов.  
  
 Следующий скрипт задает режим записи запросов как Auto (автоматически).  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (QUERY_CAPTURE_MODE = AUTO);  
```  
  
## <a name="how-to-start-with-query-performance-troubleshooting"></a>Как приступить к устранению проблем производительности запросов  
 Как показано на следующей схеме, рабочий процесс устранения неполадок в хранилище довольно простой.  
  
 ![query-store-troubleshooting](../../relational-databases/performance/media/query-store-troubleshooting.png "query-store-troubleshooting")  
  
 Включите хранилище запросов с помощью [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] , как описано в предыдущем разделе, или выполните следующую инструкцию [!INCLUDE[tsql](../../includes/tsql-md.md)] :  
  
```sql  
ALTER DATABASE [DatabaseOne] SET QUERY_STORE = ON;  
```  
  
 Сбор хранилищем запросов набора данных, который точно представляет рабочую нагрузку, может занять некоторое время. Обычно одного дня достаточно даже для очень сложных рабочих нагрузок. Однако вы можете приступить к исследованию данных и идентификации запросов, требующих вашего внимания, сразу после включения этой функции.   
Перейдите во вложенную папку Query Store в узле базы данных в обозревателе объектов [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] , чтобы открыть представления по устранению неполадок для конкретных сценариев.   
Представления хранилища запросов[!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] работают с набором метрик выполнения, каждая из которых выражается в виде какой-либо из следующих статистических функций.  
  
|[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]|Метрика выполнения|Статистическая функция|  
|----------------------|----------------------|------------------------|  
|[!INCLUDE[ssSQL15](../../includes/sssql15-md.md)]|CPU time (время ЦП), Duration (длительность), Execution Count (число выполнений), Logical Reads (число логических операций чтения), Logical writes (число логических операций записи), Memory consumption (потребление памяти), Physical Reads (число физических операций чтения), CLR time (время среды CLR), Degree of Parallelism (DOP) (степень параллелизма) и Row count (число строк)|Average (среднее), Maximum (максимум), Minimum (минимум), Standard Deviation (стандартное отклонение), Total (всего)|
|[!INCLUDE[ssSQL17](../../includes/sssql17-md.md)]|CPU time (время ЦП), Duration (длительность), Execution Count (число выполнений), Logical Reads (число логических операций чтения), Logical writes (число логических операций записи), Memory consumption (потребление памяти), Physical Reads (число физических операций чтения), CLR time (время среды CLR), Degree of Parallelism (DOP) (степень параллелизма), Row count (число строк), Log memory (память, занимаемая журналом), TempDB memory (память, занимаемая базой данных TempDB) и Wait times (время ожидания)|Average (среднее), Maximum (максимум), Minimum (минимум), Standard Deviation (стандартное отклонение), Total (всего)|
  
 На следующем рисунке показано, как найти представления хранилища запросов.  
  
 ![query-store-views](../../relational-databases/performance/media/query-store-views.png "query-store-views")  
  
 В следующей таблице поясняется, когда следует использовать каждое из представлений хранилища запросов.  
  
|Представление SSMS|Сценарий|  
|---------------|--------------|  
|Regressed Queries (регрессивные запросы)|Выявите запросы, метрики выполнения для которых недавно регрессировали (т. е. стали хуже). <br />Используйте это представление для сопоставления наблюдаемых проблем производительности в приложении с фактическими запросами, которые необходимо улучшить или исправить.|  
|Overall Resource Consumption (общее потребление ресурсов)|Анализируйте общее потребление ресурсов базы данных для любой из метрик выполнения.<br />Используйте это представление для определения шаблонов ресурсов (дневная и ночная рабочие нагрузки) и оптимизации общего потребления для базы данных.|  
|Top Resource Consuming Queries (запросы, потребляющие больше всего ресурсов)|Выберите интересующую метрику выполнения и определите запросы, которые имели максимальные значения в указанном промежутке времени. <br />Используйте это представление, чтобы сосредоточиться на наиболее важных запросах, которые оказывают самое большое воздействие на потребление ресурсов базы данных.|  
|Запросы с принудительными планами|Здесь приводятся планы, которые были принудительно выполнены ранее с помощью Query Store. <br />В этом представлении можно быстро получить доступ ко всем текущим принудительным планам.|  
|Запросы с высокой вариативностью|Анализ запросов с высокой вариативностью выполнения с учетом всех доступных параметров, таких как длительность, время ЦП, ввод-вывод данных и использование памяти в соответствующем временном интервале.<br />Используйте это представление для выявления запросов с сильно варьируемой производительностью, которые могут влиять на работу пользователей в приложениях.|  
|Tracked Queries (отслеживаемые запросы)|Отслеживайте выполнение наиболее важных запросов в реальном времени. Как правило, эти представления используются, когда имеются запросы с принудительными планами и требуется убедиться в стабильной производительности запросов.|
  
> [!TIP]  
>  Подробное описание того, как использовать [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)] для выявления запросов с самым большим потреблением ресурсов и исправления тех, чьи метрики ухудшились из-за изменения плана, см. в [блогах @Azureпо хранилищу запросов в Azure](https://azure.microsoft.com/blog/query-store-a-flight-data-recorder-for-your-database/).  
  
 При указании запроса с недостаточной производительностью необходимые действия будут зависеть от характера проблемы.  
  
-   Если запрос выполнялся с несколькими планами и последний план оказался значительно хуже предыдущего, можно применить механизм принудительного использования плана. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] попытается принудительно применить план в оптимизаторе. Если это не удастся сделать, будет порождено событие XEvent и оптимизация будет выполнена как обычно. 
  
     ![query-store-force-plan](../../relational-databases/performance/media/query-store-force-plan.png "query-store-force-plan")  

> [!NOTE]  
> На представленном выше графике могут отображаться различные формы, каждая из которых соответствует определенному статусу:<br />  
> |Фигурная|Значение|  
> |-------------------|-------------|
> |Circle|Запрос выполнен (обычное выполнение успешно завершено)|
> |Square|Запрос отменен (клиент прервал выполнение)|
> |Triangle|Сбой (выполнение прервано с исключением)|
> Кроме того, размер фигуры отражает количество выполнений запроса за указанный интервал времени (чем больше это количество, тем больше размер фигуры).  

-   Вы можете решить, что в запросе отсутствует индекс для оптимального выполнения. Эта информация будет отображена в плане выполнения запроса. Создайте отсутствующий индекс и проверьте производительность запросов с помощью хранилища запросов.  
  
     ![query-store-show-plan](../../relational-databases/performance/media/query-store-show-plan.png "query-store-show-plan")  
  
     При выполнении рабочей нагрузки в [!INCLUDE[ssSDS](../../includes/sssds-md.md)]подпишитесь на помощник по построению индексов [!INCLUDE[ssSDS](../../includes/sssds-md.md)] , чтобы автоматически получать рекомендации по индексам.  
  
-   В некоторых случаях можно принудительно выполнить перекомпиляцию статистики, если вы видите, что разница между предполагаемым и фактическим числом строк в плане выполнения является существенной.  
  
-   Перепишите проблемные запросы. Например, чтобы воспользоваться преимуществами параметризации запросов или для реализации более оптимальной логики.  
  
##  <a name="Verify"></a> Проверяйте непрерывность сбора данных запросов хранилищем запросов  
 Хранилище запросов может без предупреждения изменять режим работы. Вы должны постоянно наблюдать за состоянием хранилища запросов, чтобы знать, что хранилище запросов работает, и предпринимать действия для исключения сбоев по предотвращаемым причинам. Выполните следующий запрос, чтобы определить режим работы и просмотреть наиболее актуальные параметры.  
  
```sql
USE [QueryStoreDB];  
GO  
  
SELECT actual_state_desc, desired_state_desc, current_storage_size_mb,   
    max_storage_size_mb, readonly_reason, interval_length_minutes,   
    stale_query_threshold_days, size_based_cleanup_mode_desc,   
    query_capture_mode_desc  
FROM sys.database_query_store_options;  
```  
  
 Разница между `actual_state_desc` и `desired_state_desc` показывает, что произошло автоматическое изменение режима работы. Самое частое изменение — автоматическое переключение хранилища запросов в режим "только чтение". В исключительно редких случаях хранилище запросов может оказаться в состоянии ошибки из-за внутренних ошибок.  
  
 Если фактическое состояние является режимом только чтения, используйте столбец **readonly_reason** для определения основной причины. Скорее всего, вы обнаружите, что хранилище запросов перешло в режим "только чтение" из-за превышения квоты на размер. В этом случае в столбце **readonly_reason** будет значение 65 536. Другие причины см. в разделе [sys.database_query_store_options (Transact-SQL)](../../relational-databases/system-catalog-views/sys-database-query-store-options-transact-sql.md).  
  
 Рассмотрите следующие действия, чтобы переключить хранилище запросов в режим чтения и записи и активировать сбор данных.  
  
-   Увеличение максимального размера хранилища с помощью параметра **MAX_STORAGE_SIZE_MB** инструкции **ALTER DATABASE**.  
  
-   Очистка данных в хранилище запросов с помощью следующей инструкции.  
  
    ```sql  
    ALTER DATABASE [QueryStoreDB] SET QUERY_STORE CLEAR;  
    ```  
  
Можно применить одно или оба этих действия, выполнив следующую инструкцию, которая явно изменяет режим работы обратно в режим чтения и записи.  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (OPERATION_MODE = READ_WRITE);  
```  
  
 Выполните следующие упреждающие действия.  
  
-   Вы можете предотвратить автоматические изменения режима работы, применяя рекомендации. Если обеспечить, чтобы размер хранилища запросов всегда был меньше максимально допустимого значения, это существенно уменьшит вероятность перехода в режим "только чтение". Активируйте политику на основе размера, как описано в руководстве по [настройке хранилища запросов](#Configure), чтобы хранилище запросов автоматически очищало данные при достижении предельного размера.  
  
-   Чтобы обеспечить сохранение последних данных, настройте политику на основе времени для регулярного удаления устаревшей информации.  
  
-   И наконец, следует рассмотреть возможность установки автоматического режима записи запросов, так как в нем отфильтровываются запросы, которые обычно меньше всего соответствуют вашей рабочей нагрузке.  
  
### <a name="error-state"></a>Состояние ошибки  
 Чтобы восстановить хранилище запросов, попробуйте явно установить режим чтения и записи и проверьте фактическое состояние еще раз.  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (OPERATION_MODE = READ_WRITE);    
GO  
  
SELECT actual_state_desc, desired_state_desc, current_storage_size_mb,   
    max_storage_size_mb, readonly_reason, interval_length_minutes,   
    stale_query_threshold_days, size_based_cleanup_mode_desc,   
    query_capture_mode_desc  
FROM sys.database_query_store_options;  
```  
  
 Если проблема сохраняется, это означает повреждение данных в хранилище запросов, сохраненных на диске.
 
 Хранилище запросов можно освободить, выполнив хранимую процедуру **sp_query_store_consistency_check** в соответствующей базе данных.
 
 Если это не помогло, можно попробовать очистить хранилище запросов перед запросом режима чтения и записи.  
  
```sql  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE CLEAR;  
GO  
  
ALTER DATABASE [QueryStoreDB]   
SET QUERY_STORE (OPERATION_MODE = READ_WRITE);    
GO  
  
SELECT actual_state_desc, desired_state_desc, current_storage_size_mb,   
    max_storage_size_mb, readonly_reason, interval_length_minutes,   
    stale_query_threshold_days, size_based_cleanup_mode_desc,   
    query_capture_mode_desc  
FROM sys.database_query_store_options;  
```  
  
## <a name="set-the-optimal-query-capture-mode"></a>Установите оптимальный режим записи запросов  
 Наиболее важные данные следует хранить в хранилище запросов. В следующей таблице описаны типичные сценарии для каждого режима записи запросов.  
  
|Режим записи запросов|Сценарий|  
|------------------------|--------------|  
|All|Тщательно анализируйте рабочую нагрузку на основе форм всех запросов и частоты их выполнения, а также других статистических данных.<br /><br /> Выявление новых запросов в рабочей нагрузке.<br /><br /> Обнаруживайте, используются ли динамические запросы для определения возможностей для пользовательской или автоматической параметризации.|  
|Auto|Сосредоточьте внимание на важных и действенных запросах; это запросы, которые выполняются регулярно или потребляют ресурсы в значительных объемах.|  
|None|Вы уже записали набор запросов, который хотите отслеживать в среде выполнения, и хотите исключить отвлекающие факторы, которые могут быть внесены другими запросами.<br /><br /> Значение None подходит для тестовых сред и сред тестирования производительности.<br /><br /> Кроме того, значение None подходит для поставщиков программного обеспечения, поставляющих конфигурацию хранилища запросов, настроенную для наблюдения за рабочей нагрузкой приложений.<br /><br /> Значение None следует использовать с осторожностью, поскольку можно упустить возможность отслеживания и оптимизации важных новых запросов. Старайтесь не использовать None, если этого не требуется в конкретном сценарии.|  
  
## <a name="keep-the-most-relevant-data-in-query-store"></a>Храните наиболее важные данные в хранилище запросов  
 Настройте хранилище запросов таким образом, чтобы в нем содержались только нужные данные, и оно будет выполняться непрерывно, предоставляя прекрасные возможности для устранения неполадок с минимальным воздействием на обычную рабочую нагрузку.  
В следующей таблице приведены рекомендации.  
  
|Рекомендации|Настройка|  
|-------------------|-------------|  
|Ограничение сохраненных исторических данных.|Настройте политику на основе времени для активации автоматической очистки.|  
|Отфильтровывайте несущественные запросы.|Настройте автоматический режим записи запросов.|  
|Удаляйте наименее важные запросы по достижении максимального размера.|Активируйте политику очистки на основе размера.|  
  
##  <a name="Parameterize"></a> Старайтесь не использовать запросы без параметров  
За исключением случаев, когда этого никак нельзя избежать (например, при динамическом анализе), использовать запросы без параметров не рекомендуется.  Кэшированные планы не могут использоваться повторно, что заставляет оптимизатор запросов компилировать запросы для каждого уникального текста запроса. См. [рекомендации по использованию принудительной параметризации](../../relational-databases/query-processing-architecture-guide.md#ForcedParamGuide).  
Кроме того, хранилище запросов может быстро превысить размер квоты из-за потенциально большого количества разных текстов запросов и, следовательно, большого количества разных планов выполнения с аналогичной формой.  
В результате производительность рабочей нагрузки может стать неудовлетворительной и хранилище запросов может перейти в режим "только чтение" или может постоянно удалять данные в попытке справиться с входящими запросами.  
  
Рассмотрите следующие варианты.  

-   Параметризация запросов везде, где это возможно, например перенос запросов в хранимую процедуру или sp_executesql. См. дополнительные сведения о [параметрах и повторном использовании планов выполнения](../../relational-databases/query-processing-architecture-guide.md#PlanReuse).    
  
-   Использование параметра [**Оптимизировать для нерегламентированной рабочей нагрузки**](../../database-engine/configure-windows/optimize-for-ad-hoc-workloads-server-configuration-option.md), если рабочая нагрузка содержит много нерегламентированных пакетов для однократного использования с разными планами запроса.  
  
    -   Сравните число уникальных значений query_hash с общим числом записей в sys.query_store_query. Если этот коэффициент близок к 1, ваша нерегламентированная рабочая нагрузка создает разные запросы.  
  
-   Применение [**принудительной параметризации**](../../relational-databases/query-processing-architecture-guide.md#ForcedParam) для базы данных или подмножества запросов, если количество разных планов запроса невелико.  
  
    -   Используйте [структуру плана](../../relational-databases/performance/specify-query-parameterization-behavior-by-using-plan-guides.md), чтобы применить принудительную параметризацию только в выбранном запросе.  
  
    -   Принудительная параметризация настраивается с помощью параметра базы данных [PARAMETERIZATION](../../relational-databases/databases/database-properties-options-page.md#miscellaneous), если количество разных планов запросов в рабочей нагрузке невелико: соотношение между числом отличных параметров query_hash и общим числом записей в sys.query_store_query должно быть намного меньше 1.  
  
-   Задание автоматического **режима записи запросов** , чтобы динамические запросы с небольшим потреблением ресурсов отфильтровывались автоматически.  
  
##  <a name="Drop"></a> Старайтесь не использовать шаблоны DROP и CREATE при обслуживании содержащих объектов для запросов  
Хранилище запросов связывает запись запроса с содержащим объектом (хранимой процедурой, функцией или триггером).  При повторном создании содержащего объекта будет создана новая запись запроса для того же текста запроса. Это будет препятствовать отслеживанию статистики производительности для этого запроса с течением времени и использованию механизма форсирования планов. Чтобы избежать этого, используйте процесс `ALTER <object>` для изменения определения содержащего объекта везде, где это возможно.  
  
##  <a name="CheckForced"></a> Регулярно проверяйте состояние принудительных планов  

Форсирование плана — это удобный механизм, позволяющий исправлять производительность важных запросов и делать их более предсказуемыми. Тем не менее, как и в случае подсказок планов и структур планов, не гарантируется, что это будет использовано в будущих выполнениях. Обычно, когда схема базы данных изменяется так, что объекты, упоминаемые в плане выполнения, изменяются или удаляются, принудительное выполнение плана будет начинаться сбоем. В этом случае [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] возвращается к перекомпиляции запроса, а фактическая причина сбоя принудительного выполнения отображается в [sys.query_store_plan](../../relational-databases/system-catalog-views/sys-query-store-plan-transact-sql.md). Следующий запрос возвращает информацию о принудительно выполненных планах.  
  
```sql  
USE [QueryStoreDB];  
GO  
  
SELECT p.plan_id, p.query_id, q.object_id as containing_object_id,  
    force_failure_count, last_force_failure_reason_desc  
FROM sys.query_store_plan AS p  
JOIN sys.query_store_query AS q on p.query_id = q.query_id  
WHERE is_forced_plan = 1;  
```  
  
 Полный список причин см. в разделе [sys.query_store_plan](../../relational-databases/system-catalog-views/sys-query-store-plan-transact-sql.md). Кроме того, можно использовать XEvent **query_store_plan_forcing_failed** для отслеживания и устранения неполадок с принудительным выполнением планов.  
  
##  <a name="Renaming"></a> Избегайте переименования баз данных при наличии запросов с принудительными планами  

 Планы выполнения ссылаются на объекты с помощью трехкомпонентных имен (`database.schema.object`).   

При переименовании базы данных произойдет сбой принудительного выполнения планов, что приведет к повторной компиляции при выполнении всех последующих запросов.  

##  <a name="Recovery"></a> Использование флагов трассировки на критически важных серверах для оптимизации восстановления после сбоев
 
Глобальные флаги трассировки 7745 и 7752 можно использовать для повышения производительности хранилища запросов в сценариях обеспечения высокой доступности и аварийного восстановления. Дополнительные сведения см. в разделе [Флаги трассировки](../..//t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql.md).
  
Флаг трассировки 7745 будет препятствовать поведению по умолчанию, при котором хранилище запросов записывает данные на диск до того, как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сможет завершить работу.
  
Флаг трассировки 7752 обеспечивает асинхронную загрузку хранилища запросов, а также разрешает [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] выполнять запросы до полной загрузки хранилища запросов. Поведение хранилища запросов по умолчанию препятствует запуску запросов до восстановления хранилища запросов.

> [!IMPORTANT]
> Если вы используете хранилище запросов для JIT-анализа рабочих нагрузок в [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)], запланируйте установку исправлений масштабируемости производительности (см. [статью базы знаний 4340759](http://support.microsoft.com/help/4340759)) как можно скорее. 

## <a name="see-also"></a>См. также:  
 [Query Store Catalog Views (Transact-SQL) ](../../relational-databases/system-catalog-views/query-store-catalog-views-transact-sql.md)  (Представления каталогов хранилища запросов (Transact-SQL))  
 [Query Store Stored Procedures (Transact-SQL)](../../relational-databases/system-stored-procedures/query-store-stored-procedures-transact-sql.md)  (Хранимые процедуры хранилища запросов (Transact-SQL))  
 [Использование хранилища запросов с выполняющейся в памяти OLTP](../../relational-databases/performance/using-the-query-store-with-in-memory-oltp.md)   
 [Monitoring Performance By Using the Query Store](../../relational-databases/performance/monitoring-performance-by-using-the-query-store.md)     
 [Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)  
  
