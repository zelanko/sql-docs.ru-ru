---
title: Построение поисковых инструкций | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- searched statements [ODBC]
- ODBC cursor library [ODBC], statement processing
- ODBC cursor library [ODBC], searched statements
- SQL statements [ODBC], cursor library
- cursor library [ODBC], statement processing
- cursor library [ODBC], searched statements
- SQL statements [ODBC], searched statements
ms.assetid: e429254c-c43f-4fbf-98b2-5f1ed53501ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: b8b9a27aa9fc84aadc6659993de3e12e269631d2
ms.sourcegitcommit: 6fd8c1914de4c7ac24900fe388ecc7883c740077
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81284744"
---
# <a name="constructing-searched-statements"></a>Построение поисковых выражений
> [!IMPORTANT]  
>  Эта функция будет удалена в следующей версии Windows. Избегайте использования этой функции в новых разработках и запланируйте изменение приложений, которые в настоящее время используют эту функцию. Корпорация Майкрософт рекомендует использовать функцию курсора драйвера.  
  
 Для поддержки позиционированных инструкций UPDATE и DELETE библиотека курсоров формирует поисковую инструкцию **Update** или **Delete** из позиционированной инструкции. Для поддержки вызовов **SQLGetData** в блоке данных Библиотека курсоров создает поисковую инструкцию **SELECT** для создания результирующего набора, содержащего текущую строку данных. В каждой из этих инструкций предложение **WHERE** перечисляет значения, хранящиеся в кэше для каждого привязанного столбца, который возвращает SQL_PRED_SEARCHABLE или SQL_PRED_BASIC для идентификатора поля SQL_DESC_SEARCHABLE в **SQLColAttribute**.  
  
> [!CAUTION]  
>  Предложение **WHERE** , созданное библиотекой курсоров для обнаружения текущей строки, может не распознать какие-либо строки, указывать другую строку или указывать более одной строки.  
  
 Если инструкция позиционированного обновления или удаления затрагивает более одной строки, Библиотека курсоров обновляет массив состояния строк только для строки, в которой находится курсор, и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операций курсора). Если инструкция не определяет какие-либо строки, Библиотека курсоров не обновляет массив состояния строк и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операций курсора). Приложение может вызвать **SQLRowCount** , чтобы определить количество строк, которые были обновлены или удалены.  
  
 Если предложение **SELECT** , используемое для позиционирования курсора для вызова **SQLGetData** , определяет более одной строки, **SQLGetData** не гарантирует возвращение правильных данных. Если не удается найти ни одной строки, **SQLGetData** возвращает SQL_NO_DATA.  
  
 Если приложение соответствует следующим рекомендациям, предложение **WHERE** , созданное библиотекой курсоров, должно однозначно идентифицировать текущую строку, за исключением случаев, когда источник данных содержит дублирующиеся строки.  
  
-   **Привяжите столбцы, которые уникально идентифицируют строку.** Если привязанные столбцы не уникально идентифицируют строку, то предложение **WHERE** , созданное библиотекой курсоров, может определять несколько строк. В инструкции позиционированного обновления или удаления такое предложение может привести к обновлению или удалению более чем одной строки. При вызове **SQLGetData**такое предложение может привести к тому, что драйвер возвратит данные для неверной строки. Привязка всех столбцов в уникальном ключе гарантирует уникальную идентификацию каждой строки.  
  
-   **Достаточно большой объем буферов данных, чтобы усечение не произошло.** Кэш библиотеки курсоров — это копия значений в буферах наборов строк, привязанных к результирующему набору с помощью **SQLBindCol**. Если данные усекаются при помещении в эти буферы, они также будут обрезаны в кэше. Предложение **WHERE** , созданное из усеченных значений, может неправильно указывать базовую строку в источнике данных.  
  
-   **Укажите буферы длины, отличные от NULL, для двоичных данных C.** Библиотека курсоров выделяет буферы длины в своем кэше только в том случае, если аргумент *StrLen_or_IndPtr* в **SQLBindCol** имеет значение, отличное от NULL. Если аргумент *TargetType* имеет SQL_C_BINARY, библиотеке курсоров требуется длина двоичных данных для создания предложения **WHERE** из данных. Если буфер длины для SQL_C_BINARY столбца отсутствует и приложение вызывает **SQLGetData** или пытается выполнить инструкцию позиционированного обновления или удаления, Библиотека курсоров возвращает SQL_ERROR и SQLSTATE SL014 (был выдан позиционированный запрос, а не все поля счетчика столбцов были помещены в буфер).  
  
-   **Укажите буферы длины, отличные от NULL, для столбцов, допускающих значение null.** Библиотека курсоров выделяет буферы длины в своем кэше только в том случае, если аргумент *StrLen_or_IndPtr* в **SQLBindCol** имеет значение, отличное от NULL. Поскольку SQL_NULL_DATA хранится в буфере длины, Библиотека курсоров предполагает, что любой столбец, для которого не задан буфер длины, не допускает значения NULL. Если столбец Length не указан для столбца, допускающего значение null, то библиотека курсоров конструирует предложение **WHERE** , использующее значение данных для столбца. Это предложение не будет правильно указывать строку.
