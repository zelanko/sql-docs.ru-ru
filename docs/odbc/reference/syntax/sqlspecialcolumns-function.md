---
title: Функция SQLSpecialColumns | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSpecialColumns
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSpecialColumns
helpviewer_keywords:
- SQLSpecialColumns function [ODBC]
ms.assetid: bb2d9f21-bda0-4e50-a8be-f710db660034
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 826630e1d344322268a2f2638310b3a1e182de6d
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81287174"
---
# <a name="sqlspecialcolumns-function"></a>SQLSpecialColumns, функция
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: открытая группа  
  
 **Сводка**  
 **SQLSpecialColumns** получает следующие сведения о столбцах в указанной таблице:  
  
-   Оптимальный набор столбцов, однозначно определяющий строку в таблице.  
  
-   Столбцы, автоматически обновляемые при обновлении любого значения в строке транзакцией.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSpecialColumns(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   IdentifierType,  
     SQLCHAR *     CatalogName,  
     SQLSMALLINT   NameLength1,  
     SQLCHAR *     SchemaName,  
     SQLSMALLINT   NameLength2,  
     SQLCHAR *     TableName,  
     SQLSMALLINT   NameLength3,  
     SQLSMALLINT   Scope,  
     SQLSMALLINT   Nullable);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *идентифиертипе*  
 Входной Тип возвращаемого столбца. Необходимо установить одно из следующих значений.  
  
 SQL_BEST_ROWID: Возвращает оптимальный столбец или набор столбцов, которые, получая значения из столбца или столбцов, позволяют однозначно идентифицировать любую строку в указанной таблице. Столбец может быть либо псевдо-столбцом, специально предназначенным для этой цели (например, в Oracle ROWID, либо входным TID), либо столбцом или столбцам любого уникального индекса для таблицы.  
  
 SQL_ROWVER: Возвращает столбец или столбцы в указанной таблице (если таковые имеются), которые автоматически обновляются источником данных, когда любое значение в строке обновляется любой транзакцией (например, в Склбасе ROWID или Sybase TIMESTAMP).  
  
 *CatalogName*  
 Входной Имя каталога для таблицы. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает таблицы, не имеющие каталогов. *CatalogName* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *CatalogName* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *CatalogName* является обычным аргументом. он обрабатывается буквально, и его регистр важен. Дополнительные сведения см. [в разделе аргументы в функциях каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 Входной Длина в символах **CatalogName*.  
  
 *SchemaName*  
 Входной Имя схемы для таблицы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает те таблицы, которые не имеют схем. *SchemaName* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, то объект *SchemaName* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, то *SchemaName* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength2*  
 Входной Длина в символах **SchemaName*.  
  
 *TableName*  
 Входной Имя таблицы. Этот аргумент не может быть пустым указателем. *TableName* не может содержать шаблон поиска строки.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID имеет значение SQL_TRUE, *TableName* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, то *TableName* является обычным аргументом; он обрабатывается буквально, и его регистр важен.  
  
 *NameLength3*  
 Входной Длина в символах **TableName*.  
  
 *Область*  
 Входной Минимальная требуемая область ROWID. Возвращаемый ROWID может быть в большей области. Должна быть одной из следующих:  
  
 SQL_SCOPE_CURROW: значение ROWID гарантировано должно быть допустимым только при размещении в этой строке. Позднее повторное выделение с помощью ROWID может не возвращать строку, если строка была обновлена или удалена другой транзакцией.  
  
 SQL_SCOPE_TRANSACTION: ROWID гарантированно действителен в течение текущей транзакции.  
  
 SQL_SCOPE_SESSION: в течение сеанса (за пределами транзакции) гарантируется допустимость ROWID.  
  
 *Допускает значения NULL*  
 Входной Определяет, следует ли возвращать специальные столбцы, которые могут иметь значение NULL. Должна быть одной из следующих:  
  
 SQL_NO_NULLS: исключите специальные столбцы, которые могут иметь значения NULL. Некоторые драйверы не поддерживают SQL_NO_NULLS, и эти драйверы будут возвращать пустой результирующий набор, если был указан параметр SQL_NO_NULLS. Приложения должны быть подготовлены для этого случая и запрашивать SQL_NO_NULLS только в случае крайней необходимости.  
  
 SQL_NULLABLE: возвращают специальные столбцы, даже если они могут иметь значения NULL.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSpecialColumns** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLSpecialColumns** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|В *статеменсандле*был открыт курсор, а также был вызван **SQLFetch** или **SQLFetchScroll** . Эта ошибка возвращается диспетчером драйверов, если **SQLFetch** или **SQLFetchScroll** не вернул SQL_NO_DATA и возвращается драйвером, если **SQLFetch** или **SQLFetchScroll** вернул SQL_NO_DATA.<br /><br /> В *статеменсандле*был открыт курсор, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере * \*MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *статеменсандле*. Затем функция была вызвана в *статеменсандле*.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY009|Недопустимое использование пустого указателя|Аргумент *TableName* был пустым указателем.<br /><br /> Атрибуту инструкции SQL_ATTR_METADATA_ID было присвоено значение SQL_TRUE, аргумент *CatalogName* был пустым указателем, а SQL_CATALOG_NAME *инфотипе* возвращает, что эти имена каталогов поддерживаются.<br /><br /> (DM) атрибуту инструкции SQL_ATTR_METADATA_ID было присвоено значение SQL_TRUE, а аргумент *SchemaName* — пустой указатель.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта функция все еще выполнялась при вызове **SQLSpecialColumns** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение одного из аргументов длины меньше 0, но не равно SQL_NTS.<br /><br /> Длина значения одного из аргументов длины превышает максимальную длину для соответствующего имени. Максимальная длина каждого имени может быть получена путем вызова **SQLGetInfo** со значениями *инфотипе* : SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN или SQL_MAX_TABLE_NAME_LEN.|  
|HY097|Тип столбца вне допустимого диапазона|(DM) указано недопустимое значение *идентифиертипе* .|  
|HY098|Тип области вне допустимого диапазона|(DM) указано недопустимое значение *области* .|  
|HY099|Тип Nullable вне допустимого диапазона|(DM) указано недопустимое значение, *допускающее значение NULL* .|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Указан каталог, а драйвер или источник данных не поддерживает каталоги.<br /><br /> Указана схема, и драйвер или источник данных не поддерживают схемы.<br /><br /> Сочетание текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживалось драйвером или источником данных.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул запрошенный результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 Если аргумент *идентифиертипе* имеет значение SQL_BEST_ROWID, **SQLSpecialColumns** возвращает столбец или столбцы, однозначно идентифицирующие каждую строку в таблице. Эти столбцы всегда можно использовать в предложении *SELECT-List* или **WHERE** . **SQLColumns**, который используется для возвращения различных сведений о столбцах таблицы, не обязательно возвращает столбцы, которые однозначно идентифицируют каждую строку, или столбцы, которые автоматически обновляются, когда транзакция обновляется любым значением в строке. Например, **SQLColumns** может не возвращать столбец с псевдо-столбцом Oracle. Именно поэтому **SQLSpecialColumns** используется для возврата этих столбцов. Дополнительные сведения см. в разделе [использование данных каталога](../../../odbc/reference/develop-app/uses-of-catalog-data.md).  
  
> [!NOTE]  
>  Дополнительные сведения об общем использовании, аргументах и возвращаемых данных функций каталога ODBC см. в разделе [функции каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 Если нет столбцов, уникально идентифицирующих каждую строку в таблице, **SQLSpecialColumns** возвращает набор строк без строк. последующий вызов **SQLFetch** или **SQLFetchScroll** в инструкции возвращает SQL_NO_DATA.  
  
 Если аргументы *идентифиертипе*, *Scope*или *Nullable* определяют характеристики, которые не поддерживаются источником данных, **SQLSpecialColumns** возвращает пустой результирующий набор.  
  
 Если для атрибута SQL_ATTR_METADATA_ID инструкции задано значение SQL_TRUE, аргументы *CatalogName*, *SchemaName*и *TableName* рассматриваются как идентификаторы, поэтому в определенных ситуациях им не могут быть присвоены пустые указатели. (Дополнительные сведения см. [в разделе аргументы в функциях каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).)  
  
 **SQLSpecialColumns** возвращает результаты в виде стандартного результирующего набора, упорядоченного по области.  
  
 Следующие столбцы были переименованы для ODBC *3. x*. Изменения имени столбца не влияют на обратную совместимость, так как приложения привязаны по номеру столбца.  
  
|Столбец ODBC 2,0|Столбец ODBC *3. x*|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|LENGTH|BUFFER_LENGTH|  
|SCALE|DECIMAL_DIGITS|  
  
 Чтобы определить фактическую длину COLUMN_NAME столбца, приложение может вызвать **SQLGetInfo** с параметром SQL_MAX_COLUMN_NAME_LEN.  
  
 В следующей таблице перечислены столбцы результирующего набора. Дополнительные столбцы, превышающие столбец 8 (PSEUDO_COLUMN), могут быть определены драйвером. Приложение должно получить доступ к столбцам, относящимся к драйверу, выполнив подсчет с конца результирующего набора, а не указав явную порядковую точку. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|ОБЛАСТЬ (ODBC 1,0)|1|Smallint|Фактическая область ROWID. Содержит одно из следующих значений:<br /><br /> SQL_SCOPE_CURROW SQL_SCOPE_TRANSACTION SQL_SCOPE_SESSION<br /><br /> Если *идентифиертипе* имеет значение SQL_ROWVER, возвращается null. Описание каждого значения см. в описании *области* в «синтаксисе» выше в этом разделе.|  
|COLUMN_NAME (ODBC 1,0)|2|Varchar, не РАВНый NULL|Имя столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|DATA_TYPE (ODBC 1,0)|3|Smallint, не NULL|Тип данных SQL. Это может быть тип данных ODBC SQL или тип данных SQL, зависящий от драйвера. Список допустимых типов данных ODBC SQL см. в разделе [типы данных SQL](../../../odbc/reference/appendixes/sql-data-types.md). Дополнительные сведения о типах данных SQL, относящихся к драйверам, см. в документации по драйверу.|  
|TYPE_NAME (ODBC 1,0)|4|Varchar, не РАВНый NULL|Имя типа данных, зависящее от источника данных; Например, «CHAR», «VARCHAR», «MONEY», «LONG VARBINARY» или «CHAR () для данных BIT».|  
|COLUMN_SIZE (ODBC 1,0)|5|Целое число|Размер столбца в источнике данных. Дополнительные сведения о размере столбцов см. в разделе [размер столбца, десятичные цифры, длина октета и размер отображаемого](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)данных.|  
|BUFFER_LENGTH (ODBC 1,0)|6|Целое число|Длина данных в байтах, передаваемых в операции **SQLGetData** или **SQLFetch** при указании SQL_C_DEFAULT. Для числовых данных этот размер может отличаться от размера данных, хранящихся в источнике данных. Это значение совпадает со столбцом COLUMN_SIZE для символьных или двоичных данных. Дополнительные сведения см. в разделе [размер столбца, десятичные цифры, длина октета и размер отображаемого](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)данных.|  
|DECIMAL_DIGITS (ODBC 1,0)|7|Smallint|Десятичные разряды столбца в источнике данных. Значение NULL возвращается для типов данных, в которых десятичные цифры неприменимы. Дополнительные сведения о десятичных цифрах см. в разделе [размер столбца, десятичные цифры, длина октета и размер отображаемого](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md)данных.|  
|PSEUDO_COLUMN (ODBC 2,0)|8|Smallint|Указывает, является ли столбец псевдо-столбцом, например Oracle ROWID:<br /><br /> SQL_PC_UNKNOWN SQL_PC_NOT_PSEUDO SQL_PC_PSEUDO **Примечание.** для обеспечения максимальной совместимости псевдо-столбцы не следует заключать в кавычки символом, возвращаемым функцией **SQLGetInfo**.|  
  
 После того как приложение извлекает значения для SQL_BEST_ROWID, приложение может использовать эти значения, чтобы снова выбрать эту строку в пределах определенной области. Инструкция **SELECT** гарантированно возвращает либо строки, либо одну строку.  
  
 Если приложение перевыбирает строку на основе столбца или столбцов ROWID и строка не найдена, приложение может предположить, что строка была удалена, или столбцы ROWID были изменены. Противоположное значение не равно true: даже если ROWID не изменился, другие столбцы в строке могли измениться.  
  
 Столбцы, возвращаемые для типа столбца SQL_BEST_ROWID, полезны для приложений, которые должны прокручиваться вперед и назад в результирующем наборе для получения последних данных из набора строк. Столбец или столбцы ROWID гарантированно не меняются при размещении в этой строке.  
  
 Столбец или столбцы ROWID могут оставаться действительными даже в том случае, если курсор не находится в строке. приложение может определить это, проверив столбец SCOPE в результирующем наборе.  
  
 Столбцы, возвращаемые для типа столбца SQL_ROWVER, полезны для приложений, которым требуется возможность проверять, обновлялись ли какие-либо столбцы в данной строке во время повторного выбора строки с помощью ROWID. Например, после повторного выбора строки с помощью ROWID приложение может сравнить предыдущие значения в SQL_ROWVER столбцах с только что выбранными. Если значение в столбце SQL_ROWVER отличается от предыдущего значения, приложение может предупредить пользователя о том, что данные на экране изменились.  
  
## <a name="code-example"></a>Пример кода  
 Пример кода подобной функции см. в разделе [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат столбцов в таблице или таблицах|[Функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)|  
|Выборка одной строки или блока данных в прямом направлении|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение столбцов первичного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
