---
title: SQLSetPos, функция | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetPos
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLSetPos
helpviewer_keywords:
- SQLSetPos function [ODBC]
ms.assetid: 80190ee7-ae3b-45e5-92a9-693eb558f322
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 80f14b99d2c7dac91116186fdcf53ff77ee6c2c0
ms.sourcegitcommit: c1382268152585aa77688162d2286798fd8a06bb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/19/2019
ms.locfileid: "68343074"
---
# <a name="sqlsetpos-function"></a>Функция SQLSetPos
**Соответствия**  
 Представленная версия: Соответствие стандартам ODBC 1,0: интерфейс ODBC  
  
 **Сводка**  
 Функция **SQLSetPos** задает позицию курсора в наборе строк и позволяет приложению обновлять данные в наборе строк, а также обновлять или удалять данные в результирующем наборе.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLSetPos(  
      SQLHSTMT        StatementHandle,  
      SQLSETPOSIROW   RowNumber,  
      SQLUSMALLINT    Operation,  
      SQLUSMALLINT    LockType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *RowNumber*  
 Входной Расположение строки в наборе строк, в которой выполняется операция, указанная с помощью аргумента *операции* . Если параметр *RowNumber* имеет значение 0, операция применяется к каждой строке в наборе строк.  
  
 Дополнительные сведения см. в разделе "Комментарии".  
  
 *Операция*  
 Входной Выполняемая операция:  
  
 SQL_POSITION SQL_REFRESH SQL_UPDATE SQL_DELETE  
  
> [!NOTE]
>  Значение SQL_ADD для аргумента *операции* устарело для ODBC *3. x*. Драйверам ODBC *3. x* потребуется поддержка SQL_ADD для обеспечения обратной совместимости. Эта функция была заменена вызовом **SQLBulkOperations** с операцией SQL_ADD  . Если приложение ODBC *3. x* работает с драйвером ODBC *2. x* , диспетчер драйверов сопоставляет вызов **SQLBulkOperations** с *операцией* SQL_ADD для **SQLSetPos** с *операцией* SQL_ADD.  
  
 Дополнительные сведения см. в разделе "Комментарии".  
  
 *LockType*  
 Входной Указывает, как заблокировать строку после выполнения операции, указанной в аргументе *операции* .  
  
 SQL_LOCK_NO_CHANGE SQL_LOCK_EXCLUSIVE SQL_LOCK_UNLOCK  
  
 Дополнительные сведения см. в разделе "Комментарии".  
  
 **Возврата**  
  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда функция **SQLSetPos** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGETDIAGREC** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLSetPos** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, — это SQL_ERROR, если не указано иное.  
  
 Для всех этих SQLSTATE, которые могут возвращать SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением 01XXX SQLSTATE), возвращается значение SQL_SUCCESS_WITH_INFO, если ошибка возникает в одной или нескольких строках операции многострочные, а SQL_ERROR возвращается при возникновении ошибки в операция с одной строкой.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01001|Конфликт операций с курсором|Аргумент *операции* был SQL_DELETE или SQL_UPDATE, и ни одна строка, ни несколько строк не были удалены или обновлены. (Дополнительные сведения об обновлениях более чем в одной строке см. в описании *атрибута* SQL_ATTR_SIMULATE_CURSOR в **SQLSetStmtAttr**.) (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Аргумент *операции* был SQL_DELETE или SQL_UPDATE, и операция завершилась сбоем из-за оптимистичного параллелизма. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Усечение строковых данных справа|Аргумент *операции* был SQL_REFRESH, а строковые или двоичные данные, возвращенные для столбца или столбцов с типом данных SQL_C_CHAR или SQL_C_BINARY, привели к усечению непустого символа или двоичных данных, отличных от NULL.|  
|01S01|Ошибка в строке|Аргумент *RowNumber* имел значение 0, а ошибка произошла в одной или нескольких строках при выполнении операции, указанной в аргументе *операции* .<br /><br /> (SQL_SUCCESS_WITH_INFO возвращается при возникновении ошибки в одной или нескольких строках операции многострочные, а SQL_ERROR возвращается в случае ошибки операции с одной строкой.)<br /><br /> (Значение SQLSTATE возвращается, только если метод **SQLSetPos** вызывается после **SQLExtendedFetch**, если драйвер является драйвером ODBC *2. x* , а библиотека курсоров не используется.)|  
|01S07|Усечение дробной части|Аргумент *операции* был SQL_REFRESH, тип данных буфера приложения не SQL_C_CHAR или SQL_C_BINARY, а данные, возвращенные в буферы приложений для одного или нескольких столбцов, были усечены. Для числовых типов данных дробная часть числа была усечена. Для типов данных времени, временных меток и интервалов, содержащих компонент времени, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных столбца в результирующем наборе не может быть преобразовано в тип данных, указанный *TargetType* в вызове **SQLBindCol**.|  
|07009|Недопустимый индекс дескриптора|*Операция* аргумента была SQL_REFRESH или SQL_UPDATE, а столбец был привязан с номером столбца, превышающим число столбцов в результирующем наборе.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|*Операция* аргумента была SQL_UPDATE, и ни один столбец не был обновлен, так как все столбцы были либо несвязанными, либо доступны только для чтения, либо значение в буфере ограничивающей длины SQL_COLUMN_IGNORE.|  
|22001|Строковые данные, усечение справа|Аргумент *операции* был SQL_UPDATE, а присваивание символьного или двоичного значения столбцу привело к усечению непустых (для символов) или не NULL (для двоичных) символов или байтов.|  
|22003|Числовое значение вне допустимого диапазона|*Операция* аргумента была SQL_UPDATE, а присваивание числового значения столбцу в результирующем наборе привело к усечению всего (в отличие от дробного) части числа.<br /><br /> *Операция* аргумента была SQL_REFRESH, и возврат числового значения для одного или нескольких связанных столбцов привело бы к утрате значащих цифр.|  
|22007|Недопустимый формат даты и времени|*Операция* аргумента была SQL_UPDATE, и присвоение значения даты или метки времени столбцу в результирующем наборе привело к тому, что поле год, месяц или день выходит за пределы диапазона.<br /><br /> *Операция* аргумента была SQL_REFRESH, и возврат значения даты или метки времени для одного или нескольких связанных столбцов привело к тому, что поле год, месяц или день выходит за пределы диапазона.|  
|22008|Переполнение поля даты и времени|Аргумент *операции* был SQL_UPDATE, и производительность арифметики значений DateTime для данных, отправляемых в столбец результирующего набора, привела к полю DateTime (год, месяц, день, час, минута или второе поле) результата за пределами допустимого значения диапазон значений для поля или является недопустимым в зависимости от естественных правил григорианского календаря для значений даты и времени.<br /><br /> Аргумент *операции* был SQL_REFRESH, а производительность арифметических операций с типом DateTime для данных, извлекаемых из результирующего набора, привела к полю DateTime (год, месяц, день, час, минута или второе поле) результата вне допустимого значения диапазон значений для поля или является недопустимым в зависимости от естественных правил григорианского календаря для значений даты и времени.|  
|22015|Переполнение поля интервала|Аргумент *операции* был SQL_UPDATE, а назначение точного числового или временного типа C к типу данных SQL Interval привело к утрате значащих цифр.<br /><br /> Аргумент *операции* был SQL_UPDATE; При назначении типа SQL Interval не было представления значения типа C в поле Interval SQL Type.<br /><br /> Аргумент *операции* был SQL_REFRESH, и присваивание от точного числового или временного типа SQL к типу Interval C привело к утере значащих цифр в начальном поле.<br /><br /> Аргумент *операции* был SQL_ обновлением; При назначении в тип C Interval не было представления значения типа SQL в типе Interval C.|  
|22018|Недопустимое символьное значение для спецификации приведения|Аргумент *операции* был SQL_REFRESH; Тип C был точным или приблизительным числовым, типом данных DateTime или интервалом. тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.<br /><br /> *Операция* аргумента была SQL_UPDATE; тип SQL был точным или приблизительным числовым, типом данных DateTime или значением интервала. Тип C — SQL_C_CHAR; и значение в столбце не было допустимым литералом привязанного типа SQL.|  
|23000|Нарушение ограничения целостности|*Операция* аргумента была SQL_DELETE или SQL_UPDATE, и нарушено ограничение целостности.|  
|24000|Недопустимое состояние курсора|*Статеменсандле* был в выполненном состоянии, но с *статеменсандле*не связан ни один результирующий набор.<br /><br /> (DM) курсор был открыт в *статеменсандле*, но не был вызван **SQLFetch** или **SQLFetchScroll** .<br /><br /> Курсор был открыт в *статеменсандле*, а **SQLFetch** или **SQLFetchScroll** был вызван, но курсор был помещен перед началом результирующего набора или после конца результирующего набора.<br /><br /> *Операция* аргумента была SQL_DELETE, SQL_REFRESH или SQL_UPDATE, и курсор был помещен перед началом результирующего набора или после конца результирующего набора.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|42000|Синтаксическая ошибка или нарушение прав доступа|Драйверу не удалось заблокировать строку по мере необходимости для выполнения операции, запрошенной в *операции*с аргументом.<br /><br /> Драйверу не удалось заблокировать строку согласно запросу в аргументе *LockType*.|  
|44000|Нарушение параметра WITH CHECK OPTION|Аргумент *операции* был SQL_UPDATE, а обновление было выполнено в просматриваемой таблице или таблице, производной от просматриваемой таблицы, которая была создана с помощью **параметра WITH CHECK**, так что одна или несколько строк, затронутых обновлением, больше не будут содержится в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией  *\** **SQLGetDiagRec** в буфере MessageText, описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *Статеменсандле*, а затем в *статеменсандле*был вызвана функция.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции SQLSetPos.<br /><br /> (DM) указанный *статеменсандле* не находится в выполненном состоянии. Функция была вызвана без предварительного вызова **SQLExecDirect**, **SQLExecute**или функции каталога.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращенного SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) драйвер был драйвером ODBC *2. x* , а метод **SQLSetPos** был вызван для *статеменсандле* после вызова **SQLFetch** .|  
|HY011|Задать атрибут сейчас невозможно|(DM) драйвер был драйвером ODBC *2. x* ; был задан атрибут инструкции SQL_ATTR_ROW_STATUS_PTR. затем был вызван метод **SQLSetPos** до вызова **SQLFetch**, **SQLFetchScroll**или **SQLExtendedFetch** .|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Аргумент *операции* был SQL_UPDATE, значение данных было пустым указателем, а значение длины столбца не равно 0, SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NULL_DATA или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Аргумент *операции* был SQL_UPDATE; значение данных не является пустым указателем; тип данных C — SQL_C_BINARY или SQL_C_CHAR; значение длины столбца было меньше 0, но не равно SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NTS или SQL_NULL_DATA или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение в буфере длины или индикатора было SQL_DATA_AT_EXEC; тип SQL был либо SQL_LONGVARCHAR, SQL_LONGVARBINARY, либо типом данных типа Long, относящимся к источнику данных. а тип сведений SQL_NEED_LONG_DATA_LEN в **SQLGetInfo** — «Y».|  
|HY092|Недопустимый идентификатор атрибута|(DM) значение, указанное для аргумента *операции* , недопустимо.<br /><br /> (DM) значение, указанное для аргумента *LockType* , недопустимо.<br /><br /> Аргументом *операции* был SQL_UPDATE или SQL_DELETE, а атрибутом инструкции SQL_ATTR_CONCURRENCY — SQL_ATTR_CONCUR_READ_ONLY.|  
|HY107|Значение строки вне допустимого диапазона|Значение, указанное для аргумента *RowNumber* , больше числа строк в наборе строк.|  
|HY109|Недопустимое расположение курсора|Курсор, связанный с *статеменсандле* , был определен как однонаправленный, поэтому курсор не может быть помещен в набор строк. См. Описание атрибута SQL_ATTR_CURSOR_TYPE в **SQLSetStmtAttr**.<br /><br /> Аргумент *операции* был SQL_UPDATE, SQL_DELETE или SQL_REFRESH, а строка, определенная аргументом *RowNumber* , была удалена или не была выбрана.<br /><br /> (DM) аргумент *RowNumber* имел значение 0, а аргумент *операции* — SQL_POSITION.<br /><br /> Функция **SQLSetPos** была вызвана после вызова **SQLBulkOperations** и до вызова **SQLFetchScroll** или **SQLFetch** .|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает операцию, запрошенную в аргументе *операции* или в аргументе *LockType* .|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr** с *атрибутом* SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в Handle возвращает SQL_STILL_EXECUTING и включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
  
> [!CAUTION]
>  Сведения о том, что функция **SQLSetPos** может быть вызвана в и что нужно сделать для совместимости с приложениями ODBC *2. x* , см. в разделе [блочные курсоры, прокручиваемые курсоры и обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md).  
  
## <a name="rownumber-argument"></a>Аргумент RowNumber  
 Аргумент *RowNumber* задает номер строки в наборе строк, в которой выполняется операция, указанная аргументом *операции* . Если параметр *RowNumber* имеет значение 0, операция применяется к каждой строке в наборе строк. Аргумент *RowNumber* должен иметь значение от 0 до количества строк в наборе строк.  
  
> [!NOTE]  
>  В языке C массивы основаны на 0, а аргумент *RowNumber* — на 1. Например, чтобы обновить пятую строку набора строк, приложение изменяет буферы набора строк с индексом 4 массива, но указывает *RowNumber* , равную 5.  
  
 Все операции наведите курсор на строку, указанную функцией *RowNumber*. Для следующих операций требуется указать позицию курсора:  
  
-   Позиционированные инструкции UPDATE и DELETE.  
  
-   Вызывает **SQLGetData**.  
  
-   Вызовы функции **SQLSetPos** с параметрами SQL_DELETE, SQL_REFRESH и SQL_UPDATE.  
  
 Например, если функция *RowNumber* имеет значение 2 для вызова функции **SQLSetPos** с *операцией* SQL_DELETE, курсор размещается во второй строке набора строк, а эта строка удаляется. Запись в массиве состояния строки реализации (на которую указывает атрибут инструкции SQL_ATTR_ROW_STATUS_PTR) для второй строки изменяется на SQL_ROW_DELETED.  
  
 Приложение может указать позицию курсора при вызове функции **SQLSetPos**. Как правило, он вызывает функцию **SQLSetPos** с операцией SQL_POSITION или SQL_REFRESH для позиционирования курсора перед выполнением инструкции позиционированного обновления или удаления или вызовом **SQLGetData**.  
  
## <a name="operation-argument"></a>Аргумент операции  
 Аргумент *операции* поддерживает следующие операции. Чтобы определить, какие параметры поддерживаются источником данных, приложение вызывает **SQLGetInfo** с SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 тип сведений (в зависимости от типа курсора).  
  
|*Операция*<br /><br /> аргумент|Операция|  
|------------------------------|---------------|  
|SQL_POSITION|Драйвер устанавливает курсор на строку, указанную функцией *RowNumber*.<br /><br /> Содержимое массива состояния строки, на которое указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR, не учитывается для *операции*SQL_POSITION.|  
|SQL_REFRESH|Драйвер устанавливает курсор на строку, указанную функцией *RowNumber* , и обновляет данные в буферах набора строк для этой строки. Дополнительные сведения о том, как драйвер возвращает данные в буферах наборов строк, см. в описании привязок на уровне строк и столбцов в **SQLBindCol**.<br /><br /> Функция **SQLSetPos** с *операцией* SQL_REFRESH обновляет состояние и содержимое строк в текущем выбранном наборе строк. Сюда входит обновление закладок. Поскольку данные в буферах обновляются, но не перегружается, членство в наборе строк фиксируется. Это отличается от обновления, выполненного вызовом **SQLFetchScroll** с *фетчориентатион* SQL_FETCH_RELATIVE, и *RowNumber* , равным 0, который повторно извлекает набор строк из результирующего набора, чтобы он мог отображать добавленные данные и удалять удаленные данные, если эти операции поддерживаются драйвером и курсором.<br /><br /> Успешное обновление с помощью функции **SQLSetPos** не изменит состояние строки SQL_ROW_DELETED. Удаленные строки в наборе строк будут по прежнему помечаться как удаленные до следующей выборки. Строки исчезают при следующей выборки, если курсор поддерживает упаковку (в результате чего последующие **SQLFetch** или **SQLFetchScroll** не возвращают удаленные строки).<br /><br /> Добавленные строки не отображаются при выполнении инструкции Refresh с параметром **SQLSetPos** . Это поведение отличается от **SQLFetchScroll** с *fetchtype* SQL_FETCH_RELATIVE и *RowNumber* , равным 0, что также обновляет текущий набор строк, но отображает добавленные записи или Pack удаленные записи, если эти операции поддерживается курсором.<br /><br /> Успешное обновление с помощью функции **SQLSetPos** изменит состояние строки SQL_ROW_ADDED на SQL_ROW_SUCCESS (если существует массив состояния строки).<br /><br /> Успешное обновление с помощью функции **SQLSetPos** изменит состояние строки SQL_ROW_UPDATED на новое состояние строки (если массив состояния строки существует).<br /><br /> Если в операции **SQLSetPos** в строке возникает ошибка, то строке присваивается состояние SQL_ROW_ERROR (если существует массив состояния строки).<br /><br /> Для курсора, открытого с помощью атрибута SQL_ATTR_CONCURRENCY инструкции SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES, обновление с помощью **SQLSetPos** может обновить значения оптимистичного параллелизма, используемые источником данных, чтобы обнаружить, что строка изменилась. В этом случае версии строк или значения, используемые для обеспечения параллелизма курсоров, обновляются всякий раз, когда буферы набора строк обновляются с сервера. Это происходит для каждой обновляемой строки.<br /><br /> Содержимое массива состояния строки, на которое указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR, не учитывается для *операции*SQL_REFRESH.|  
|SQL_UPDATE|Драйвер устанавливает курсор на строку, указанную функцией *RowNumber* , и обновляет базовую строку данных значениями в буферах набора строк (аргумент *таржетвалуептр* в **SQLBindCol**). Он получает длины данных из буферов длины и индикатора (аргумент *StrLen_or_IndPtr* в **SQLBindCol**). Если длина любого столбца равна SQL_COLUMN_IGNORE, столбец не обновляется. После обновления строки драйвер изменяет соответствующий элемент массива состояния строки на SQL_ROW_UPDATED или SQL_ROW_SUCCESS_WITH_INFO (если существует массив состояния строки).<br /><br /> Определяется драйвером поведение, если функция **SQLSetPos** с аргументом *операции* SQL_UPDATE вызывается для курсора, который содержит дублирующиеся столбцы. Драйвер может возвращать определенное драйвером значение SQLSTATE, может обновить первый столбец, отображаемый в результирующем наборе, или выполнить другое поведение, определяемое драйвером.<br /><br /> Массив операций строк, на который указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR, может использоваться для указания того, что строка в текущем наборе строк должна игнорироваться во время выполнения пакета обновления. Дополнительные сведения см. в подразделе "состояние и массивы операций" Далее в справочнике по функциям.|  
|SQL_DELETE|Драйвер устанавливает курсор на строку, указанную функцией *RowNumber* , и удаляет базовую строку данных. Он изменяет соответствующий элемент массива состояния строки на SQL_ROW_DELETED. После удаления строки следующие данные недопустимы для строк: позиционированные обновления и инструкции DELETE, вызовы **SQLGetData**и вызовы функции **SQLSetPos** *с* заданным значением, кроме SQL_POSITION. Для драйверов, поддерживающих упаковку, строка удаляется из курсора при получении новых данных из источника данных.<br /><br /> Должна ли строка оставаться видимой, зависит от типа курсора. Например, удаленные строки видимы для статических и управляемых набором ключей курсоров, но невидимы для динамических курсоров.<br /><br /> Массив операций строк, на который указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR, может использоваться для указания того, что строка в текущем наборе строк должна игнорироваться во время выполнения операции полного удаления. Дополнительные сведения см. в подразделе "состояние и массивы операций" Далее в справочнике по функциям.|  
  
## <a name="locktype-argument"></a>LockType, аргумент  
 Аргумент *LockType* предоставляет приложениям возможность управлять параллелизмом. В большинстве случаев источники данных, поддерживающие уровни параллелизма и транзакции, поддерживают только значение SQL_LOCK_NO_CHANGE аргумента *LockType* . Аргумент *LockType* обычно используется только для поддержки файлов.  
  
 Аргумент *LockType* задает состояние блокировки строки после выполнения инструкции **SQLSetPos** . Если драйверу не удается заблокировать строку для выполнения запрошенной операции или для удовлетворения аргумента *LockType* , он возвращает SQL_ERROR и SQLSTATE 42000 (синтаксическая ошибка или нарушение прав доступа).  
  
 Хотя аргумент *LockType* указан для одной инструкции, эта блокировка применяет те же права для всех инструкций в соединении. В частности, блокировка, полученная одной инструкцией в соединении, может быть разблокирована другой инструкцией в том же соединении.  
  
 Строка, заблокированная с помощью функции **SQLSetPos** , остается заблокированной до тех пор, пока приложение не вызовет функцию **SQLSetPos** для строки с *LockType* , для которой задано значение SQL_LOCK_UNLOCK, или пока приложение не вызовет **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметром SQL_CLOSE. Для драйвера, который поддерживает транзакции, строка, заблокированная с помощью функции **SQLSetPos** , разблокируется, когда приложение вызывает **SQLEndTran** для фиксации или отката транзакции в соединении (если курсор закрывается при фиксации или откате транзакции). как указано в типах сведений SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR, возвращаемых **SQLGetInfo**).  
  
 Аргумент *LockType* поддерживает следующие типы блокировок. Чтобы определить, какие блокировки поддерживаются источником данных, приложение вызывает **SQLGetInfo** с SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 тип сведений (в зависимости от типа курсора).  
  
|*LockType* , аргумент|Тип блокировки|  
|-------------------------|---------------|  
|SQL_LOCK_NO_CHANGE|Драйвер или источник данных гарантирует, что строка находится в том же заблокированном или разблокированном состоянии, что и до того, как была вызвана функция **SQLSetPos** . Это значение *LockType* позволяет источникам данных, которые не поддерживают явную блокировку на уровне строк, использовать блокировку, необходимую для текущих уровней параллелизма и изоляции транзакций.|  
|SQL_LOCK_EXCLUSIVE|Драйвер или источник данных блокирует строку в монопольном режиме. Инструкция в другом соединении или в другом приложении не может быть использована для получения каких-либо блокировок в строке.|  
|SQL_LOCK_UNLOCK|Драйвер или источник данных разблокирует строку.|  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированная строка остается заблокированной до тех пор, пока не будет вызван один из вызовов функций, описанных в предыдущем абзаце.  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированная строка останется заблокированной до тех пор, пока приложение не вызовет **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметром SQL_CLOSE. Если драйвер поддерживает транзакции и закрывает курсор после фиксации или отката транзакции, приложение вызывает **SQLEndTran**.  
  
 Для операций обновления и удаления в **SQLSetPos**приложение использует аргумент *LockType* следующим образом:  
  
-   Чтобы гарантировать, что строка не изменится после ее извлечения, приложение вызывает функцию **SQLSetPos** *с ЗАданным* для SQL_REFRESH, а для *LockType* задано значение SQL_LOCK_EXCLUSIVE.  
  
-   Если приложение устанавливает для *LockType* значение SQL_LOCK_NO_CHANGE, драйвер гарантирует, что операция обновления или удаления будет выполнена только в том случае, если приложение заданное SQL_CONCUR_LOCK для атрибута инструкции SQL_ATTR_CONCURRENCY.  
  
-   Если в приложении указано SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES для атрибута SQL_ATTR_CONCURRENCY Statement, драйвер сравнивает версии строк или значения и отклоняет операцию, если строка была изменена после того, как приложение выбирало строку.  
  
-   Если в приложении указано SQL_CONCUR_READ_ONLY для атрибута SQL_ATTR_CONCURRENCY Statement, драйвер отклоняет любые операции обновления или удаления.  
  
 Дополнительные сведения об атрибуте инструкции SQL_ATTR_CONCURRENCY см. в разделе [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md).  
  
## <a name="status-and-operation-arrays"></a>Массивы состояния и операций  
 При вызове функции **SQLSetPos**используются следующие массивы состояния и операции:  
  
-   Массив состояния строки (на который указывает поле SQL_DESC_ARRAY_STATUS_PTR в атрибуте IRD и SQL_ATTR_ROW_STATUS_ARRAY) содержит значения состояния для каждой строки данных в наборе строк. Драйвер задает значения состояния в этом массиве после вызова **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**или **SQLSetPos**. На этот массив указывает атрибут инструкции SQL_ATTR_ROW_STATUS_PTR.  
  
-   Массив операций с строками (на который указывает поле SQL_DESC_ARRAY_STATUS_PTR в атрибуте АРД и SQL_ATTR_ROW_OPERATION_ARRAY) содержит значение для каждой строки в наборе строк, которое показывает, является ли вызов функции **SQLSetPos** для групповой операции игнорируется или выполняется. Каждому элементу массива присваивается значение SQL_ROW_PROCEED (значение по умолчанию) или SQL_ROW_IGNORE. На этот массив указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR.  
  
 Количество элементов в массивах состояния и операций должно равняться числу строк в наборе строк (как определено атрибутом инструкции SQL_ATTR_ROW_ARRAY_SIZE).  
  
 Дополнительные сведения о массиве состояния строк см. в разделе [SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md). Дополнительные сведения о массиве операций с строками см. в разделе «игнорирование строки в групповой операции» далее в этом подразделе.  
  
## <a name="using-sqlsetpos"></a>Использование функции SQLSetPos  
 Перед вызовом функции **SQLSetPos**приложение должно выполнить следующую последовательность действий:  
  
1.  Если приложение будет вызывать функцию **SQLSetPos** с  параметром SQL_UPDATE, вызовите **SQLBindCol** (или **SQLSetDescRec**) для каждого столбца, чтобы указать его тип данных и буфер привязки для данных и длины столбца.  
  
2.  Если приложение вызывает функцию **SQLSetPos** с параметром *Operation* , ИМЕЮЩИМ значение SQL_DELETE или SQL_UPDATE, вызовите **SQLColAttribute** , чтобы убедиться, что удаляемые или обновляемые столбцы являются обновляемыми.  
  
3.  Вызовите **SQLExecDirect**, **SQLExecute**или функцию каталога, чтобы создать результирующий набор.  
  
4.  Вызовите **SQLFetch** или **SQLFetchScroll** для получения данных.  
  
 Дополнительные сведения об использовании функции **SQLSetPos**см. в разделе [Обновление данных с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-data-with-sqlsetpos.md).  
  
## <a name="deleting-data-using-sqlsetpos"></a>Удаление данных с помощью SQLSetPos  
 Чтобы удалить данные с помощью функции **SQLSetPos**, приложение вызывает функцию **SQLSetPos** с параметром *RowNumber* , равным номеру удаляемой строки, и параметру *Operation* задано значение SQL_DELETE.  
  
 После удаления данных драйвер изменяет значение в массиве состояния строки реализации соответствующей строки на SQL_ROW_DELETED (или SQL_ROW_ERROR).  
  
## <a name="updating-data-using-sqlsetpos"></a>Обновление данных с помощью SQLSetPos  
 Приложение может передать значение для столбца либо в привязанном буфере данных, либо с помощью одного или нескольких вызовов **SQLPutData**. Столбцы, данные которых передаются с помощью **SQLPutData** , называются столбцами *данных в процессе выполнения* . Они обычно используются для отправки данных для столбцов SQL_LONGVARBINARY и SQL_LONGVARCHAR и могут быть смешаны с другими столбцами.  
  
#### <a name="to-update-data-with-sqlsetpos-an-application"></a>Для обновления данных с помощью функции SQLSetPos приложение:  
  
1.  Помещает значения в буферы данных и длины/индикаторов, привязанные к **SQLBindCol**:  
  
    -   Для обычных столбцов приложение помещает новое значение столбца в  *\*буфер таржетвалуептр* и длину  *\** этого значения в буфер StrLen_or_IndPtr. Если строка не должна обновляться, приложение помещает SQL_ROW_IGNORE в элемент строки массива операций строки.  
  
    -   Для столбцов данных, выполняемых при выполнении, приложение помещает в  *\*буфер таржетвалуептр* определенное приложением значение, например номер столбца. Значение можно использовать позже для задания столбца.  
  
         Приложение помещает результат макроса SQL_LEN_DATA_AT_EXEC (*length*) в буфер **StrLen_or_IndPtr* . Если тип данных SQL столбца — SQL_LONGVARBINARY, SQL_LONGVARCHAR или long Data Source Type, а драйвер возвращает значение "Y" для типа сведений SQL_NEED_LONG_DATA_LEN в **SQLGetInfo**, то *Длина* — это число байтов данных должен быть отправлен для параметра; в противном случае оно должно быть неотрицательным значением и игнорируется.  
  
2.  Вызывает функцию **SQLSetPos** с аргументом *операции* , для которого задано значение SQL_UPDATE, чтобы обновить строку данных.  
  
    -   Если столбцы данных не выполняются, процесс завершается.  
  
    -   Если имеются какие-либо столбцы данных на этапе выполнения, функция возвращает SQL_NEED_DATA и переходит к шагу 3.  
  
3.  Вызывает **метод SQLParamData** , чтобы получить адрес  *\*буфера таржетвалуептр* для первого обрабатываемого столбца данных. **Метод SQLParamData** возвращает SQL_NEED_DATA. Приложение получает значение, определяемое приложением, из  *\*буфера таржетвалуептр* .  
  
    > [!NOTE]  
    >  Хотя параметры данных во время выполнения похожи на столбцы данных на этапе выполнения, значение, возвращаемое функцией **метод SQLParamData** , отличается для каждого из них.  
  
    > [!NOTE]  
    >  Параметры данных при выполнении — это параметры в инструкции SQL, для которых данные будут отправляться с помощью **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter** или путем установки дескрипторов с помощью **SQLSetDescRec**. Значение, возвращаемое функцией **метод SQLParamData** , является 32-битным значением, передаваемым в **SQLBindParameter** в аргументе *параметервалуептр* .  
  
    > [!NOTE]  
    >  Столбцы с данными при выполнении — это столбцы в наборе строк, для которых данные будут отправляться с помощью **SQLPutData** при обновлении строки с помощью функции **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращаемое функцией **метод SQLParamData** , является адресом строки в буфере **таржетвалуептр* , который обрабатывается.  
  
4.  Вызывает **SQLPutData** один или несколько раз для отправки данных для столбца. Требуется более одного вызова, если все значения данных не могут быть возвращены в  *\*буфер таржетвалуептр* , указанный в **SQLPutData**; несколько вызовов **SQLPutData** для одного и того же столбца разрешены только при отправке символьных данных C к столбцу с символьным, двоичным или определяемым источником данных типом данных или при отправке двоичных данных C в столбец с символьными, двоичными данными или типами данных, зависящими от источника данных.  
  
5.  Вызывает **метод SQLParamData** еще раз, чтобы сообщить о том, что для столбца были отправлены все данные.  
  
    -   Если имеются дополнительные столбцы данных на этапе выполнения, **метод SQLParamData** возвращает SQL_NEED_DATA и адрес буфера *таржетвалуептр* для следующего обрабатываемого столбца данных. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет столбцов данных в процессе выполнения, процесс завершится. Если инструкция была выполнена успешно, **метод SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; в случае сбоя выполнения возвращается SQL_ERROR. На этом этапе **метод SQLParamData** может возвращать любое SQLSTATE, которое может быть возвращено функцией **SQLSetPos**.  
  
 Если данные были обновлены, драйвер изменяет значение в массиве состояния строки реализации для соответствующей строки на SQL_ROW_UPDATED.  
  
 Если операция отменяется или возникает ошибка в **метод SQLParamData** или **SQLPutData**, после того, как функция **SQLSetPos** возвращает SQL_NEED_DATA и перед отправкой данных для всех столбцов данных в ходе выполнения, приложение может вызвать только **SQLCancel**,  **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions**, **метод SQLParamData**или **SQLPutData** для инструкции или соединения, связанного с инструкцией. Если вызывается любая другая функция для инструкции или соединение, связанное с инструкцией, функция возвращает SQL_ERROR и SQLSTATE HY010 (ошибка последовательности функций).  
  
 Если приложение вызывает **SQLCancel** , а драйверу по-прежнему требуются данные для столбцов данных в процессе выполнения, драйвер отменяет операцию. Затем приложение может снова вызвать функцию **SQLSetPos** ; Отмена не влияет на состояние курсора или текущую позицию курсора.  
  
 Если список SELECT-List спецификации запроса, связанного с курсором, содержит несколько ссылок на один и тот же столбец, возникает ошибка или драйвер игнорирует дублирующиеся ссылки и выполняет запрошенные операции, определяется драйвером.  
  
## <a name="performing-bulk-operations"></a>Выполнение операций с массовыми операциями  
 Если аргумент *RowNumber* равен 0, драйвер выполняет операцию, указанную в аргументе *операции* , для каждой строки в наборе строк, имеющей значение SQL_ROW_PROCEED в поле в массиве операций строки, на которое указывает SQL_ATTR_ROW_OPERATION_PTR. атрибут инструкции. Это допустимое значение аргумента *RowNumber* для аргумента *операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE, но не SQL_POSITION. Функция **SQLSetPos** с *операцией* SQL_POSITION и функция *RowNumber* , равная 0, возвращают значение SQLSTATE HY109 (Недопустимая координата курсора).  
  
 Если возникает ошибка, относящаяся ко всему набору строк, например SQLSTATE HYT00 (время ожидания истекло), драйвер возвращает SQL_ERROR и соответствующее значение SQLSTATE. Содержимое буферов наборов строк не определено, а позиции курсора не меняются.  
  
 Если возникает ошибка, относящаяся к одной строке, драйвер:  
  
-   Задает элемент для строки в массиве состояния строки, на который указывает атрибут SQL_ATTR_ROW_STATUS_PTR инструкции SQL_ROW_ERROR.  
  
-   Отправляет один или несколько дополнительных SQLSTATE для ошибки в очереди ошибок и устанавливает поле SQL_DIAG_ROW_NUMBER в структуре диагностических данных.  
  
 После обработки ошибки или предупреждения, если драйвер завершает операцию для оставшихся строк в наборе строк, он возвращает SQL_SUCCESS_WITH_INFO. Таким же для каждой строки, возвращающей ошибку, очередь ошибок содержит ноль или более дополнительных SQLSTATE. Если драйвер останавливает операцию после обработки ошибки или предупреждения, он возвращает SQL_ERROR.  
  
 Если драйвер возвращает предупреждения, например SQLSTATE 01004 (усечение данных), то он возвращает предупреждения, относящиеся ко всему набору строк или неизвестным строкам в наборе строк, прежде чем возвращает сведения об ошибке, относящиеся к определенным строкам. Он возвращает предупреждения для конкретных строк вместе с другими сведениями об ошибках этих строк.  
  
 Если функция *RowNumber* равна 0, а *Операция* — SQL_UPDATE, SQL_REFRESH или SQL_DELETE, то количество строк, с которыми работает функция **SQLSetPos** , указывает атрибуту инструкции SQL_ATTR_ROWS_FETCHED_PTR.  
  
 Если параметр *RowNumber* равен 0, а *Операция* — SQL_DELETE, SQL_REFRESH или SQL_UPDATE, то текущая строка после операции совпадает с текущей строкой перед операцией.  
  
## <a name="ignoring-a-row-in-a-bulk-operation"></a>Пропуск строки в групповой операции  
 Массив операций строки можно использовать, чтобы указать, что строка в текущем наборе строк должна игнорироваться во время выполнения групповой операции с помощью функции **SQLSetPos**. Чтобы указать драйверу игнорировать одну или несколько строк во время выполнения групповой операции, приложение должно выполнить следующие действия:  
  
1.  Вызовите **SQLSetStmtAttr** , чтобы задать атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR, указывающий на массив склусмаллинтс. Это поле также можно задать, вызвав **SQLSetDescField** , чтобы задать поле заголовка SQL_DESC_ARRAY_STATUS_PTR в АРД, которое требует, чтобы приложение получало дескриптор дескриптора.  
  
2.  Присвойте каждому элементу массива операций строк одно из двух значений:  
  
    -   SQL_ROW_IGNORE, чтобы указать, что строка исключена для выполнения групповой операции.  
  
    -   SQL_ROW_PROCEED, чтобы указать, что строка включена в массовый операции. (Это значение по умолчанию.)  
  
3.  Вызовите функцию **SQLSetPos** для выполнения групповой операции.  
  
 К массиву операций с строками применяются следующие правила.  
  
-   SQL_ROW_IGNORE и SQL_ROW_PROCEED влияют только на групповые операции с использованием функции **SQLSetPos** с *операцией* SQL_DELETE или SQL_UPDATE. Они не влияют на вызовы функции **SQLSetPos** с помощью *операции* SQL_REFRESH или SQL_POSITION.  
  
-   По умолчанию указатель имеет значение null.  
  
-   Если указатель имеет значение null, все строки обновляются так, как если бы для всех элементов было задано значение SQL_ROW_PROCEED.  
  
-   Установка элемента в SQL_ROW_PROCEED не гарантирует, что операция будет выполняться в этой конкретной строке. Например, если определенная строка в наборе строк имеет состояние SQL_ROW_ERROR, драйвер, возможно, не сможет обновить эту строку независимо от того, указал ли приложение SQL_ROW_PROCEED. Приложение всегда должно проверить массив состояния строк, чтобы узнать, была ли операция успешной.  
  
-   SQL_ROW_PROCEED определяется как 0 в файле заголовка. Приложение может инициализировать массив операций строк в 0 для обработки всех строк.  
  
-   Если для элемента "n" в массиве операций строки задано значение SQL_ROW_IGNORE и функция **SQLSetPos** вызывается для выполнения операции обновления или удаления, то n-е строка в наборе строк остается неизменной после вызова функции **SQLSetPos**.  
  
-   Приложение должно автоматически задать для столбца, доступного только для чтения, значение SQL_ROW_IGNORE.  
  
## <a name="ignoring-a-column-in-a-bulk-operation"></a>Пропуск столбца в групповой операции  
 Чтобы избежать ненужных диагностических данных, созданных при попытке обновления до одного или нескольких столбцов только для чтения, приложение может установить значение SQL_COLUMN_IGNORE в буфере ограничивающей длины или индикатора. Дополнительные сведения см. в разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение позволяет пользователю просматривать таблицу ORDERs и обновлять состояние заказа. Курсор, управляемый набором ключей, имеет размер набора строк, равный 20, и использует управление оптимистичным параллелизмом, сравнивая версии строк. После получения каждого набора строк приложение выводит его и позволяет пользователю выбрать и обновить состояние заказа. Приложение использует функцию **SQLSetPos** для позиционирования курсора в выбранной строке и выполняет позиционированное обновление строки. (Для ясности пропущена обработка ошибок.)  
  
```cpp  
#define ROWS 20  
#define STATUS_LEN 6  
  
SQLCHAR        szStatus[ROWS][STATUS_LEN], szReply[3];  
SQLINTEGER     cbStatus[ROWS], cbOrderID;  
SQLUSMALLINT   rgfRowStatus[ROWS];  
SQLUINTEGER    sOrderID, crow = ROWS, irow;  
SQLHSTMT       hstmtS, hstmtU;  
  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CONCURRENCY, (SQLPOINTER) SQL_CONCUR_ROWVER, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CURSOR_TYPE, (SQLPOINTER) SQL_CURSOR_KEYSET_DRIVEN, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_STATUS_PTR, (SQLPOINTER) rgfRowStatus, 0);  
SQLSetCursorName(hstmtS, "C1", SQL_NTS);  
SQLExecDirect(hstmtS, "SELECT ORDERID, STATUS FROM ORDERS ", SQL_NTS);  
  
SQLBindCol(hstmtS, 1, SQL_C_ULONG, &sOrderID, 0, &cbOrderID);  
SQLBindCol(hstmtS, 2, SQL_C_CHAR, szStatus, STATUS_LEN, &cbStatus);  
  
while ((retcode == SQLFetchScroll(hstmtS, SQL_FETCH_NEXT, 0)) != SQL_ERROR) {  
   if (retcode == SQL_NO_DATA_FOUND)  
      break;  
   for (irow = 0; irow < crow; irow++) {  
      if (rgfRowStatus[irow] != SQL_ROW_DELETED)  
         printf("%2d %5d %*s\n", irow+1, sOrderID, NAME_LEN-1, szStatus[irow]);  
   }  
   while (TRUE) {  
      printf("\nRow number to update?");  
      gets_s(szReply, 3);  
      irow = atoi(szReply);  
      if (irow > 0 && irow <= crow) {  
         printf("\nNew status?");  
         gets_s(szStatus[irow-1], (ROWS * STATUS_LEN));  
         SQLSetPos(hstmtS, irow, SQL_POSITION, SQL_LOCK_NO_CHANGE);  
         SQLPrepare(hstmtU,  
          "UPDATE ORDERS SET STATUS=? WHERE CURRENT OF C1", SQL_NTS);  
         SQLBindParameter(hstmtU, 1, SQL_PARAM_INPUT,  
            SQL_C_CHAR, SQL_CHAR,  
            STATUS_LEN, 0, szStatus[irow], 0, NULL);  
         SQLExecute(hstmtU);  
      } else if (irow == 0) {  
         break;  
      }  
   }  
}  
```  
  
 Дополнительные примеры см. в разделе [позиционированные обновления и инструкции DELETE](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md) и [Обновление строк в наборе строк с помощью функции SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение массовых операций, не связанных с блочным положением курсора|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одного поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Задание одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
|Задание атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
