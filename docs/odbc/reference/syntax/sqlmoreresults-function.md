---
title: Функция SQLMoreResults | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLMoreResults
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLMoreResults
helpviewer_keywords:
- SQLMoreResults function [ODBC]
ms.assetid: bf169ed5-4d55-412c-b184-12065a726e89
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: c26111571eb505640acee035cba37d617b43c481
ms.sourcegitcommit: 61381ef939415fe019285def9450d7583df1fed0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2018
ms.locfileid: "47849942"
---
# <a name="sqlmoreresults-function"></a>SQLMoreResults, функция
**Соответствие стандартам**  
 Версия была введена: ODBC 1.0 соответствует стандартам: ODBC  
  
 **Сводка**  
 **SQLMoreResults** определяет, доступны ли дополнительные результаты на значение типа, содержащее инструкции **ВЫБЕРИТЕ**, **обновление**, **вставить**, или  **Удалить** инструкций и, если да, инициализирует обработки для этих результатов.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLMoreResults(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
## <a name="returns"></a>Возвращает  
 ЗНАЧЕНИЕ SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, ЗНАЧЕНИЕ SQL_NO_DATA, ЗНАЧЕНИЕ SQL_ERROR, SQL_INVALID_HANDLE ИЛИ SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLMoreResults** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL _HANDLE_STMT и *обрабатывать* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLMoreResults** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменилось|При обработке значение атрибута инструкции, изменен в пакете. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Состояние транзакции неизвестно|Не удалось выполнить связанное соединение во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. **SQLMoreResults** была вызвана функция, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* . Затем **SQLMoreResults** функция была вызвана снова на *StatementHandle*.<br /><br /> **SQLMoreResults** была вызвана функция, и до его завершения выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*  из другого потока в многопоточных приложениях.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *StatementHandle*. Если по-прежнему выполнении асинхронной функции **SQLMoreResults** была вызвана функция.<br /><br /> (DM) асинхронно выполняемой функции (не такой) был вызван для *StatementHandle* и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|Опрос недоступен в режиме асинхронное уведомление|Каждый раз, когда используется модель уведомлений, отключен опроса.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущий вызов функции в дескриптор возвращает SQL_STILL_EXECUTING, и если включен режим уведомлений, **SQLCompleteAsync** должен вызываться с дескриптором постобработки и завершить операцию.|  
  
## <a name="comments"></a>Комментарии  
 **ВЫБЕРИТЕ** инструкции возвращают результирующие наборы. **ОБНОВЛЕНИЕ**, **вставить**, и **удалить** инструкции возвращают количество затронутых строк. Если любой из этих инструкций, объединяются в пакеты, отправленные с массивами параметров (по возрастанию параметр, в том порядке, в котором они отображаются в пакете под номером), или в процедурах, они могут возвращать несколько результирующих наборов или количество строк. Сведения о пакеты инструкций и массивы параметров, см. в разделе [пакеты инструкций SQL](../../../odbc/reference/develop-app/batches-of-sql-statements.md) и [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 После выполнения пакета, приложение устанавливается на первый результирующий набор. Приложение может вызвать **SQLBindCol**, **SQLBulkOperations**, **SQLFetch**, **SQLGetData**, **SQLFetchScroll** , **SQLSetPos**и все функции метаданных, на первой или любые последующие результирующие наборы, точно так же, как это происходит при наличии только одного результирующего набора. После завершения первого результирующего набора, приложение вызывает **SQLMoreResults** для перемещения к следующему результирующему набору. Если другой результирующий набор или число, **SQLMoreResults** возвращает значение SQL_SUCCESS и инициализирует результирующий набор или число для дополнительной обработки. Если все инструкции генерации число строк в диапазоне от привести генерации набор инструкций, они могут быть ступенчатый посредством вызова **SQLMoreResults**. После вызова метода **SQLMoreResults** для **обновление**, **вставить**, или **удалить** инструкций, приложение может вызвать **SQLRowCount**.  
  
 Если текущий результирующий набор со строками строк **SQLMoreResults** отменяет этого результирующего набора и делает следующий результирующий набор или количество доступных. Если все результаты будут обработаны, **SQLMoreResults** не вернет значение SQL_NO_DATA. Для некоторых драйверов выходные параметры и возвращаемые значения недоступны, пока не были обработаны все результирующие наборы и количество строк. Для таких драйверов, выходные параметры и возвращаемые значения, которые становятся доступными при **SQLMoreResults** не вернет значение SQL_NO_DATA.  
  
 Любые привязки, которые были настроены для предыдущих результирующего набора по-прежнему остаются действительными. Если столбец структуры отличаются для данного результирующего набора, затем вызов **SQLFetch** или **SQLFetchScroll** может привести к ошибки или усечения. Чтобы избежать этого, приложение должно вызвать **SQLBindCol** явным образом повторно привязать соответствующим образом (или сделать, задав поля дескриптора). Кроме того, приложение может вызвать **SQLFreeStmt** с *параметр* из SQL_UNBIND, чтобы отменить привязку всех буферах столбцов.  
  
 Значения атрибутов инструкции, такие как тип курсора, параллелизм курсоров, размер набора ключей или Максимальная длина может измениться, как приложение переходит к пакету вызовами **SQLMoreResults**. В этом случае **SQLMoreResults** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01S02 (значение параметра был изменен).  
  
 Вызов **SQLCloseCursor**, или **SQLFreeStmt** с *параметр* из SQL_CLOSE, отбрасывает все результирующие наборы и количество строк, которые были доступны в результате выполнения пакет. Возвращает дескриптор инструкции в выделенных или подготовленной состояние. Вызов **SQLCancel** отменить асинхронно выполняемой функции, когда был выполнен пакет и дескриптор инструкции в выполненном, курсор, или асинхронное состояние приводит все результаты наборов и подсчет числа строк для создания пакета, они будут удалены, если Отмена вызов был успешным. Затем инструкция возвращает подготовленный и выделенный состояние.  
  
 Если пакет инструкций или процедуры смешаны других инструкций SQL с **ВЫБЕРИТЕ**, **обновления**, **вставить**, и **удалить** инструкций, Эти другие операторы не влияют на **SQLMoreResults**.  
  
 Дополнительные сведения см. в разделе [несколько результатов](../../../odbc/reference/develop-app/multiple-results.md).  
  
 Искомая update, insert или delete, инструкция в пакет инструкций не влияет на все строки в источнике данных, **SQLMoreResults** возвращает значение SQL_SUCCESS. Это отличается от применения поисковое обновление, вставка или удаление инструкцию, которая выполняется через **SQLExecDirect**, **SQLExecute**, или **SQLParamData**, который Возвращает значение SQL_NO_DATA, если он не влияет на все строки в источнике данных. Если приложение вызывает **SQLRowCount** для извлечения количества строк после вызова **SQLMoreResults** проблема не затронет все строки **SQLRowCount** вернет значение SQL_NO_DATA.  
  
 Дополнительные сведения о допустимых виртуализации функций обработки результатов, см. в разделе [таблицы перехода состояния ODBC B: приложение](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md).  
  
 Дополнительные сведения о SQL_PARAM_DATA_AVAILABLE и потоковых выходных параметров, см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="availability-of-row-counts"></a>Доступность количество строк  
 Если пакет содержит несколько инструкций генерации количество последовательных строк, вполне возможно, что эти счетчики строк учитываются в счетчик только одну строку. Например если пакет содержит пять инструкций insert, то некоторые источники данных не может возвращать счетчики пять отдельных строк. Некоторые другие источники данных возвращать только одну строку число, представляющее сумму пять количество отдельных строк.  
  
 Если пакет содержит сочетание результирующего набора генерации и инструкций генерации число строк, количество строк может или могут отсутствовать вообще. Поведение драйвера с точки зрения доступности количество строк, перечисленных в тип SQL_BATCH_ROW_COUNT сведений, доступных посредством вызова **SQLGetInfo**. Например, предположим, что пакет содержит **ВЫБЕРИТЕ**, а затем два **вставить**s, а другой **ВЫБЕРИТЕ**. Затем возможны следующие варианты:  
  
-   Количество строк, соответствующие двум **вставить** инструкции доступны не все. Первый вызов **SQLMoreResults** расположит для результирующего набора из второго **ВЫБЕРИТЕ** инструкции.  
  
-   Количество строк, соответствующие двум **вставить** инструкции доступны по отдельности. (Вызов **SQLGetInfo** не возвращает SQL_BRC_ROLLED_UP бит для типа данных SQL_BATCH_ROW_COUNT.) Первый вызов **SQLMoreResults** будут размещены на количестве строк первого **вставить**, и второй вызов будут размещены на количестве строк из второго **вставить**. Третий вызов **SQLMoreResults** расположит для результирующего набора из второго **ВЫБЕРИТЕ** инструкции.  
  
-   Количество строк, соответствующие двум **вставляет** свертываются в один счетчик одну строку, которая доступна. (Вызов **SQLGetInfo** возвращает SQL_BRC_ROLLED_UP бит для типа данных SQL_BATCH_ROW_COUNT.) Первый вызов **SQLMoreResults** будут размещены на число строк свернутая, а второй вызов **SQLMoreResults** расположит для результирующего набора из второго **ВЫБЕРИТЕ**.  
  
 Некоторые драйверы сделать количество строк, доступных только для явных пакетов, а не для хранимых процедур.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработка инструкций|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Получение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
