---
title: Функция SQLGetCursorName | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetCursorName
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetCursorName
helpviewer_keywords:
- SQLGetCursorName function [ODBC]
ms.assetid: e6e92199-7bb6-447c-8987-049a4c6ce05d
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 4017ed07681a74da4832db2db3aeabddf22edb19
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "68020334"
---
# <a name="sqlgetcursorname-function"></a>Функция SQLGetCursorName
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLGetCursorName** возвращает имя курсора, связанного с указанной инструкцией.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLGetCursorName(  
     SQLHSTMT        StatementHandle,  
     SQLCHAR *       CursorName,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   NameLengthPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *курсорнаме*  
 Проверки Указатель на буфер, в который возвращается имя курсора.  
  
 Если *курсорнаме* имеет значение null, то *намеленгсптр* будет возвращать общее количество символов (исключая символ завершения null для символьных данных), доступный для возврата в буфер, на который указывает *курсорнаме*.  
  
 *BufferLength*  
 Входной \*Длина *курсорнаме*в символах. Если значение в * \*курсорнаме* является строкой Юникода (при вызове **склжеткурсорнамев**), аргумент *BufferLength* должен быть четным числом.  
  
 *намеленгсптр*  
 Проверки Указатель на память, в которой возвращается общее число символов (за исключением символа завершения null), доступного для возврата в \* *курсорнаме*. Если число возвращаемых символов больше или равно *BufferLength*, то имя курсора в \* *курсорнаме* усекается до *BufferLength* минус длину символа завершения null.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLGetCursorName** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLGetCursorName** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Буфер \* *курсорнаме* не достаточен для возврата всего имени курсора, поэтому имя курсора было усечено. Длина неусеченного имени курсора возвращается в **намеленгсптр*. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере * \*MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLGetCursorName** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) была вызвана асинхронно исполняемая функция для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY015|Нет доступных имен курсоров|(DM) драйвер был драйвером ODBC 2 *. x* , в инструкции отсутствует открытый курсор и не было задано имя курсора **SQLSetCursorName**.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное в аргументе *BufferLength* , было меньше 0.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Имена курсоров используются только в позиционированных инструкциях UPDATE и Delete (например, **Обновление** _Table-name_ ... **Где текущее** _имя курсора_). Дополнительные сведения см. в разделе [позиционированные обновления и инструкции DELETE](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md). Если приложение не вызывает **SQLSetCursorName** для определения имени курсора, драйвер создает имя. Это имя начинается с букв SQL_CUR.  
  
> [!NOTE]
>  В ODBC 2 *. x*, если нет открытого курсора, а имя не было задано вызовом **SQLSetCursorName**, вызов **SQLGetCursorName** возвратил SQLSTATE HY015 (имя курсора не доступно). В ODBC 3 *. x*это не так. независимо от того, когда вызывается **SQLGetCursorName** , драйвер возвращает имя курсора.  
  
 **SQLGetCursorName** возвращает имя курсора независимо от того, было ли оно создано явно или неявно. Имя курсора неявно создается, если **SQLSetCursorName** не вызывается. **SQLSetCursorName** можно вызвать для переименования курсора в инструкции, если курсор находится в выделенном или подготовленном состоянии.  
  
 Имя курсора, которое задается явно или неявно, остается установленным до тех пор, пока *статеменсандле* , с которым он связан, удаляется с помощью **SQLFreeHandle** с *параметром handletypeом* SQL_HANDLE_STMT.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Тема|См. следующие документы.|  
|---------------------------|---------|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Задание имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
