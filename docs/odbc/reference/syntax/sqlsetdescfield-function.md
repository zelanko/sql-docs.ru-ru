---
title: Функция SQLSetDescField | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetDescField
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetDescField
helpviewer_keywords:
- SQLSetDescField function [ODBC]
ms.assetid: 8c544388-fe9d-4f94-a0ac-fa0b9c9c88a5
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 44a3cfe212fcd452307a6aef0aedd1c22ca4e545
ms.sourcegitcommit: 61381ef939415fe019285def9450d7583df1fed0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2018
ms.locfileid: "47717142"
---
# <a name="sqlsetdescfield-function"></a>Функция SQLSetDescField
**Соответствие стандартам**  
 Версия была введена: ODBC 3.0 соответствует стандартам: ISO-92  
  
 **Сводка**  
 **SQLSetDescField** задает значение из одного поля записи дескриптора.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLSetDescField(  
     SQLHDESC      DescriptorHandle,  
     SQLSMALLINT   RecNumber,  
     SQLSMALLINT   FieldIdentifier,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    BufferLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 [Вход] Дескриптор.  
  
 *RecNumber*  
 [Вход] Указывает запись дескриптора, содержащий поле, которое стремится установить приложение. Записи дескриптора нумеруются от 0, записи номером 0 является записи закладки. *RecNumber* аргумент учитывается для поля заголовка.  
  
 *FieldIdentifier*  
 [Вход] Указывает поле, значение которого равно устанавливаемое значение дескриптора. Дополнительные сведения см. в разделе "*FieldIdentifier* аргумент» в разделе «Примечания».  
  
 *ValuePtr*  
 [Вход] Указатель на буфер, содержащий данные дескриптора, или значение типа integer. Тип данных зависит от значения *FieldIdentifier*. Если *ValuePtr* — целочисленное значение, его можно рассматривать в качестве 8 байт (SQLLEN), 4 байта (SQLINTEGER) или 2 байта (SQLSMALLINT), в зависимости от значения *FieldIdentifier* аргумент.  
  
 *BufferLength*  
 [Вход] Если *FieldIdentifier* представляет собой поле, определенных для ODBC и *ValuePtr* указывает на строку символов или двоичный буфер, данный аргумент должен иметь длину **ValuePtr*. Для строки символьных данных этот аргумент должен содержать число байтов в строке.  
  
 Если *FieldIdentifier* представляет собой поле, определенных для ODBC и *ValuePtr* должно быть целым числом, *BufferLength* учитывается.  
  
 Если *FieldIdentifier* является полем, определяемым драйвером, приложение указывает характер поле для диспетчера драйверов, задав *BufferLength* аргумент. *BufferLength* может иметь следующие значения:  
  
-   Если *ValuePtr* — это указатель на строку символов, затем *BufferLength* длина строки или SQL_NTS.  
  
-   Если *ValuePtr* является указателем в двоичный буфер, а затем приложение размещает результат SQL_LEN_BINARY_ATTR (*длина*) в макрос *BufferLength*. Это размещает отрицательное значение в *BufferLength*.  
  
-   Если *ValuePtr* — это указатель на значение, отличное от строку символов или двоичная строка, затем *BufferLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *BufferLength* является SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT или SQL_IS_USMALLINT, соответствующим образом.  
  
## <a name="returns"></a>Возвращает  
 Значение SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetDescField** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, а связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_HANDLE_DESC и *обрабатывать* из *DescriptorHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetDescField** и объясняется каждый из них в контексте этой функции; описания SQLSTATE, возвращаемых диспетчером драйверов предшествует обозначение «(DM)». Возвращается связанный с каждого значения SQLSTATE значение SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Специфические для драйвера информационное сообщение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает значения, указанного в  *\*ValuePtr* (если *ValuePtr* был указателем) или значение в *ValuePtr* (если *ValuePtr*  был целочисленное значение), или  *\*ValuePtr* Недопустимый рабочий трудностями реализации, драйвер заменены примерно такое же значение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07009|Недопустимый индекс дескриптора|*FieldIdentifier* аргумент был поле записи, *RecNumber* аргумент было равно 0 и *DescriptorHandle* аргумент ссылается на дескриптор IPD.<br /><br /> *RecNumber* аргумент был меньше 0 и *DescriptorHandle* аргумент называется Отменить или APD.<br /><br /> *RecNumber* аргумент поданных единиц превысил максимальное количество столбцов или параметров, поддерживаемых источником данных, и *DescriptorHandle* ссылается аргумент в APD или Отменить.<br /><br /> (DM) *FieldIdentifier* аргумент был SQL_DESC_COUNT, и  *\*ValuePtr* аргумента меньше 0.<br /><br /> *RecNumber* аргумент, равное 0 и *DescriptorHandle* аргумент называется неявно выделенные APD. (Эта ошибка не возникает дескриптор явно выделенные приложений, так как неизвестно, является ли дескриптор явно выделенные приложений APD или Отменить до выполнена время.)|  
|08S01|Отказ канала связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Усечение данных строки справа|*FieldIdentifier* аргумент был SQL_DESC_NAME и *BufferLength* аргумент имел значение больше, чем SQL_MAX_IDENTIFIER_LEN.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет конкретных SQLSTATE и SQLSTATE не зависящие от реализации, который был определен. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) *DescriptorHandle* был связан с параметром *StatementHandle* которого асинхронно выполняемой функции (не вот) был вызван и еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* с помощью которого *DescriptorHandle* был связанные и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров данных времени выполнения или столбцов.<br /><br /> (DM) был вызван асинхронно выполняемой функции для дескриптора соединения, связанный с *DescriptorHandle*. Если по-прежнему выполнении асинхронной функции **SQLSetDescField** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для одного из дескрипторов инструкций, связанных с *DescriptorHandle* и возвращается SQL_PARAM_DATA_AVAILABLE. Прежде чем данные были получены для всех параметров потоковой вызове этой функции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как базовые объекты памяти оказываются недоступны, возможно из-за нехватки памяти.|  
|HY016|Не удается изменить дескриптор строки реализации|*DescriptorHandle* аргумент был связан с IRD и *FieldIdentifier* аргумент не SQL_DESC_ARRAY_STATUS_PTR или SQL_DESC_ROWS_PROCESSED_PTR.|  
|HY021|Несовместимые сведения дескриптора|Поля SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE не образуют допустимый тип ODBC SQL или допустимый тип специфические для драйвера SQL (для поставщики IDP) или допустимый тип ODBC C (для APDs или ARDs).<br /><br /> Сведения о дескрипторе проверяется в ходе проверки согласованности не согласован. (См. в разделе «Проверка согласованности» в **SQLSetDescRec**.)|  
|HY090|Недопустимая длина строки или буфера|(DM)  *\*ValuePtr* представляет собой строку символов и *BufferLength* был меньше нуля и не не равно SQL_NTS.<br /><br /> (DM) драйвер был ODBC 2 *.x* драйвера, дескриптор был Отменить *ColumnNumber* аргумент имеет значение 0, а значение, указанное для аргумента *BufferLength* был не равно 4.|  
|HY091|Недопустимый идентификатор поля дескриптора|Значение, указанное для *FieldIdentifier* аргумент не полей, определенных для ODBC и не значение, определяемое реализацией.<br /><br /> *FieldIdentifier* недопустимое значение аргумента для *DescriptorHandle* аргумент.<br /><br /> *FieldIdentifier* аргумент был поля только для чтения, определенных для ODBC.|  
|HY092|Недопустимый атрибут/идентификатор параметра|Значение в  *\*ValuePtr* оказался недействительным для *FieldIdentifier* аргумент.<br /><br /> *FieldIdentifier* аргумент был SQL_DESC_UNNAMED, и *ValuePtr* был SQL_NAMED.|  
|HY105|Недопустимый тип параметра|(DM) Недопустимое значение для поля SQL_DESC_PARAMETER_TYPE. (Дополнительные сведения см. в разделе "*InputOutputType* аргумент» статьи **SQLBindParameter**.)|  
|HY117|Подключение будет приостановлена из-за состояние транзакции неизвестно. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе [новые возможности ODBC 3.8](../../../odbc/reference/what-s-new-in-odbc-3-8.md).|  
|HYT01|Время ожидания подключения истекло|Время ожидания подключения истекло раньше, чем ответил на запрос источника данных. Период времени ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *DescriptorHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **SQLSetDescField** задать любой дескриптор полю по одному за раз. Один вызов **SQLSetDescField** задает отдельное поле в одном дескрипторе. Эта функция может вызывается для установки любого поля в любой тип дескриптора, если поле можно задать. (См. таблицу далее в этом разделе).  
  
> [!NOTE]  
>  Если в вызове **SQLSetDescField** содержимое запись дескриптора, определяемый в случае сбоя *RecNumber* аргумент не определены.  
  
 Другие функции могут быть вызваны для задания нескольких полей дескриптора с помощью одного вызова функции. **SQLSetDescRec** функция задает различные поля, влияющих на тип данных и буфер привязанного столбца или параметра (SQL_DESC_TYPE, SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_OCTET_LENGTH, SQL_DESC_PRECISION, SQL_ DESC_SCALE, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR поля). **SQLBindCol** или **SQLBindParameter** позволяют сделать полную спецификацию для привязки столбца или параметра. Эти функции устанавливают определенной группы полей дескриптора с один вызов функции.  
  
 **SQLSetDescField** можно вызвать, чтобы изменить привязки буферов путем добавления смещения для привязки указателей (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR). Это изменяет буферы привязки без вызова **SQLBindCol** или **SQLBindParameter**, что позволяет приложению изменять SQL_DESC_DATA_PTR без изменения других полей, таких как SQL_DESC_DATA_ ТИП.  
  
 Если приложение вызывает **SQLSetDescField** для установки всех полей, кроме SQL_DESC_COUNT или отложенных полей SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR, запись становится непривязанной.  
  
 Поля заголовка дескриптора устанавливаются с помощью вызова **SQLSetDescField** с соответствующим *FieldIdentifier*. Множество полей заголовка также являются атрибуты инструкции, поэтому их можно также задать с помощью вызова **SQLSetStmtAttr**. Это позволяет приложениям задать поле дескриптора без предварительного получения дескриптора. Когда **SQLSetDescField** вызывается, чтобы задать поле заголовка, *RecNumber* аргумент учитывается.  
  
 Объект *RecNumber* 0 используется для задания поля закладки.  
  
> [!NOTE]  
>  Атрибут инструкции SQL_ATTR_USE_BOOKMARKS всегда должны устанавливаться перед вызовом **SQLSetDescField** задать поля закладки. Хотя это не обязательно, настоятельно рекомендуется.  
  
## <a name="sequence-of-setting-descriptor-fields"></a>Последовательность Установка полей дескриптора  
 При задании поля дескриптора, вызвав **SQLSetDescField**, приложения должны придерживаться определенной последовательности:  
  
1.  Во-первых, приложение должно установить поле SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE или SQL_DESC_DATETIME_INTERVAL_CODE.  
  
2.  После одного из этих полей, приложение может задать атрибут типа данных, и драйвер задает тип данных поля атрибута соответствующие значения по умолчанию для типа данных. Автоматическая установка значений по умолчанию полей типа атрибута гарантирует, что дескриптор будет готово к использованию, когда приложение указанный тип данных. Если приложение явно задает атрибут типа данных, он переопределяет атрибут по умолчанию.  
  
3.  После того как установлено одно из полей, указанных в действии 1 и были заданы атрибуты типа данных, приложение может задать SQL_DESC_DATA_PTR. Вам предложат указать проверка согласованности этого поля дескриптора. Если приложение изменяет тип данных или атрибутов, задав поле SQL_DESC_DATA_PTR, драйвер задает SQL_DESC_DATA_PTR является пустым указателем, Отмена привязки значения записи. Это заставляет приложение завершения правильной последовательности, можно использовать запись дескриптора.  
  
## <a name="initialization-of-descriptor-fields"></a>Инициализация полей дескриптора  
 При выделении дескриптор поля в дескрипторе можно инициализировать значение по умолчанию, инициализироваться без значения по умолчанию или быть не определено для типа дескриптора. В следующих таблицах указаны инициализации каждого поля для каждого типа дескриптора, «D», указывающее, что поле инициализируется по умолчанию, и «ND», указывающее, что поле инициализируется без значения по умолчанию. Если отображается число, значение по умолчанию поля — это число. Таблицы также указывать, является ли поле чтения и записи (чтение/запись) или только для чтения (R).  
  
 Поля IRD имеет значения по умолчанию только в том случае, после инструкции подготовки, или выполнения и IRD был заполнен, не в том случае, когда выделен дескриптора инструкции или дескриптора. Пока не был заполнен IRD, любая попытка получить доступ к полю IRD возвратит ошибку.  
  
 Некоторые поля дескриптора, которые определены для одного или нескольких, но не все типы дескрипторов (ARDs и IRDs и APDs и поставщики IDP). Поле не определено для типа дескриптора, не требуется каким-либо функций, использующих этот дескриптор.  
  
 Поля, которые может осуществляться **SQLGetDescField** обязательно не может задать **SQLSetDescField**. Поля, которые задаются **SQLSetDescField** , перечислены в следующих таблицах.  
  
 Инициализация поля заголовка описан в следующей таблице.  
  
|Имя поля заголовка|Тип|Чтение-запись|По умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_ALLOC_TYPE|SQLSMALLINT|ОТМЕНИТЬ: R APD: R IRD: R IPD: R|Отменить: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явной<br /><br /> APD: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явной<br /><br /> IRD: SQL_DESC_ALLOC_AUTO<br /><br /> IPD: SQL_DESC_ALLOC_AUTO|  
|SQL_DESC_ARRAY_SIZE|SQLULEN|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|Отменить: APD [1]: [1] IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_ARRAY_STATUS_PTR|SQLUSMALLINT *|ОТМЕНИТЬ: APD R/W: IRD R/W: IPD R/W: R/W|Отменить: Null ptr APD: Null ptr IRD: Null ptr IPD: Null ptr|  
|SQL_DESC_BIND_OFFSET_PTR|SQLLEN *|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_BIND_TYPE|SQLINTEGER|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|ОТМЕНИТЬ: SQL_BIND_BY_COLUMN<br /><br /> APD: SQL_BIND_BY_COLUMN<br /><br /> IRD: неиспользуемые<br /><br /> IPD: неиспользуемые|  
SQL_DESC_COUNT|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: 0 APD: 0 IRD: D IPD: 0|  
|SQL_DESC_ROWS_PROCESSED_PTR|SQLULEN *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R/W IPD: R/W|Отменить: Неиспользуемые APD: неиспользуемые IRD: Null ptr IPD: Null ptr|  
  
 [1] Эти поля определены только в том случае, если IPD заполняется автоматически с помощью драйвера. Если это не так, они будут неопределенными. Если приложение пытается установить эти поля SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено.  
  
 Инициализация полей записей является, как показано в следующей таблице.  
  
|Имя поля записи|Тип|Чтение-запись|По умолчанию|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_AUTO_UNIQUE_VALUE|SQLINTEGER|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_BASE_COLUMN_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_BASE_TABLE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_CASE_SENSITIVE|SQLINTEGER|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_CATALOG_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_CONCISE_TYPE|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: SQL_C_ ПО УМОЛЧАНИЮ APD: IRD SQL_C_ ПО УМОЛЧАНИЮ: D IPD: ND|  
|SQL_DESC_DATA_PTR|УКАЗАТЕЛЬ SQLPOINTER|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые [2]|  
|SQL_DESC_DATETIME_INTERVAL_CODE|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_DATETIME_INTERVAL_PRECISION|SQLINTEGER|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
SQL_DESC_DISPLAY_SIZE|SQLLEN|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_FIXED_PREC_SCALE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_INDICATOR_PTR|SQLLEN *|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_LABEL|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LENGTH|SQLULEN|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_LITERAL_PREFIX|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LITERAL_SUFFIX|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LOCAL_TYPE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NULLABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_NUM_PREC_RADIX|SQLINTEGER|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
SQL_DESC_OCTET_LENGTH|SQLLEN|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH_PTR|SQLLEN *|Отменить: R/W APD: R/W IRD: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_PARAMETER_TYPE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: неиспользуемые IPD: R/W|Отменить: Неиспользуемые APD: неиспользуемые IRD: неиспользуемые IPD: D = SQL_PARAM_INPUT|  
|SQL_DESC_PRECISION|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_ROWVER|SQLSMALLINT|Отменить: неиспользуемые<br /><br /> APD: неиспользуемые<br /><br /> IRD: R<br /><br /> IPD: R|Отменить: неиспользуемые<br /><br /> APD: неиспользуемые<br /><br /> IRD: ND<br /><br /> IPD: ND|  
|SQL_DESC_SCALE|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_SCHEMA_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_SEARCHABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_TABLE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_TYPE|SQLSMALLINT|ОТМЕНИТЬ: APD R/W: IRD R/W: R IPD: R/W|ОТМЕНИТЬ: SQL_C_DEFAULT APD: SQL_C_DEFAULT IRD: D IPD: ND|  
SQL_DESC_TYPE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_UNNAMED|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R/W|ОТМЕНИТЬ: ND APD: ND IRD: D IPD: ND|  
|SQL_DESC_UNSIGNED|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_UPDATABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
  
 [1] Эти поля определены только в том случае, если IPD заполняется автоматически с помощью драйвера. Если это не так, они будут неопределенными. Если приложение пытается установить эти поля SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено.  
  
 [2] в IPD может быть задан параметр sql_desc_data_ptr принудительную проверку согласованности. В последующем вызове **SQLGetDescField** или **SQLGetDescRec**, драйвер не должен возвращать значение, которое было присвоено значение SQL_DESC_DATA_PTR.  
  
## <a name="fieldidentifier-argument"></a>Аргумент FieldIdentifier  
 *FieldIdentifier* аргумент указывает поле дескриптора, устанавливаемое значение. Дескриптор содержит *заголовка дескриптора* состоящий из полей заголовка, описанных в следующем разделе, «Заголовок поля» и ноль или несколько *записи дескриптора* состоящий из поля записей описывается в разделе, в следующем разделе «Поля заголовка».  
  
## <a name="header-fields"></a>Поля заголовка  
 Каждый дескриптор имеет заголовок, состоящий из следующих полей:  
  
 **SQL_DESC_ALLOC_TYPE [все]**  
 Это только для чтения поле заголовка SQLSMALLINT указывает ли дескриптор был выделен автоматически с помощью драйвера, или явно приложением. Приложения можно получить, но не изменяйте это поле. Поле будет присвоено SQL_DESC_ALLOC_AUTO драйвером, если дескриптор был автоматически выделяется с помощью драйвера. Он присваивается SQL_DESC_ALLOC_USER драйвером Если дескриптор явно была выделена для приложения.  
  
 **SQL_DESC_ARRAY_SIZE [дескрипторы приложения]**  
 В ARDs это поле заголовка SQLULEN указывает количество строк в наборе строк. Это число строк, возвращаемых при вызове **SQLFetch** или **SQLFetchScroll** или должна быть вызовом **SQLBulkOperations** или **SQLSetPos** .  
  
 В APDs это поле заголовка SQLULEN указывает число значений для каждого параметра.  
  
 По умолчанию значение этого поля равно 1. Если SQL_DESC_ARRAY_SIZE значение больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD или Отменить указывать массивов. Количество элементов каждого массива равно значению этого поля.  
  
 Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с помощью атрибута SQL_ATTR_ROW_ARRAY_SIZE. Это поле в дескрипторе параметра приложения можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAMSET_SIZE.  
  
 **SQL_DESC_ARRAY_STATUS_PTR [все]**  
 Для каждого дескриптора типа, этот SQLUSMALLINT * заголовок указывается массив полей SQLUSMALLINT значений. Такие массивы имеют следующие имена: строка, массив состояний (IRD), массив состояний параметров (IPD), массива операций строк (Отменить) и массив параметров операции (APD).  
  
 В IRD, это поле заголовка указывает на массив статусов строк, содержащий значения состояния после вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos**. Массив имеет столько элементов, сколько строк в наборе строк. Приложение должно выделить память для массива SQLUSMALLINTs и задайте в этом поле, чтобы он указывал на массив. Поле по умолчанию присваивается указатель null. Драйвер будет заполнить массив, если поле SQL_DESC_ARRAY_STATUS_PTR имеет значение является пустым указателем, в этом случае создаются без значения состояния и массива не заполняется.  
  
> [!CAUTION]  
>  Если приложение задает элементы массива строк состояния, на которые указывает поле SQL_DESC_ARRAY_STATUS_PTR IRD, поведение драйвера не определено.  
  
 Массив изначально была заполнена с помощью вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos**. Если вызов не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле не определено. Элементы в массиве может содержать следующие значения:  
  
-   SQL_ROW_SUCCESS: Строка была успешно сделана выборка и не изменилась со времени последней загрузки.  
  
-   SQL_ROW_SUCCESS_WITH_INFO: Строка была успешно сделана выборка и не изменилась со времени последней загрузки. Тем не менее предупреждение было возвращено о строке.  
  
-   SQL_ROW_ERROR: Произошла ошибка при извлечении строки.  
  
-   SQL_ROW_UPDATED: Строка была успешно сделана выборка и с момента последней загрузки была обновлена. Если строка выбирается заново, его состояние будет SQL_ROW_SUCCESS.  
  
-   Значение SQL_ROW_DELETED: Строка была удалена с момента последней загрузки.  
  
-   SQL_ROW_ADDED: Строки, вставленные в ходе **SQLBulkOperations**. Если строка выбирается заново, его состояние будет SQL_ROW_SUCCESS.  
  
-   SQL_ROW_NOROW: В наборе строк overlapped конец результирующего набора, и строка не был возвращен, что, предоставивших к данному элементу массив статусов строк.  
  
 Это поле в IRD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом значения SQL_ATTR_ROW_STATUS_PTR.  
  
 В поле SQL_DESC_ARRAY_STATUS_PTR IRD является допустимым, только в том случае, после возвращения SQL_SUCCESS или SQL_SUCCESS_WITH_INFO. Если код возврата, не является одним из них, расположении, указанном SQL_DESC_ROWS_PROCESSED_PTR не определено.  
  
 В IPD, это поле заголовка указывает на массив состояний параметров, содержащий сведения о состоянии для каждого набора значений параметров после вызова **SQLExecute** или **SQLExecDirect**. Если вызов **SQLExecute** или **SQLExecDirect** не возвратил значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле не определено. Приложение должно выделить память для массива SQLUSMALLINTs и задайте в этом поле, чтобы он указывал на массив. Драйвер будет заполнить массив, если поле SQL_DESC_ARRAY_STATUS_PTR имеет значение является пустым указателем, в этом случае создаются без значения состояния и массива не заполняется. Элементы в массиве может содержать следующие значения:  
  
-   SQL_PARAM_SUCCESS: Инструкция SQL была выполнена успешно для данного набора параметров.  
  
-   SQL_PARAM_SUCCESS_WITH_INFO: Инструкция SQL была успешно выполнена для данного набора параметров; Тем не менее предупреждение сведения можно найти в структуре данных диагностики.  
  
-   SQL_PARAM_ERROR: Произошла ошибка при обработке этого набора параметров. Дополнительные сведения об ошибке доступен в структуре данных диагностики.  
  
-   SQL_PARAM_UNUSED: Этот набор параметров не была задействована, возможно из-за того, что некоторые предыдущий набор параметров вызвала ошибку, что прервана дальнейшей обработки или SQL_PARAM_IGNORE было задано для данного набора параметров массива, заданного параметром SQL_DESC_ARRAY_ Поле STATUS_PTR дескрипторе параметра приложения.  
  
-   SQL_PARAM_DIAG_UNAVAILABLE: Диагностических сведений недоступен. Примером этого является при драйвер рассматривает массивы параметров как единое монолитных и поэтому не создает такой уровень сведений об ошибке.  
  
 Это поле в IPD можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_STATUS_PTR.  
  
 В Отменить, это поле заголовка указывает массива операций строк значений, которые могут устанавливаться для приложения, чтобы указать, относится ли эта строка будет пропускаться при **SQLSetPos** операций. Элементы в массиве может содержать следующие значения:  
  
-   SQL_ROW_PROCEED: Строка включается в операции массового с помощью **SQLSetPos**. (Этот параметр не гарантирует, что операция будет выполняться на строки. Если строка имеет состояние SQL_ROW_ERROR в массив статусов строк IRD, драйвер может не иметь возможность выполнять операции в строке.)  
  
-   SQL_ROW_IGNORE: Строка не будет производиться массовой операции с помощью **SQLSetPos**.  
  
 Если нет элементов массива, в операции массового включаются все строки. Если значение в поле SQL_DESC_ARRAY_STATUS_PTR Отменить является указателем null, все строки будут включены в операцию массовой; Интерпретация совпадает так, будто на который указывает указатель в допустимый массив и SQL_ROW_PROCEED были все элементы массива. Если элемент в массиве имеет значение SQL_ROW_IGNORE, значение в массив статусов строк для пропускаемых строк не изменяется.  
  
 Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_OPERATION_PTR.  
  
 В дескрипторе параметра приложения, это поле заголовка указывает на массив значений, которые могут устанавливаться для приложения, чтобы указать, является ли этот набор параметров, чтобы быть операции параметров игнорируются, когда **SQLExecute** или **SQLExecDirect**вызывается. Элементы в массиве может содержать следующие значения:  
  
-   SQL_PARAM_PROCEED: Набор параметров включается в **SQLExecute** или **SQLExecDirect** вызова.  
  
-   SQL_PARAM_IGNORE: Набор параметров не будет производиться **SQLExecute** или **SQLExecDirect** вызова.  
  
 Если нет элементов массива, все наборы параметров в массиве используются в **SQLExecute** или **SQLExecDirect** вызовов. Если значение в поле SQL_DESC_ARRAY_STATUS_PTR APD является указателем null, используются все наборы параметров; Интерпретация совпадает так, будто на который указывает указатель в допустимый массив и SQL_PARAM_PROCEED были все элементы массива.  
  
 Это поле в дескрипторе параметра приложения можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_OPERATION_PTR.  
  
 **SQL_DESC_BIND_OFFSET_PTR [дескрипторы приложения]**  
 Этот SQLLEN * заголовка поле указывает на смещение привязки. Он присваивается указатель null по умолчанию. Если это поле не является указателем null, драйвер разыменовывает указатель и добавляет разыменованное значение к каждому из отложенных полей, к которым имеет ненулевое значение в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) выборки во времени и использует новые значения указателя при привязке.  
  
 Смещение привязки всегда добавляется непосредственно значений в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется с другим значением, новое значение по-прежнему добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется значение поля, а также более ранних смещения.  
  
 Это поле является *отложенные поля*: он не используется во время его устанавливается, но используется в дальнейшем драйвером, когда требуется определить адреса для буферов данных.  
  
 Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_BIND_OFFSET_PTR. Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_BIND_OFFSET_PTR.  
  
 Дополнительные сведения см. в описании привязки на уровне строки в [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md) и [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md).  
  
 **SQL_DESC_BIND_TYPE [дескрипторы приложения]**  
 Это поле заголовка SQLUINTEGER задает ориентацию привязки для привязки столбцов или параметров.  
  
 В ARDs, это поле задает ориентацию привязки при **SQLFetchScroll** или **SQLFetch** вызывается для дескриптора связанный с ним оператор.  
  
 Чтобы выбрать привязку по столбцам для столбцов, это поле имеет значение равное SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с SQL_ATTR_ROW_BIND_TYPE *атрибут*.  
  
 В APDs это поле задает ориентацию привязки для использования динамических параметров.  
  
 Чтобы выбрать привязка на уровне столбцов для параметров, этого поля задается значение sql_bind_bind_by_column (по умолчанию).  
  
 Это поле в дескрипторе параметра приложения можно также задать, вызвав **SQLSetStmtAttr** с SQL_ATTR_PARAM_BIND_TYPE *атрибут*.  
  
 **SQL_DESC_COUNT [все]**  
 Это поле заголовка SQLSMALLINT указывает отсчитываемый от единицы индекс наибольший номер записи, которая содержит данные. Если драйвер устанавливает структуре данных для дескриптора, также необходимо задать поле SQL_DESC_COUNT, чтобы показать, сколько записей значимы. Если приложение выделяет экземпляр этой структуры данных, он не имеет для указания числа записей, чтобы зарезервировать место для. Как приложение указывает содержимое записей, драйвер принимает любое требуемое действие, чтобы убедиться, что дескриптор ссылается на структуру данных достаточного размера.  
  
 SQL_DESC_COUNT не число все столбцы данных, привязанных (если поле находится в Отменить) или для всех параметров, имеется привязка (если поле находится в APD), но номер записи наибольший номер. Если наибольший номер столбца или параметра является свободным, SQL_DESC_COUNT меняется на количество следующий наибольший номер столбца или параметра. Если столбец или параметр с номером, меньше, чем номер столбца новейшую отменяется привязка (путем вызова **SQLBindCol** с *TargetValuePtr* аргумент значение null указателя или **SQLBindParameter** с *ParameterValuePtr* аргумент значение является пустым указателем), SQL_DESC_COUNT не изменяется. Если дополнительные столбцы или параметры связаны с числа больше наибольшего запись, которая содержит данные, драйвер автоматически увеличивает значение в поле SQL_DESC_COUNT. Если все столбцы являются несвязанных путем вызова **SQLFreeStmt** с параметром SQL_UNBIND поля SQL_DESC_COUNT Отменить и IRD устанавливаются в значение 0. Если **SQLFreeStmt** вызывается с параметром SQL_RESET_PARAMS поля SQL_DESC_COUNT в APD и IPD устанавливаются в значение 0.  
  
 Значение в SQL_DESC_COUNT задаются явным образом приложения путем вызова **SQLSetDescField**. Если значение в SQL_DESC_COUNT явным образом снижается, удаляются все записи с номерами больше, чем новое значение в SQL_DESC_COUNT. Если значение в SQL_DESC_COUNT явно установлен в 0, поле находится в Отменить данных за исключением столбца привязанного закладки будут освобождены все буфера.  
  
 Число записей в этом поле Отменить не включает столбец привязанного закладки. Единственный способ отменить привязку столбца закладки — присвоить SQL_DESC_DATA_PTR поле является пустым указателем.  
  
 **SQL_DESC_ROWS_PROCESSED_PTR [реализации дескрипторы]**  
 В IRD, этот SQLULEN \* заголовка поле указывает на буфер, содержащий число возвращаемых строк после вызова **SQLFetch** или **SQLFetchScroll**, или количество строк, затронутых при массовой операции выполняется путем вызова **SQLBulkOperations** или **SQLSetPos**, включая строки ошибок.  
  
 В IPD этот SQLUINTEGER * заголовка поле указывает на буфер, содержащий число наборов параметров, которые будут обработаны, включая наборы ошибки. Номер не будет возвращаться, если это является пустым указателем.  
  
 SQL_DESC_ROWS_PROCESSED_PTR является допустимым только в том случае, после возвращения SQL_SUCCESS или SQL_SUCCESS_WITH_INFO после вызова **SQLFetch** или **SQLFetchScroll** (для IRD-полю) или **SQLExecute** , **SQLExecDirect**, или **SQLParamData** (для IPD-поле). Если вызов, который заполняет буфер, на который указывает это поле не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определены, если только он вернет значение SQL_NO_DATA, в котором значение в буфер имеет значение 0.  
  
 Это поле в Отменить можно также задать, вызвав **SQLSetStmtAttr** с помощью атрибута SQL_ATTR_ROWS_FETCHED_PTR. Это поле в дескрипторе параметра приложения можно также задать, вызвав **SQLSetStmtAttr** с атрибут sql_attr_params_processed_ptr должен.  
  
 Буфер, на который указывает это поле выделяется для приложения. Это отложенного выходной буфер, который задается с помощью драйвера. Он присваивается указатель null по умолчанию.  
  
## <a name="record-fields"></a>Запись поля  
 Каждый дескриптор содержит одну или несколько записей, состоящий из полей, которые определяют данные столбца или динамических параметров, в зависимости от типа дескриптора. Каждая запись имеет полное определение одного столбца или параметра.  
  
 **SQL_DESC_AUTO_UNIQUE_VALUE [IRDs]**  
 Это только для чтения поле записи SQLINTEGER содержит SQL_TRUE, если столбец является столбцом с автоматическим приращением, или значение SQL_FALSE, если столбец не является столбцом с автоматическим приращением. Это поле доступно только для чтения, но базового столбца автоприращения не обязательно предназначены только для чтения.  
  
 **SQL_DESC_BASE_COLUMN_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит имя базового столбца для столбца результирующего набора. Если имя базового столбца не существует (как в случае столбцы, являющиеся выражениями), эта переменная содержит пустую строку.  
  
 **SQL_DESC_BASE_TABLE_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит имя базовой таблицы, для столбца результирующего набора. Если имя базовой таблицы не могут быть определены или не применяется, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CASE_SENSITIVE [реализации дескрипторы]**  
 Это только для чтения поле записи SQLINTEGER содержит SQL_TRUE, если столбец или параметр интерпретируется, как с учетом регистра для сортировки и сравнения или значение SQL_FALSE Если столбец не обрабатывается, как с учетом регистра для сортировки и сравнений, или если он является символьным столбец.  
  
 **SQL_DESC_CATALOG_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит каталог для базовой таблицы, содержащей столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления. Если источник данных не поддерживает каталоги или каталог не может быть определено, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CONCISE_TYPE [все]**  
 Это поле заголовка SQLSMALLINT тип краткие данные для всех типов данных, включая типы данных даты и времени и интервала.  
  
 Значения в полях SQL_DESC_CONCISE_TYPE SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE зависят друг от друга. Каждый раз одно из полей имеет значение, другой также должно быть задано. Можно задать с помощью вызова SQL_DESC_CONCISE_TYPE **SQLBindCol** или **SQLBindParameter**, или **SQLSetDescField**. SQL_DESC_TYPE можно задать с помощью вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если SQL_DESC_CONCISE_TYPE краткими тип, отличный от типа данных interval или даты и времени, поле SQL_DESC_TYPE устанавливается то же значение, и поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение 0.  
  
 Если SQL_DESC_CONCISE_TYPE присвоено краткими тип данных даты-времени или интервал, поле SQL_DESC_TYPE устанавливается с нужным типом verbose (SQL_DATETIME или SQL_INTERVAL) и поля SQL_DESC_DATETIME_INTERVAL_CODE задается соответствующий дополнительный код.  
  
 **SQL_DESC_DATA_PTR [дескрипторов приложений и поставщики IDP]**  
 Этот указатель SQLPOINTER записей поле указывает на переменную, которая будет содержать значение параметра (для APDs) или значение столбца (для ARDs). Это поле является *отложенные поля*. Он не используется во время его устанавливается, но используется позже с помощью драйвера для получения данных.  
  
 Столбец, указанный в поле SQL_DESC_DATA_PTR Отменить отменяется, если *TargetValuePtr* аргумента в вызове **SQLBindCol** является пустым указателем или если в поле SQL_DESC_DATA_PTR Отменить задается вызов **SQLSetDescField** или **SQLSetDescRec** на указатель null. Если задан параметр sql_desc_data_ptr на указатель null, другие поля не затрагиваются.  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** что заливки в буфере, это поле не возвратил значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Каждый раз, когда поле SQL_DESC_DATA_PTR в APD, Отменить или IPD имеет значение, драйвер проверяет, что значение в поле SQL_DESC_TYPE содержит одно из допустимых типов данных ODBC C или тип данных, и что все поля, влияющие на типы данных согласованы. Запрос проверки согласованности является использование только поля SQL_DESC_DATA_PTR IPD. В частности Если приложение задает поле SQL_DESC_DATA_PTR IPD и последующие вызовы **SQLGetDescField** на это поле не является обязательно возвращается значение, которое оно задано. Дополнительные сведения см. в разделе «Проверки согласованности» в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_CODE [все]**  
 Это поле записи SQLSMALLINT содержит дополнительный код для конкретного типа данных даты-времени или интервал, когда поле SQL_DESC_TYPE равно SQL_DATETIME или SQL_INTERVAL. Это справедливо для типов данных SQL и C. Код состоит из имени типа данных с «Код» заменить «TYPE» или «C_TYPE» (для типов даты и времени) или «Код» заменить «ИНТЕРВАЛ» или «C_INTERVAL» (для типов интервалов).  
  
 Если дескриптор не связан с дескриптором инструкции SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE в дескриптор приложений имеют значение SQL_C_DEFAULT, содержимое SQL_DESC_DATETIME_INTERVAL_CODE не определены.  
  
 Это поле можно задать для типов данных даты и времени, перечисленные в следующей таблице.  
  
|Типы даты и времени|DATETIME_INTERVAL_CODE|  
|--------------------|------------------------------|  
|SQL_TYPE_DATE/SQL_C_TYPE_DATE|SQL_CODE_DATE|  
|SQL_TYPE_TIME/SQL_C_TYPE_TIME|SQL_CODE_TIME|  
|SQL_TYPE_TIMESTAMP / SQL_C_TYPE_TIMESTAMP|SQL_CODE_TIMESTAMP|  
  
 Это поле можно задать для интервальных типов данных, перечисленные в следующей таблице.  
  
|Тип интервала|DATETIME_INTERVAL_CODE|  
|-------------------|------------------------------|  
|SQL_INTERVAL_DAY / SQL_C_INTERVAL_DAY|SQL_CODE_DAY|  
|SQL_INTERVAL_DAY_TO_HOUR / SQL_C_INTERVAL_DAY_TO_HOUR|SQL_CODE_DAY_TO_HOUR|  
|SQL_INTERVAL_DAY_TO_MINUTE / SQL_C_INTERVAL_DAY_TO_MINUTE|SQL_CODE_DAY_TO_MINUTE|  
|SQL_INTERVAL_DAY_TO_SECOND / SQL_C_INTERVAL_DAY_TO_SECOND|SQL_CODE_DAY_TO_SECOND|  
|SQL_INTERVAL_HOUR / SQL_C_INTERVAL_HOUR|SQL_CODE_HOUR|  
QL_INTERVAL_HOUR_TO_MINUTE / SQL_C_INTERVAL_HOUR_TO_MINUTE|SQL_CODE_HOUR_TO_MINUTE|  
|SQL_INTERVAL_HOUR_TO_SECOND / SQL_C_INTERVAL_HOUR_TO_SECOND|SQL_CODE_HOUR_TO_SECOND|  
|SQL_INTERVAL_MINUTE / SQL_C_INTERVAL_MINUTE|SQL_CODE_MINUTE|  
|SQL_INTERVAL_MINUTE_TO_SECOND / SQL_C_INTERVAL_MINUTE_TO_SECOND|SQL_CODE_MINUTE_TO_SECOND|  
|SQL_INTERVAL_MONTH / SQL_C_INTERVAL_MONTH|SQL_CODE_MONTH|  
QL_INTERVAL_SECOND / SQL_C_INTERVAL_SECOND|SQL_CODE_SECOND|  
|SQL_INTERVAL_YEAR / SQL_C_INTERVAL_YEAR|SQL_CODE_YEAR|  
|SQL_INTERVAL_YEAR_TO_MONTH / SQL_C_INTERVAL_YEAR_TO_MONTH|SQL_CODE_YEAR_TO_MONTH|  
  
 Дополнительные сведения о интервалы данных, а это поле, см. в разделе [данных идентификаторы и дескрипторы типов](../../../odbc/reference/appendixes/data-type-identifiers-and-descriptors.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_PRECISION [все]**  
 Это поле записи SQLINTEGER содержит точности интервала, если поле SQL_DESC_TYPE SQL_INTERVAL. Если поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение к типу данных интервала, это поле имеет значение для главного параметра точности интервала по умолчанию.  
  
 **Столбцов SQL_DESC_DISPLAY_SIZE [IRDs]**  
 Это только для чтения поле записи SQLINTEGER содержит максимальное число символов, необходимых для отображения данных из столбца.  
  
 **SQL_DESC_FIXED_PREC_SCALE [реализации дескрипторы]**  
 Это поле записи SQLSMALLINT только для чтения имеет значение SQL_TRUE, если столбец является столбцом точные числовые и имеет фиксированные точность и масштаб ненулевое значение, или значение SQL_FALSE, если столбец не является точного числового столбца с фиксированной точностью и масштабом.  
  
 **SQL_DESC_INDICATOR_PTR [дескрипторы приложения]**  
 В ARDs, этот SQLLEN * записи поле указывает на переменную признака. Эта переменная содержит значение SQL_NULL_DATA, если значение столбца равно NULL. Для APDs переменная индикатора устанавливается в значение SQL_NULL_DATA для указания динамические аргументы NULL. В противном случае переменная является ноль (если значения в SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR — тот же указатель).  
  
 Если поле SQL_DESC_INDICATOR_PTR Отменить является указателем null, драйвер запрещено. Возврат сведений о, является ли столбец значение NULL или нет. Если столбец имеет значение NULL и SQL_DESC_INDICATOR_PTR является пустым указателем, SQLSTATE 22002 (переменная индикатора требуется, но не указано) возвращается, если драйвер пытается заполнить буфер после вызова **SQLFetch** или  **SQLFetchScroll**. Если вызов **SQLFetch** или **SQLFetchScroll** не возвратил значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определены.  
  
 Поле SQL_DESC_INDICATOR_PTR определяет, имеет ли поле, на которые указывают SQL_DESC_OCTET_LENGTH_PTR значение. Если значение столбца равно NULL, драйвер задает переменную признака в значение SQL_NULL_DATA. Затем поля, на которые указывают SQL_DESC_OCTET_LENGTH_PTR не задается. Если значение NULL не обнаружено во время выборки, буфера, SQL_DESC_INDICATOR_PTR, равным нулю, и буфер, на которые указывают SQL_DESC_OCTET_LENGTH_PTR задается равным длину данных.  
  
 Если поле SQL_DESC_INDICATOR_PTR в APD является указателем null, приложение нельзя использовать эту запись с дескриптора для указания аргументов NULL.  
  
 Это поле является *отложенные поля*: он не используется во время его устанавливается, но используется позже с помощью драйвера указать допустимость значений NULL (ARDs) или требуется определить допустимость значений NULL (для APDs).  
  
 **SQL_DESC_LABEL [IRDs]**  
 Это только для чтения SQLCHAR * содержит поле записи метки столбца или заголовок. Если столбец не содержит метку, эта переменная содержит имя столбца. Если столбец без имени и без метки, эта переменная содержит пустую строку.  
  
 **SQL_DESC_LENGTH [все]**  
 Это поле записи SQLULEN — фактическое или Максимальная длина символьной строки в символах или двоичный тип данных в байтах. Это максимальная длина для типа данных фиксированной длины или фактическая длина для типа данных переменной длины. Его значение всегда не включает символ завершения null, которым заканчивается символьной строки. Для значений, тип которого — SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или один из типов данных SQL интервала это поле имеет длину в символах символов строкового представления значения даты и времени или интервал.  
  
 Значение этого поля может отличаться от значения «Длина» как определенный в ODBC 2 *.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_LITERAL_PREFIX [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит символ или символы, которые драйвер распознает как префикс для литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого префикс литерала не применимо.  
  
 **SQL_DESC_LITERAL_SUFFIX [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит символ или символы, которые драйвер распознает в качестве суффикса для литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого литеральный суффикс не применимо.  
  
 **SQL_DESC_LOCAL_TYPE_NAME [реализации дескрипторы]**  
 Это только для чтения SQLCHAR * поле записи содержит все локализованные (собственное) название языка для типа данных, который может отличаться от стандартное имя типа данных. Если отсутствует локализованное имя, возвращается пустая строка. Это поле является только в целях отображения.  
  
 **SQL_DESC_NAME [реализации дескрипторы]**  
 Этот SQLCHAR * поле записи в дескрипторе строки содержит псевдоним столбца, если он применяется. Если псевдоним столбца не применимо, возвращается имя столбца. В любом случае драйвер устанавливает поля SQL_DESC_UNNAMED значение SQL_NAMED при определении поля SQL_DESC_NAME. Если отсутствует имя столбца или псевдоним столбца, драйвер возвращает пустую строку в поля SQL_DESC_NAME и задает для поля SQL_DESC_UNNAMED SQL_UNNAMED.  
  
 Приложение может задать поля SQL_DESC_NAME IPD для параметра имя или псевдоним, чтобы указать параметры хранимой процедуры по имени. (Дополнительные сведения см. в разделе [привязка параметров по имени (именованные параметры)](../../../odbc/reference/develop-app/binding-parameters-by-name-named-parameters.md).) В поле SQL_DESC_NAME IRD является полем только для чтения; SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), будет возвращено в том случае, если приложение пытается его изменить.  
  
 В поставщики IDP это поле не определено, если драйвер не поддерживает именованные параметры. Если драйвер поддерживает именованные параметры и способен описания параметров, в этом поле возвращается имя параметра.  
  
 **SQL_DESC_NULLABLE [реализации дескрипторы]**  
 В IRDs это только для чтения поле записи SQLSMALLINT является SQL_NULLABLE, если столбец может иметь значения NULL SQL_NO_NULLS, если столбец не имеет значения NULL, либо SQL_NULLABLE_UNKNOWN, если неизвестно, допускает ли столбец значения NULL. Это поле относится к столбцу результирующего набора, не базового столбца.  
  
 В поставщики IDP это поле всегда присваивается SQL_NULLABLE так, как динамические параметры всегда допускают значение NULL и не может быть приложением.  
  
 **SQL_DESC_NUM_PREC_RADIX [все]**  
 Это поле SQLINTEGER содержит значение 2, если тип данных в поле SQL_DESC_TYPE имеет тип приблизительных числовых данных, так как поле SQL_DESC_PRECISION содержит количество битов. Это поле содержит значение 10, если тип данных в поле SQL_DESC_TYPE имеет тип точных числовых данных, так как поле SQL_DESC_PRECISION содержит количество цифр дробной части. Это поле имеет значение 0 для всех типов нечисловые данные.  
  
 **SQL_DESC_OCTET_LENGTH [все]**  
 Это поле записи SQLLEN содержит длину в байтах символьной строки или двоичный тип данных. Для фиксированной длины символьных или двоичных типов это фактическая длина в байтах. Для переменной длины символьных или двоичных типов это максимальная длина в байтах. Это значение всегда не включает место для символа конечное значение null для реализации дескрипторов и всегда включает свободное место для символа конечное значение null для дескрипторов приложения. Для данных приложений это поле содержит размер буфера. Для APDs это поле определено только для вывода или входных и выходных параметров.  
  
 **SQL_DESC_OCTET_LENGTH_PTR [дескрипторы приложения]**  
 Этот SQLLEN * записи поле указывает на переменную, которая будет содержать общая длина в байтах динамического аргумента (для параметра дескрипторов) или значение привязанного столбца (для дескрипторов строк).  
  
 Для APD это значение учитывается для всех аргументов, за исключением символьная строка и двоичный файл; Если это поле указывает SQL_NTS, динамического аргумента должно оканчиваться нулевым символом. Чтобы указать, что привязанного параметра будет параметра данных во время выполнения, приложение устанавливает для этого поля в соответствующей записи APD переменной, выполните на время, будет содержать значение SQL_DATA_AT_EXEC или результата SQL_LEN_DATA_AT_EXEC макроса . Если имеется более одного поля, SQL_DESC_DATA_PTR может быть присвоено значение, однозначно идентифицирующее параметра помогут определить, какой параметр запрашивается приложения.  
  
 Если в поле OCTET_LENGTH_PTR Отменить является указателем null, драйвер не возвращает сведения о длине столбца. Если поле SQL_DESC_OCTET_LENGTH_PTR в APD является указателем null, драйвер предполагается, что символьные строки, а также двоичные значения нулем. (Двоичных значений не должно быть нулем, но должна иметь длину, чтобы избежать усечения.)  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** что заливки в буфере, это поле не возвратил значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено. Это поле является *отложенные поля*. Он не используется во время его устанавливается, но используется позже с помощью драйвера для определения или указать длительность октета данных.  
  
 **SQL_DESC_PARAMETER_TYPE [поставщики IDP]**  
 Это SQLSMALLINT поле записи имеет значение SQL_PARAM_INPUT для входного параметра, SQL_PARAM_INPUT_OUTPUT для параметра ввода вывода, SQL_PARAM_OUTPUT для выходного параметра, SQL_PARAM_INPUT_OUTPUT_STREAM для параметра потокового ввода вывода или SQL_ PARAM_OUTPUT_STREAM для выходным потоком. Он имеет значение SQL_PARAM_INPUT по умолчанию.  
  
 Для IPD поле имеет значение SQL_PARAM_INPUT по умолчанию если IPD не заполняется автоматически с помощью драйвера (атрибут инструкции SQL_ATTR_ENABLE_AUTO_IPD — SQL_FALSE). Приложение должно установить это поле в IPD для параметров, которые не являются входными параметрами.  
  
 **SQL_DESC_PRECISION [все]**  
 Это поле записи SQLSMALLINT содержит количество цифр для точный числовой тип, число бит в мантиссе (двоичной точностью) для приблизительный числовой тип или количество цифр в доли секунды для SQL_TYPE_TIME SQL_TYPE _TIMESTAMP или SQL_INTERVAL_SECOND типом данных. Это поле не определено для всех других типов данных.  
  
 В этом поле значение может отличаться от значения для «точность» как определенный в ODBC 2 *.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_ROWVER [реализации дескрипторы]**  
 Это поле SQLSMALLINTrecord указывает, был ли столбец автоматически изменен СУБД при обновлении строки (например, столбец типа «timestamp» в SQL Server). Это поле записи имеет значение SQL_TRUE, если столбец является столбцом управление версиями строк, а также значение SQL_FALSE в противном случае. Этот атрибут столбца аналогично вызову **SQLSpecialColumns** с IdentifierType SQL_ROWVER, чтобы определить, является ли столбец автоматически обновляется.  
  
 **SQL_DESC_SCALE [все]**  
 Это поле записи SQLSMALLINT содержит заданного масштаба для десятичных и числовых типов данных. Поле не определено для всех других типов данных.  
  
 В этом поле значение может отличаться от значения «масштаб», как определено в ODBC 2 *.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_SCHEMA_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится имя схемы, содержащей столбец базовой таблицы. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления. Если источник данных не поддерживает схемы или невозможно определить имя схемы, эта переменная содержит пустую строку.  
  
 **SQL_DESC_SEARCHABLE [IRDs]**  
 Это только для чтения поле записи SQLSMALLINT присваивается одно из следующих значений:  
  
-   SQL_PRED_NONE, если столбец не может использоваться в **ГДЕ** предложение. (Это то же самое значение SQL_UNSEARCHABLE в ODBC 2 *.x*.)  
  
-   SQL_PRED_CHAR, если столбец может использоваться в **ГДЕ** предложение, но только с **как** предиката. (Это то же самое значение SQL_LIKE_ONLY в ODBC 2 *.x*.)  
  
-   SQL_PRED_BASIC, если столбец может использоваться в **ГДЕ** предложение со всеми операторами сравнения, за исключением **как**. (Это то же самое значение SQL_EXCEPT_LIKE в ODBC 2 *.x*.)  
  
-   SQL_PRED_SEARCHABLE, если столбец может использоваться в **ГДЕ** предложение с любым оператором сравнения.  
  
 **SQL_DESC_TABLE_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится имя базовой таблицы, который содержит этот столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления.  
  
 **SQL_DESC_TYPE [все]**  
 Это поле записи SQLSMALLINT указывает краткими SQL или C тип данных для всех типов данных, за исключением типов данных даты и времени и интервала. Для типов данных даты и времени и интервала это поле указывает тип подробные данные, который равно SQL_DATETIME или SQL_INTERVAL.  
  
 Каждый раз, когда это поле содержит SQL_DATETIME или SQL_INTERVAL, SQL_DESC_DATETIME_INTERVAL_CODE поле должно содержать соответствующие дополнительным кодом для тип сокращения. Для типов данных даты и времени SQL_DESC_TYPE содержит SQL_DATETIME и поле SQL_DESC_DATETIME_INTERVAL_CODE содержит дополнительный код для типа данных, дату и время. Для интервальных типов данных SQL_DESC_TYPE содержит SQL_INTERVAL и поле SQL_DESC_DATETIME_INTERVAL_CODE содержит дополнительный код для типа данных через определенный интервал времени.  
  
 Значения в поля SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE зависят друг от друга. Каждый раз одно из полей имеет значение, другой также должно быть задано. SQL_DESC_TYPE можно задать с помощью вызова **SQLSetDescField** или **SQLSetDescRec**. Можно задать с помощью вызова SQL_DESC_CONCISE_TYPE **SQLBindCol** или **SQLBindParameter**, или **SQLSetDescField**.  
  
 Если SQL_DESC_TYPE устанавливается краткими тип, отличный от типа данных interval или даты и времени, поле SQL_DESC_CONCISE_TYPE установлено то же значение, и поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение 0.  
  
 Если SQL_DESC_TYPE устанавливается verbose datetime или тип данных интервала (SQL_DATETIME или SQL_INTERVAL) и поля SQL_DESC_DATETIME_INTERVAL_CODE задается соответствующий дополнительный код, поле ТИПА SQL_DESC_CONCISE присваивается соответствующий тип сокращения. Попытка установить SQL_DESC_TYPE к одному из краткого типов даты-времени или интервал вернет SQLSTATE HY021 (несовместимые сведения дескриптора).  
  
 Когда поле SQL_DESC_TYPE устанавливается с помощью вызова **SQLBindCol**, **SQLBindParameter**, или **SQLSetDescField**, следующие поля заданы следующие значения по умолчанию, как показано в следующей таблице. Значения остальных полей в той же записи не определены.  
  
|Значение SQL_DESC_TYPE|Неявно задать другие поля|  
|------------------------------|---------------------------------|  
|SQL_CHAR, SQL_VARCHAR, SQL_C_CHAR, SQL_C_VARCHAR|SQL_DESC_LENGTH имеет значение 1. SQL_DESC_PRECISION имеет значение 0.|  
|SQL_DATETIME|Если имеет значение SQL_DESC_DATETIME_INTERVAL_CODE SQL_CODE_DATE или SQL_CODE_TIME, SQL_DESC_PRECISION имеет значение 0. Если он имеет значение SQL_DESC_TIMESTAMP, SQL_DESC_PRECISION равна 6.|  
|SQL_C_NUMERIC SQL_DECIMAL SQL_NUMERIC,|SQL_DESC_SCALE имеет значение 0. SQL_DESC_PRECISION присваивается определенное реализацией точность для типа данных.<br /><br /> См. в разделе [SQL в C: числовые](../../../odbc/reference/appendixes/sql-to-c-numeric.md) сведения о том, как вручную привязать значение SQL_C_NUMERIC.|  
|SQL_FLOAT SQL_C_FLOAT|Имеет значение SQL_DESC_PRECISION точность по умолчанию, определяемое реализацией для SQL_FLOAT.|  
|SQL_INTERVAL|Если к типу данных interval имеет значение SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_DATETIME_INTERVAL_PRECISION имеет значение 2 (точность по умолчанию интервал начальные). Если интервал компонента секунд, SQL_DESC_PRECISION имеет значение 6 (точность секунд интервал по умолчанию).|  
  
 Если приложение вызывает **SQLSetDescField** задать поля дескриптора, вместо вызова метода **SQLSetDescRec**, приложение сначала необходимо объявить тип данных. Когда это происходит, неявно задаются другие поля, отмеченные в предыдущей таблице. Если какие-либо значения неявно набора неприемлемы, приложение может затем вызвать **SQLSetDescField** или **SQLSetDescRec** явным образом задать недопустимые значения.  
  
 **SQL_DESC_TYPE_NAME [реализации дескрипторы]**  
 Это только для чтения SQLCHAR * поле записи содержит имя типа зависит от источника данных (например, «CHAR», «VARCHAR» и т. д.). Если неизвестно имя типа данных, эта переменная содержит пустую строку.  
  
 **SQL_DESC_UNNAMED [реализации дескрипторы]**  
 Этого поля записи SQLSMALLINT в дескрипторе строки задается с помощью драйвера SQL_NAMED или SQL_UNNAMED, при задании поля SQL_DESC_NAME. Если поля SQL_DESC_NAME содержит псевдоним столбца или псевдоним столбца не применяется, драйвер устанавливает для поля SQL_DESC_UNNAMED значение SQL_NAMED. Если приложение задает поля SQL_DESC_NAME IPD имя параметра или псевдоним, драйвер задает поле IPD SQL_DESC_UNNAMED значение SQL_NAMED. Если отсутствует имя столбца или псевдоним столбца, драйвер задает для поля SQL_DESC_UNNAMED SQL_UNNAMED.  
  
 Приложение может задать поле SQL_DESC_UNNAMED IPD для SQL_UNNAMED. Драйвер возвращает SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), если приложение пытается задать поле IPD SQL_DESC_UNNAMED значение SQL_NAMED. Поле SQL_DESC_UNNAMED IRD доступен только для чтения; SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), будет возвращено в том случае, если приложение пытается его изменить.  
  
 **SQL_DESC_UNSIGNED [реализации дескрипторы]**  
 Если автоматический тип столбца этой записи поле только для чтения типа SQLSMALLINT, значение SQL_TRUE, если столбец имеет тип без знака, так и нечисловых или SQL_FALSE.  
  
 **SQL_DESC_UPDATABLE [IRDs]**  
 Это только для чтения поле записи SQLSMALLINT присваивается одно из следующих значений:  
  
-   SQL_ATTR_READ_ONLY, если столбец результирующего набора только для чтения.  
  
-   SQL_ATTR_WRITE, если столбец результирующего набора — чтение и запись.  
  
-   SQL_ATTR_READWRITE_UNKNOWN, если он не является ли столбец результирующего набора является обновляемым, или нет.  
  
 SQL_DESC_UPDATABLE описывает возможность обновления столбца в результирующем наборе, не столбец в базовой таблице. Возможность обновления столбца в базовой таблице, на котором основан этот столбец результирующего набора может отличаться от значения в этом поле. Является ли столбец обновляемых могут основываться на тип данных, права доступа пользователя и определения результирующего набора, сам. Если неясно, является ли столбец можно обновлять, SQL_ATTR_READWRITE_UNKNOWN должно быть возвращено.  
  
## <a name="consistency-checks"></a>Проверка согласованности  
 Проверка согласованности выполняется с помощью драйвера автоматически каждый раз, когда приложение передает значение для поля SQL_DESC_DATA_PTR Отменить, APD или IPD. Если поля не согласуется с другими полями **SQLSetDescField** вернет SQLSTATE HY021 (несовместимые сведения дескриптора). Дополнительные сведения см. в разделе «Проверка согласованности» в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка столбца|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка параметра|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Получение поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Установка нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)
