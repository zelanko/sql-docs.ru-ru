---
title: Функция SQLForeignKeys | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLForeignKeys
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLForeignKeys
helpviewer_keywords:
- SQLForeignKeys function [ODBC]
ms.assetid: 07f3f645-f643-4d39-9a10-70a72f24e608
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 5f2769fb378a5ee989fb6a0351537edb3de03469
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81285864"
---
# <a name="sqlforeignkeys-function"></a>Функция SQLForeignKeys
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ODBC  
  
 **Сводка**  
 **SQLForeignKeys** может возвращать:  
  
-   Список внешних ключей в указанной таблице (столбцы в указанной таблице, которые ссылаются на первичные ключи в других таблицах).  
  
-   Список внешних ключей в других таблицах, ссылающихся на первичный ключ в указанной таблице.  
  
 Драйвер возвращает каждый список в качестве результирующего набора для указанной инструкции.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLForeignKeys(  
     SQLHSTMT       StatementHandle,  
     SQLCHAR *      PKCatalogName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      PKSchemaName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      PKTableName,  
     SQLSMALLINT    NameLength3,  
     SQLCHAR *      FKCatalogName,  
     SQLSMALLINT    NameLength4,  
     SQLCHAR *      FKSchemaName,  
     SQLSMALLINT    NameLength5,  
     SQLCHAR *      FKTableName,  
     SQLSMALLINT    NameLength6);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *пккаталогнаме*  
 Входной Имя каталога таблицы первичного ключа. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает таблицы, не имеющие каталогов. *Пккаталогнаме* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *пккаталогнаме* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *пккаталогнаме* является обычным аргументом. он обрабатывается буквально, и его регистр важен. Дополнительные сведения см. [в разделе аргументы в функциях каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 Входной Длина **пккаталогнаме*в символах.  
  
 *пксчеманаме*  
 Входной Имя схемы таблицы первичного ключа. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает те таблицы, которые не имеют схем. *Пксчеманаме* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *пксчеманаме* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *пксчеманаме* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength2*  
 Входной Длина **пксчеманаме*в символах.  
  
 *PKTableName*  
 Входной Имя таблицы первичного ключа. *PKTableName* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *PKTableName* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *PKTableName* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength3*  
 Входной Длина **PKTableName*в символах.  
  
 *фккаталогнаме*  
 Входной Имя каталога таблиц внешнего ключа. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает таблицы, не имеющие каталогов. *Фккаталогнаме* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *фккаталогнаме* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *фккаталогнаме* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength4*  
 Входной Длина **фккаталогнаме*в символах.  
  
 *фксчеманаме*  
 Входной Имя схемы таблицы внешнего ключа. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, пустая строка ("") обозначает те таблицы, которые не имеют схем. *Фксчеманаме* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *фксчеманаме* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *фксчеманаме* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength5*  
 Входной Длина **фксчеманаме*в символах.  
  
 *фктабленаме*  
 Входной Имя таблицы внешнего ключа. *Фктабленаме* не может содержать шаблон поиска строки.  
  
 Если атрибуту инструкции SQL_ATTR_METADATA_ID присвоено значение SQL_TRUE, *фктабленаме* рассматривается как идентификатор и его регистр не важен. Если это SQL_FALSE, *фктабленаме* является обычным аргументом. он обрабатывается буквально, и его регистр важен.  
  
 *NameLength6*  
 Входной Длина **фктабленаме*в символах.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLForeignKeys** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLForeignKeys** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|24 000|Недопустимое состояние курсора|В *статеменсандле*был открыт курсор, а также был вызван **SQLFetch** или **SQLFetchScroll** . Эта ошибка возвращается диспетчером драйверов, если **SQLFetch** или **SQLFetchScroll** не вернул SQL_NO_DATA, и возвращается драйвером, если **SQLFetch** или **SQLFetchScroll** вернул SQL_NO_DATA.<br /><br /> В *статеменсандле*был открыт курсор, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Выполнен откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере * \*MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *Статеменсандле*, а затем в *статеменсандле*был вызвана функция.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) аргументы *PKTableName* и *фктабленаме* были оба нулевых указателя.<br /><br /> Атрибуту инструкции SQL_ATTR_METADATA_ID было присвоено значение SQL_TRUE, аргумент *фккаталогнаме* или *пккаталогнаме* является пустым указателем, а SQL_CATALOG_NAME *инфотипе* возвращает, что эти имена каталогов поддерживаются.<br /><br /> (DM) атрибуту инструкции SQL_ATTR_METADATA_ID было присвоено значение SQL_TRUE, а аргумент *фксчеманаме*, *пксчеманаме*, *фктабленаме*или *PKTableName* является пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции SQLForeignKeys.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение одного из аргументов длины имени меньше 0, но не равно SQL_NTS.|  
|||Значение одного из аргументов длины имени превышает максимальную длину для соответствующего имени. (См. раздел "Комментарии".)|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Указано имя каталога, а драйвер или источник данных не поддерживает каталоги.<br /><br /> Указано имя схемы, а драйвер или источник данных не поддерживает схемы.|  
|||Сочетание текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживалось драйвером или источником данных.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 Сведения о том, как можно использовать сведения, возвращаемые этой функцией, см. в разделе [использование данных каталога](../../../odbc/reference/develop-app/uses-of-catalog-data.md).  
  
 Если \* *PKTableName* содержит имя таблицы, **SQLForeignKeys** возвращает результирующий набор, содержащий первичный ключ указанной таблицы и все внешние ключи, ссылающиеся на нее. Список внешних ключей в других таблицах не включает внешние ключи, указывающие на ограничения UNIQUE в указанной таблице.  
  
 Если \* *фктабленаме* содержит имя таблицы, **SQLForeignKeys** возвращает результирующий набор, содержащий все внешние ключи в указанной таблице, которые указывают на первичные ключи в других таблицах, а также первичные ключи в других таблицах, на которые они ссылаются. Список внешних ключей в указанной таблице не содержит внешних ключей, которые ссылаются на уникальные ограничения в других таблицах.  
  
 Если оба \* *PKTableName* и \* *фктабленаме* содержат имена таблиц, **SQLForeignKeys** Возвращает внешние ключи в таблице, указанной в \* *фктабленаме* , ссылающейся на первичный ключ таблицы, указанный в **PKTableName*. В большинстве случаев это должен быть один ключ.  
  
> [!NOTE]  
>  Дополнительные сведения об общем использовании, аргументах и возвращаемых данных функций каталога ODBC см. в разделе [функции каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 **SQLForeignKeys** возвращает результаты в виде стандартного результирующего набора. При запросе внешних ключей, связанных с первичным ключом, результирующий набор упорядочивается по FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME и KEY_SEQ. Если требуются первичные ключи, связанные с внешним ключом, результирующий набор упорядочивается по PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME и KEY_SEQ. В следующей таблице перечислены столбцы результирующего набора.  
  
 Длины столбцов VARCHAR не показаны в таблице; Фактическая длина зависит от источника данных. Чтобы определить фактическую длину PKTABLE_CAT или FKTABLE_CAT, PKTABLE_SCHEM или FKTABLE_SCHEM, PKTABLE_NAME или FKTABLE_NAME, а также PKCOLUMN_NAME или FKCOLUMN_NAME столбцы, приложение может вызвать **SQLGetInfo** с параметрами SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN, SQL_MAX_TABLE_NAME_LEN и SQL_MAX_COLUMN_NAME_LEN.  
  
 Следующие столбцы были переименованы для ODBC 3 *. x.* Изменения имени столбца не влияют на обратную совместимость, так как приложения привязаны по номеру столбца.  
  
|Столбец ODBC 2,0|Столбец ODBC 3 *. x*|  
|---------------------|-----------------------|  
|PKTABLE_QUALIFIER|PKTABLE_CAT|  
|PKTABLE_OWNER|PKTABLE_SCHEM|  
|FKTABLE_QUALIFIER|FK_TABLE_CAT|  
|FKTABLE_OWNER|FKTABLE_SCHEM|  
  
 В следующей таблице перечислены столбцы результирующего набора. Дополнительные столбцы, которые выходят за пределы столбца 14 (remarks), могут быть определены драйвером. Приложение должно получить доступ к столбцам, относящимся к драйверу, выполнив подсчет с конца результирующего набора вместо того, чтобы задавать явную порядковую точку. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|PKTABLE_CAT (ODBC 1,0)|1|Varchar|Имя каталога таблицы первичного ключа; Значение NULL, если неприменимо к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, он возвращает пустую строку ("") для таблиц, не имеющих каталогов.|  
|PKTABLE_SCHEM (ODBC 1,0)|2|Varchar|Имя схемы таблицы первичного ключа; Значение NULL, если неприменимо к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|PKTABLE_NAME (ODBC 1,0)|3|Varchar, не РАВНый NULL|Имя таблицы первичного ключа.|  
|PKCOLUMN_NAME (ODBC 1,0)|4|Varchar, не РАВНый NULL|Имя первичного ключевого столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|FKTABLE_CAT (ODBC 1,0)|5|Varchar|Имя каталога таблиц внешнего ключа; Значение NULL, если неприменимо к источнику данных. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, он возвращает пустую строку ("") для таблиц, не имеющих каталогов.|  
|FKTABLE_SCHEM (ODBC 1,0)|6|Varchar|Имя схемы таблицы внешнего ключа; Значение NULL, если неприменимо к источнику данных. Если драйвер поддерживает схемы для некоторых таблиц, но не для других, например, когда драйвер извлекает данные из разных СУБД, он возвращает пустую строку ("") для тех таблиц, которые не имеют схем.|  
|FKTABLE_NAME (ODBC 1,0)|7|Varchar, не РАВНый NULL|Имя таблицы внешнего ключа.|  
|FKCOLUMN_NAME (ODBC 1,0)|8|Varchar, не РАВНый NULL|Имя внешнего ключевого столбца. Драйвер возвращает пустую строку для столбца, у которого нет имени.|  
|KEY_SEQ (ODBC 1,0)|9|Smallint, не NULL|Порядковый номер столбца в ключе (начиная с 1).|  
|UPDATE_RULE (ODBC 1,0)|10|Smallint|Действие, применяемое к внешнему ключу при **обновлении**операции SQL. Может иметь одно из следующих значений. (Таблица, на которую указывает ссылка, является таблицей с первичным ключом; ссылающаяся таблица — это таблица с внешним ключом.)<br /><br /> SQL_CASCADE: при обновлении первичного ключа связанной таблицы также обновляется внешний ключ ссылающейся таблицы.<br /><br /> SQL_NO_ACTION. Если обновление первичного ключа упоминаемой таблицы вызовет "висячий" ссылки в ссылочной таблице (то есть строки в ссылающейся таблице не будут иметь эквивалентов в упоминаемой таблице), обновление отклоняется. Если при обновлении внешнего ключа ссылающейся таблицы введено значение, которое не существует в качестве значения первичного ключа таблицы, на которую указывает ссылка, обновление отклоняется. (Это действие аналогично действию SQL_RESTRICT в ODBC 2 *. x*.)<br /><br /> SQL_SET_NULL. когда одна или несколько строк в упоминаемой таблице обновляются таким образом, что один или несколько компонентов первичного ключа изменяются, компоненты внешнего ключа в ссылающейся таблице, соответствующие измененным компонентам первичного ключа, устанавливаются в значение NULL во всех совпадающих строках ссылающейся таблицы.<br /><br /> SQL_SET_DEFAULT. когда одна или несколько строк в упоминаемой таблице обновляются таким образом, что один или несколько компонентов первичного ключа изменяются, компоненты внешнего ключа в ссылающейся таблице, соответствующие измененным компонентам первичного ключа, устанавливаются в соответствующие значения по умолчанию во всех совпадающих строках ссылающейся таблицы.<br /><br /> Значение NULL, если неприменимо к источнику данных.|  
|DELETE_RULE (ODBC 1,0)|11|Smallint|Действие, применяемое к внешнему ключу при **удалении**операции SQL. Может иметь одно из следующих значений. (Таблица, на которую указывает ссылка, является таблицей с первичным ключом; ссылающаяся таблица — это таблица с внешним ключом.)<br /><br /> SQL_CASCADE: при удалении строки в ссылочной таблице все совпадающие строки в ссылающихся таблицах также удаляются.<br /><br /> SQL_NO_ACTION. Если удаление строки в связанной таблице вызовет «висячие ссылки» в ссылающейся таблице (то есть строки в ссылающейся таблице не будут иметь эквивалентов в связанной таблице), обновление отклоняется. (Это действие аналогично действию SQL_RESTRICT в ODBC 2 *. x*.)<br /><br /> SQL_SET_NULL: при удалении одной или нескольких строк в таблице, на которую указывает ссылка, каждому компоненту внешнего ключа ссылающейся таблицы присваивается значение NULL во всех совпадающих строках ссылающейся таблицы.<br /><br /> SQL_SET_DEFAULT: при удалении одной или нескольких строк в таблице, на которую указывает ссылка, каждому компоненту внешнего ключа ссылающейся таблицы присваивается применимое значение по умолчанию во всех совпадающих строках ссылающейся таблицы.<br /><br /> Значение NULL, если неприменимо к источнику данных.|  
|FK_NAME (ODBC 2,0)|12|Varchar|Имя внешнего ключа. Значение NULL, если неприменимо к источнику данных.|  
|PK_NAME (ODBC 2,0)|13|Varchar|Имя первичного ключа. Значение NULL, если неприменимо к источнику данных.|  
|УКАЗАНО ОТСРОЧКИ (ODBC 3,0)|14|Smallint|SQL_INITIALLY_DEFERRED, SQL_INITIALLY_IMMEDIATE, SQL_NOT_DEFERRABLE.|  
  
## <a name="code-example"></a>Пример кода  
 Как показано в следующей таблице, в этом примере используются три таблицы, именованные заказы, строки и клиенты.  
  
|ЗАКАЗЫ|СТРОКИ|Заказчик|  
|------------|-----------|---------------|  
|ЗАКАЗА|ЗАКАЗА|CUSTID|  
|CUSTID|СТРОКИ|NAME|  
|опендате|PARTID|ADDRESS|  
|ПРОДАЖИ|СКЛАД|ТЕЛЕФОН|  
|Состояние|||  
  
 В таблице ORDERs CUSTID идентифицирует клиента, которому была выполнена продажа. Это внешний ключ, который ссылается на CUSTID в таблице CUSTOMERs.  
  
 В таблице строки ORDERID определяет заказ на продажу, с которым связан элемент строки. Это внешний ключ, который ссылается на ORDERID в таблице ORDERs.  
  
 В этом примере вызывается **SQLPrimaryKeys** для получения первичного ключа таблицы Orders. Результирующий набор будет содержать одну строку; значимые столбцы показаны в следующей таблице.  
  
|TABLE_NAME|COLUMN_NAME|KEY_SEQ|  
|-----------------|------------------|--------------|  
|ЗАКАЗЫ|ЗАКАЗА|1|  
  
 Далее в примере вызывается **SQLForeignKeys** для получения внешних ключей в других таблицах, ссылающихся на первичный ключ таблицы Orders. Результирующий набор будет содержать одну строку; значимые столбцы показаны в следующей таблице.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|ЗАКАЗЫ|CUSTID|СТРОКИ|CUSTID|1|  
  
 Наконец, в примере вызывается **SQLForeignKeys** для получения внешних ключей в таблице Orders, которые ссылаются на первичные ключи других таблиц. Результирующий набор будет содержать одну строку; значимые столбцы показаны в следующей таблице.  
  
|PKTABLE_NAME|PKCOLUMN_NAME|FKTABLE_NAME|FKCOLUMN_NAME|KEY_SEQ|  
|-------------------|--------------------|-------------------|--------------------|--------------|  
|Заказчик|CUSTID|ЗАКАЗЫ|CUSTID|1|  
  
```cpp  
#define TAB_LEN SQL_MAX_TABLE_NAME_LEN + 1  
#define COL_LEN SQL_MAX_COLUMN_NAME_LEN + 1  
  
LPSTR   szTable;              /* Table to display */  
  
UCHAR szPkTable[TAB_LEN];   /* Primary key table name */  
UCHAR szFkTable[TAB_LEN];   /* Foreign key table name */  
UCHAR szPkCol[COL_LEN];     /* Primary key column */  
UCHAR szFkCol[COL_LEN];     /* Foreign key column */  
  
SQLHSTMT      hstmt;  
SQLINTEGER    cbPkTable, cbPkCol, cbFkTable, cbFkCol, cbKeySeq;  
SQLSMALLINT   iKeySeq;  
SQLRETURN     retcode;  
  
// Bind the columns that describe the primary and foreign keys.  
// Ignore the table schema, name, and catalog for this example.  
  
SQLBindCol(hstmt, 3, SQL_C_CHAR, szPkTable, TAB_LEN, &cbPkTable);  
SQLBindCol(hstmt, 4, SQL_C_CHAR, szPkCol, COL_LEN, &cbPkCol);  
SQLBindCol(hstmt, 5, SQL_C_SSHORT, &iKeySeq, TAB_LEN, &cbKeySeq);  
SQLBindCol(hstmt, 7, SQL_C_CHAR, szFkTable, TAB_LEN, &cbFkTable);  
SQLBindCol(hstmt, 8, SQL_C_CHAR, szFkCol, COL_LEN, &cbFkCol);  
  
strcpy_s(szTable, sizeof(szTable), "ORDERS");  
  
/* Get the names of the columns in the primary key. */  
  
retcode = SQLPrimaryKeys(hstmt,  
         NULL, 0,             /* Catalog name */  
         NULL, 0,             /* Schema name */  
         szTable, SQL_NTS);   /* Table name */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL SUCCESS_WITH_INFO)) {  
  
   /* Fetch and display the result set. This will be a list of the */  
   /* columns in the primary key of the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "Table: %s Column: %s Key Seq: %hd \n", szPkTable, szPkCol,  
      iKeySeq);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys that refer to ORDERS primary key.*/   
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,            /* Primary catalog */  
         NULL, 0,            /* Primary schema */  
         szTable, SQL_NTS,   /* Primary table */  
         NULL, 0,            /* Foreign catalog */  
         NULL, 0,            /* Foreign schema */  
         NULL, 0);           /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* foreign keys in other tables that refer to the ORDERS */  
/* primary key. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s ) <-- %-s ( %-s )\n", szPkTable,  
               szPkCol, szFkTable, szFkCol);  
}  
  
/* Close the cursor (the hstmt is still allocated). */  
  
SQLFreeStmt(hstmt, SQL_CLOSE);  
  
/* Get all the foreign keys in the ORDERS table. */  
  
retcode = SQLForeignKeys(hstmt,  
         NULL, 0,             /* Primary catalog */  
         NULL, 0,             /* Primary schema */  
         NULL, 0,             /* Primary table */  
         NULL, 0,             /* Foreign catalog */  
         NULL, 0,             /* Foreign schema */  
         szTable, SQL_NTS);   /* Foreign table */  
  
while ((retcode == SQL_SUCCESS) || (retcode == SQL_SUCCESS_WITH_INFO)) {  
  
/* Fetch and display the result set. This will be all of the */  
/* primary keys in other tables that are referred to by foreign */  
/* keys in the ORDERS table. */  
  
   retcode = SQLFetch(hstmt);  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
      fprintf(out, "%-s ( %-s )--> %-s ( %-s )\n", szFkTable, szFkCol, szPkTable, szPkCol);  
}  
  
/* Free the hstmt. */  
SQLFreeStmt(hstmt, SQL_DROP);  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выборка одной строки или блока данных в прямом направлении|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение столбцов первичного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
|Возврат статистики и индексов таблицы|[Функция SQLStatistics](../../../odbc/reference/syntax/sqlstatistics-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
