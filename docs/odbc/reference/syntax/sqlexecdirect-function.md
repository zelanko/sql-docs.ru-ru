---
title: Функция SQLExecDirect | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExecDirect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecDirect
helpviewer_keywords:
- SQLExecDirect function [ODBC]
ms.assetid: 985fcee1-f204-425c-bdd1-deb0e7d7bbd9
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 5739e397467deb684a4cd6c7b13a507f30b53fa7
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81286114"
---
# <a name="sqlexecdirect-function"></a>Функция SQLExecDirect
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 1,0: ISO 92  
  
 **Сводка**  
 **SQLExecDirect** выполняет инструкцию доступный, используя текущие значения переменных маркера параметра, если в инструкции существуют какие-либо параметры. **SQLExecDirect** — это самый быстрый способ отправить инструкцию SQL для однократного выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExecDirect(  
     SQLHSTMT     StatementHandle,  
     SQLCHAR *    StatementText,  
     SQLINTEGER   TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *статементтекст*  
 Входной Инструкция SQL для выполнения.  
  
 *TextLength*  
 Входной Длина **статементтекст* в символах.  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, SQL_NO_DATA, SQL_INVALID_HANDLE или SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLExecDirect** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *параметром handletype* SQL_HANDLE_STMT и *маркером* *статеменсандле*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLExecDirect** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01001|Конфликт операций с курсором|\**Статементтекст* содержал инструкцию позиционированного обновления или удаления, и ни одна строка, ни несколько строк не были обновлены или удалены. (Дополнительные сведения об обновлениях более чем в одной строке см. в описании *атрибута* SQL_ATTR_SIMULATE_CURSOR в **SQLSetStmtAttr**.)<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01003|Значение NULL исключено в функции Set|Аргумент *статементтекст* содержал функцию набора (например, **AVG**, **Max**, **min**и т. д.), но не функцию набора **Count** , а значения аргументов null были исключены до применения функции. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Строковые или двоичные данные, возвращаемые для входного/выходного или выходного параметра, привели к усечению непустого символа или двоичных данных, отличных от NULL. Если это строковое значение, оно было усечено по правому краю. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01006|Привилегия не отменена|\**Статементтекст* содержит инструкцию **REVOKE** , и пользователь не имеет указанных прав. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01007|Привилегия не предоставлена|Статементтекст является инструкцией **Grant** , и пользователю не удалось предоставить указанные права доступа. * \**|  
|01S02|Значение параметра изменено|Указанный атрибут инструкции был недопустимым из-за рабочих условий реализации, поэтому было временно заменено аналогичное значение. (**SQLGetStmtAttr** можно вызвать, чтобы определить, что такое временно заменяющий параметр.) Заменяющее значение допустимо для *статеменсандле* до тех пор, пока курсор не будет закрыт, после чего атрибут инструкции вернется к предыдущему значению. Атрибуты инструкции, которые могут быть изменены:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Усечение дробной части|Данные, возвращаемые для входного или выходного или выходного параметра, были усечены таким, что дробная часть числового типа данных была усечена, или дробная часть временного компонента времени, отметки времени или типа данных интервала была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07002|Неверное поле количества|Число параметров, указанных в **SQLBindParameter** , меньше числа параметров в инструкции SQL, содержащейся в \* *статементтекст*.<br /><br /> **SQLBindParameter** был вызван с *параметервалуептр* , для которого задан пустой указатель, *StrLen_or_IndPtr* не задано значение SQL_NULL_DATA или SQL_DATA_AT_EXEC, а *инпутаутпуттипе* не задано значение SQL_PARAM_OUTPUT, чтобы число параметров, указанное в **SQLBindParameter** , было больше числа параметров в инструкции SQL, содержащейся в **статементтекст*.|  
|07006|Нарушение атрибута ограниченного типа данных|Значение данных, определяемое аргументом *ValueType* в **SQLBindParameter** для привязанного параметра, не может быть преобразовано в тип данных, определяемый аргументом *ParameterType* в **SQLBindParameter**.<br /><br /> Значение данных, возвращаемое для параметра, привязанного как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, не может быть преобразовано в тип данных, определяемый аргументом *ValueType* в **SQLBindParameter**.<br /><br /> (Если не удалось преобразовать значения данных для одной или нескольких строк, но одна или несколько строк были успешно возвращены, эта функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07007|Нарушение значения ограниченного параметра|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные в частях. Для этого типа параметра не допускается использование присоединенного буфера ввода.<br /><br /> Эта ошибка возникает, если тип параметра — SQL_PARAM_INPUT_OUTPUT, а \* *StrLen_or_IndPtr* , указанный в **SQLBindParameter** , не равен SQL_NULL_DATA, SQL_DEFAULT_PARAM, SQL_LEN_DATA_AT_EXEC (len) или SQL_DATA_AT_EXEC.|  
|07S01|Недопустимое использование параметра по умолчанию|Значение параметра, заданное с помощью **SQLBindParameter**, было SQL_DEFAULT_PARAM, а соответствующий параметр не имел значения по умолчанию.|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**Статементтекст* содержит инструкцию **INSERT** , а число вставляемых значений не соответствует степени производной таблицы.|  
|21S02|Степень производной таблицы не соответствует списку столбцов|\**Статементтекст* содержал инструкцию **Create View** , а неквалифицированный список столбцов (число столбцов, указанных для представления в аргументах *идентификатора столбца* в инструкции SQL) содержит больше имен, чем число столбцов в производной таблице, ОПРЕДЕЛЕННОЕ аргументом *спецификации запроса* инструкции SQL.|  
|22001|Строковые данные, усечение справа|Присвоение символьного или двоичного значения столбцу привело к усечению непустых символьных данных или двоичных данных, отличных от NULL.|  
|22002|Требуемая, но не определенная переменная индикатора|Данные NULL были привязаны к выходному параметру, *StrLen_or_IndPtr* , установленный **SQLBindParameter** , был пустым указателем.|  
|22003|Числовое значение вне допустимого диапазона|**Статементтекст* содержал инструкцию SQL, содержащую привязанный числовой параметр или литерал, и значение, которое привело к усечению всего (в отличие от дробного) части числа, которая будет обрезана при присваивании соответствующему столбцу таблицы.<br /><br /> Возврат числового значения (в виде числового или строкового) для одного или нескольких входных, выходных или выходных параметров приведет к усечению всего числа (в отличие от дробной части).|  
|22007|Недопустимый формат даты и времени|**Статементтекст* содержал инструкцию SQL, содержащую структуру даты, времени или метки времени как привязанный параметр, а параметр — соответственно, недопустимая дата, время или метка времени.<br /><br /> Входной/выходной или выходной параметр привязан к структуре даты, времени или метки времени C, а значение в возвращенном параметре было соответственно недействительной дате, времени или метке времени. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22008|Переполнение поля даты и времени|**Статементтекст* содержал инструкцию SQL, содержащую выражение DateTime, которое при вычислении привело к недопустимой структуре даты, времени или метки времени.<br /><br /> Выражение DateTime, вычисленное для входного/выходного или выходного параметра, привело к недопустимой структуре даты, времени или метки времени C.|  
|22012|Деление на ноль|**Статементтекст* содержит инструкцию SQL, содержащую арифметическое выражение, которое вызывало деление на ноль.<br /><br /> Арифметическое выражение, вычисленное для входного/выходного или выходного параметра, привело к делению на нуль.|  
|22015|Переполнение поля интервала|Статементтекст содержал точный числовой параметр или интервал, который при преобразовании в тип данных SQL Interval привел к утрате значащих цифр. * \**<br /><br /> Статементтекст содержал параметр интервала с более чем одним полем, которое при преобразовании в числовой тип данных столбца не имело представления числового типа данных. * \**<br /><br /> Статементтекст содержал данные параметров, которые были назначены типу SQL Interval, и в типе SQL Interval не было представления значения типа C. * \**<br /><br /> Назначение входного, выходного или выходного параметра, который был точным числовым или интервалом типа SQL, к типу Interval C привел к утрате значащих цифр.<br /><br /> Если входной/выходной или выходной параметр был назначен структуре интервала C, в структуре данных интервала отсутствовало представления данных.|  
|22018|Недопустимое символьное значение для спецификации приведения|Статементтекст содержит тип C, который был точным или приблизительным числовым, типом данных DateTime или интервалом. * \** тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.<br /><br /> При возвращении входного/выходного или выходного параметра тип SQL был точным или приблизительным числовым значением типа DateTime или типом данных интервала; Тип C — SQL_C_CHAR; и значение в столбце не было допустимым литералом привязанного типа SQL.|  
|22019|Недопустимый escape-символ|\**Статементтекст* содержит инструкцию SQL, содержащую предикат **Like** с **escape** -символом в предложении **WHERE** , а длина escape-символа, следующего за **escape** -выражением, не равна 1.|  
|22025|Недопустимая escape-последовательность|\**Статементтекст* содержал инструкцию SQL, которая содержит **«Like** **escape-** _символ_- _шаблон_ » в предложении **WHERE** , а символ, следующий за escape-символом в значении шаблона, был не одним из следующих: «%» или «_».|  
|23000|Нарушение ограничения целостности|**Статементтекст* содержит инструкцию SQL, содержащую параметр или литерал. Значение параметра имело значение NULL для столбца, определенного как NOT NULL в связанном столбце таблицы, было указано повторяющееся значение для столбца, ограничение которого должно содержать только уникальные значения, или нарушено какое-либо другое ограничение целостности.|  
|24 000|Недопустимое состояние курсора|Курсор был помещен в *статеменсандле* by **SQLFetch** или **SQLFetchScroll**. Эта ошибка возвращается диспетчером драйверов, если **SQLFetch** или **SQLFetchScroll** не вернул SQL_NO_DATA, и возвращается драйвером, если **SQLFetch** или **SQLFetchScroll** вернул SQL_NO_DATA.<br /><br /> Курсор был открыт, но не позиционирован на *статеменсандле*.<br /><br /> **Статементтекст* содержал инструкцию позиционированного обновления или удаления, и курсор был помещен перед началом результирующего набора или после конца результирующего набора.|  
|34000|Недопустимое имя курсора|**Статементтекст* содержал инструкцию позиционированного обновления или удаления, а курсор, на который ссылается выполняемая инструкция, не был открыт.|  
|3D000|Недопустимое имя каталога|В *статементтекст* указано недопустимое имя каталога.|  
|3F000|Недопустимое имя схемы|В *статементтекст* указано недопустимое имя схемы.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40003|Неизвестное завершение инструкции|Не удалось выполнить связанное соединение во время выполнения этой функции, и состояние транзакции не может быть определено.|  
|42000|Синтаксическая ошибка или нарушение прав доступа|\**Статементтекст* содержал инструкцию SQL, которая не была доступныйа, или не содержала синтаксическую ошибку.<br /><br /> У пользователя нет разрешения на выполнение инструкции SQL, содержащейся в **статементтекст*.|  
|42S01|Базовая таблица или представление уже существует|\**Статементтекст* содержит инструкцию **CREATE TABLE** или **Create View** , а указанное имя таблицы или представления уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**Статементтекст* содержит инструкцию **DROP TABLE** или **DROP VIEW** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **ALTER TABLE** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержал инструкцию **Create View** , а имя таблицы или представления, определенное спецификацией запроса, не существовало.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE INDEX** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержит инструкцию **Grant** или **REVOKE** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **SELECT** , а указанное имя таблицы или представления не существует.<br /><br /> \**Статементтекст* содержит инструкцию **Delete**, **INSERT**или **Update** , а указанное имя таблицы не существует.<br /><br /> \**Статементтекст* содержит оператор **CREATE TABLE** , а таблица, указанная в ограничении (ссылающаяся на таблицу, отличную от создаваемой), не существует.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE SCHEMA** , а указанное имя таблицы или представления не существует.|  
|42S11|Индекс уже существует|\**Статементтекст* содержит инструкцию **CREATE INDEX** , а указанное имя индекса уже существует.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE SCHEMA** , а указанное имя индекса уже существует.|  
|42S12|Индекс не найден|\**Статементтекст* содержит инструкцию **DROP INDEX** , а указанное имя индекса не существует.|  
|42S21|Столбец уже существует|\**Статементтекст* содержит инструкцию **ALTER TABLE** , а столбец, указанный в предложении **Add** , не уникален или определяет существующий столбец в базовой таблице.|  
|42S22|Столбец не найден|\**Статементтекст* содержит инструкцию **CREATE INDEX** , а одно или несколько имен столбцов, указанных в списке столбцов, не существуют.<br /><br /> \**Статементтекст* содержит инструкцию **Grant** или **REVOKE** , и указанное имя столбца не существует.<br /><br /> \**Статементтекст* содержит инструкцию **SELECT**, **Delete**, **INSERT**или **Update** , а указанное имя столбца не существует.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE TABLE** , а столбец, указанный в ограничении (ссылающийся на таблицу, отличную от создаваемой), не существует.<br /><br /> \**Статементтекст* содержит инструкцию **CREATE SCHEMA** , а указанное имя столбца не существует.|  
|44000|Нарушение параметра WITH CHECK OPTION|Аргумент *статементтекст* содержал инструкцию **INSERT** , выполненную в просматриваемой таблице, или таблицу, производную от просматриваемой таблицы, созданной с помощью **параметра WITH CHECK**, что одна или несколько строк, затронутых инструкцией **INSERT** , больше не будут присутствовать в просматриваемой таблице.<br /><br /> Аргумент *статементтекст* содержал инструкцию **Update** , выполненную в просматриваемой таблице, или таблицу, производную от просматриваемой таблицы, созданной с помощью **параметра WITH CHECK**, что одна или несколько строк, затронутых инструкцией **Update** , больше не будут присутствовать в просматриваемой таблице.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере * \*MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана, и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *статеменсандле*. Затем функция была вызвана в *статеменсандле*.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) **статементтекст* был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLExecDirect** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* был меньше или равен 0, но не равен SQL_NTS.<br /><br /> Значение параметра, заданное с помощью **SQLBindParameter**, является пустым указателем, а значение длины параметра не равно 0, SQL_NULL_DATA, SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение параметра, заданное с помощью **SQLBindParameter**, не является пустым указателем; тип данных C — SQL_C_BINARY или SQL_C_CHAR; и значение длины параметра было меньше 0, но не было SQL_NTS, SQL_NULL_DATA, SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение длины параметра, связанное с **SQLBindParameter** , было установлено в SQL_DATA_AT_EXEC; тип SQL был либо SQL_LONGVARCHAR, SQL_LONGVARBINARY, либо типом данных типа Long, относящимся к источнику данных. а тип сведений SQL_NEED_LONG_DATA_LEN в **SQLGetInfo** — «Y».|  
|HY105|Недопустимый тип параметра|Значение, указанное для аргумента *инпутаутпуттипе* в **SQLBindParameter** , было SQL_PARAM_OUTPUT, а параметр является входным параметром.|  
|HY109|Недопустимое расположение курсора|\**Статементтекст* содержал инструкцию позиционированного обновления или удаления, и курсор был размещен (по **SQLSetPos** или **SQLFetchScroll**) в строке, которая была удалена или не может быть получена.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Сочетание текущих параметров атрибутов SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживалось драйвером или источником данных.<br /><br /> Атрибуту инструкции SQL_ATTR_USE_BOOKMARKS было присвоено значение SQL_UB_VARIABLE, а атрибуту инструкции SQL_ATTR_CURSOR_TYPE задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLExecDirect** для отправки инструкции SQL в источник данных. Дополнительные сведения о прямом выполнении см. в разделе [прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md). Драйвер изменяет инструкцию для использования формы SQL, используемой источником данных, а затем отправляет ее в источник данных. В частности, драйвер изменяет escape-последовательности, используемые для определения определенных функций в SQL. Синтаксис escape-последовательностей см. [в разделе Escape-последовательности в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).  
  
 Приложение может включать один или несколько маркеров параметров в инструкцию SQL. Чтобы включить маркер параметра, приложение внедряет вопросительный знак (?) в инструкцию SQL в соответствующей позиции. Дополнительные сведения о параметрах см. в разделе [Параметры инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
 Если инструкция SQL является инструкцией **SELECT** и если приложение с именем **SQLSetCursorName** связывает курсор с инструкцией, то драйвер использует указанный курсор. В противном случае драйвер создает имя курсора.  
  
 Если источник данных находится в режиме фиксации вручную (требует явной инициации транзакции) и транзакция еще не запущена, драйвер инициирует транзакцию перед отправкой инструкции SQL. Дополнительные сведения см. в разделе [режим фиксации вручную](../../../odbc/reference/develop-app/manual-commit-mode.md).  
  
 Если приложение использует **SQLExecDirect** для отправки инструкций **commit** или **ROLLBACK** , оно не будет взаимодействовать между продуктами СУБД. Для фиксации или отката транзакции приложение вызывает **SQLEndTran**.  
  
 Если **SQLExecDirect** встречает параметр данных при выполнении, он возвращает SQL_NEED_DATA. Приложение отправляет данные с помощью **метод SQLParamData** и **SQLPutData**. См. раздел [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [метод SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)и [Отправка длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **SQLExecDirect** выполняет инструкцию обновления, вставки или удаления, которая не влияет ни на какие строки в источнике данных, вызов **SQLExecDirect** возвращает SQL_NO_DATA.  
  
 Если значение атрибута SQL_ATTR_PARAMSET_SIZE оператора больше 1, а инструкция SQL содержит хотя бы один маркер параметра, **SQLExecDirect** будет выполнять инструкцию SQL один раз для каждого набора значений параметров из массивов, на которые указывает аргумент *параметервалуепоинтер* в вызове **SQLBindParameter**. Дополнительные сведения см. в разделе [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 Если закладки включены и выполняется запрос, который не поддерживает закладки, драйвер должен попытаться привести среду к той, которая поддерживает закладки, изменив значение атрибута и возвращая SQLSTATE 01S02 (значение параметра изменено). Если атрибут не может быть изменен, драйвер должен возвращать значение SQLSTATE HY024 (недопустимое значения атрибута).  
  
> [!NOTE]  
>  При использовании пулов соединений приложение не должно выполнять инструкции SQL, которые изменяют базу данных или контекст базы данных, например инструкцию **use** _Database_ в SQL Server, которая изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 См. раздел [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)и [Пример программы ODBC](../../../odbc/reference/sample-odbc-program.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутка результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращение имени курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Выборка части или всего столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возврат следующего параметра для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка инструкции к выполнению|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметров во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Задание имени курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|Задание атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
