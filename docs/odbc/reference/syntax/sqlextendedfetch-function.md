---
title: Функция SQLExtendedFetch | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLExtendedFetch
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLExtendedFetch
helpviewer_keywords:
- SQLExtendedFetch function [ODBC]
ms.assetid: 940b5cf7-581c-4ede-8533-c67d5e9ef488
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 12c64be42c921a4dff57ccca6278e1f84bd717ef
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2020
ms.locfileid: "68345208"
---
# <a name="sqlextendedfetch-function"></a>Функция SQLExtendedFetch
**Соответствия**  
 Введенная версия: соответствие стандартам ODBC 1,0: не рекомендуется  
  
 **Сводка**  
 **SQLExtendedFetch** извлекает указанный набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов. Наборы строк могут быть заданы на абсолютном или относительном месте или по закладке.  
  
> [!NOTE]
>  В ODBC 3 *. x* **SQLExtendedFetch** был заменен на **SQLFetchScroll**. Приложения ODBC 3 *. x* не должны вызывать **SQLExtendedFetch**; Вместо этого они должны вызывать **SQLFetchScroll**. Диспетчер драйверов сопоставляет **SQLFetchScroll** с **SQLExtendedFetch** при работе с драйвером ODBC 2 *. x* . Драйверы ODBC 3 *. x* должны поддерживать **SQLExtendedFetch** , если они хотят работать с приложениями ODBC 2 *. x* , которые его вызывают. Дополнительные сведения см. в разделе "Комментарии" и " [блочные курсоры", "прокручиваемые курсоры" и "Обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) " в приложении G: рекомендации по драйверу для обеспечения обратной совместимости.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLExtendedFetch(  
      SQLHSTMT         StatementHandle,  
      SQLUSMALLINT     FetchOrientation,  
      SQLLEN           FetchOffset,  
      SQLULEN *        RowCountPtr,  
      SQLUSMALLINT *   RowStatusArray);  
```  
  
## <a name="arguments"></a>Аргументы  
 *статеменсандле*  
 Входной Маркер инструкции.  
  
 *фетчориентатион*  
 Входной Тип выборки. Это то же самое, что и *фетчориентатион* в **SQLFetchScroll**.  
  
 *фетчоффсет*  
 Входной Номер извлекаемой строки. Это то же самое, что и *фетчоффсет* в **SQLFetchScroll**, за одним исключением. Если *фетчориентатион* имеет SQL_FETCH_BOOKMARK, *фетчоффсет* является закладкой фиксированной длины, а не смещением от закладки. Иными словами, **SQLExtendedFetch** извлекает закладку из этого аргумента, а не атрибута SQL_ATTR_FETCH_BOOKMARK_PTR оператора. Он не поддерживает закладки с переменной длиной и не поддерживает выборку набора строк в смещении (отличном от 0) из закладки.  
  
 *RowCountPtr*  
 Проверки Указатель на буфер, в котором возвращается число фактически выбранных строк. Этот буфер используется так же, как буфер, заданный атрибутом SQL_ATTR_ROWS_FETCHED_PTR оператора. Этот буфер используется только **SQLExtendedFetch**. Он не используется **SQLFetch** или **SQLFetchScroll**.  
  
 *ровстатусаррай*  
 Проверки Указатель на массив, в котором возвращается состояние каждой строки. Этот массив используется так же, как массив, заданный атрибутом SQL_ATTR_ROW_STATUS_PTR оператора.  
  
 Однако адрес этого массива не хранится в поле SQL_DESC_STATUS_ARRAY_PTR в IRD. Кроме того, этот массив используется только **SQLExtendedFetch** и **SQLBulkOperations** с *операцией* SQL_ADD или **SQLSetPos** , когда он вызывается после **SQLExtendedFetch**. Он не используется **SQLFetch** или **SQLFetchScroll**и не используется **SQLBulkOperations** или **SQLSetPos** , если они вызываются после **SQLFetch** или **SQLFetchScroll**. Он также не используется, если **SQLBulkOperations** с *операцией* SQL_ADD вызывается до вызова любой функции fetch. Иными словами, он используется только в состоянии инструкции S7. Он не используется в инструкциях состояния S5 или S6. Дополнительные сведения см. в разделе [переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md) в приложении б: таблицы переходов состояния ODBC.  
  
 Приложения должны предоставить допустимый указатель в аргументе *ровстатусаррай* ; в противном случае поведение **SQLExtendedFetch** и поведение вызовов **SQLBulkOperations** или **SQLSetPos** после того, как курсор был помещен в **SQLExtendedFetch** , не определены.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLExtendedFetch** возвращает либо SQL_ERROR, либо SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SqlError**. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLExtendedFetch** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное. Если в одном столбце возникает ошибка, **SQLGetDiagField** можно вызвать с *диагидентифиер* из SQL_DIAG_COLUMN_NUMBER, чтобы определить столбец, в котором произошла ошибка. и **SQLGetDiagField** можно вызывать с *диагидентифиер* SQL_DIAG_ROW_NUMBER для определения строки, содержащей этот столбец.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01004|Строковые данные, усеченные справа|Строковые или двоичные данные, возвращаемые для столбца, привели к усечению непустого символа или двоичных данных, отличных от NULL. Если это строковое значение, оно было усечено по правому краю. Если это числовое значение, дробная часть числа усекается.  (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S01|Ошибка в строке|Произошла ошибка при выборке одной или нескольких строк. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S06|Попытка выборки до того, как результирующий набор вернул первый набор строк|Запрошенный набор строк перекрывает начало результирующего набора, когда текущая строка находилась за пределами первой строки, и либо *фетчориентатион* был SQL_PRIOR или *фетчориентатион* был SQL_RELATIVE с отрицательным *фетчоффсет* , абсолютное значение которого меньше или равно текущему SQL_ROWSET_SIZE. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|01S07|Усечение дробной части|Данные, возвращаемые для столбца, были усечены. Для числовых типов данных дробная часть числа была усечена. Для типов данных времени, временных меток и интервалов, содержащих компонент времени, дробная часть времени была усечена.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|07006|Нарушение атрибута ограниченного типа данных|Не удалось преобразовать значение данных в тип данных C, указанный в *TargetType* в **SQLBindCol**.|  
|07009|Недопустимый индекс дескриптора|Столбец 0 был привязан к **SQLBindCol**, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_OFF.|  
|08S01|Сбой канала связи|Канал связи между драйвером и источником данных, к которому был подключен драйвер, был неудачен до завершения обработки функции.|  
|22002|Требуемая, но не определенная переменная индикатора|Данные NULL были получены в столбец, *StrLen_or_IndPtr* , установленный параметром **SQLBindCol** , был пустым указателем.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22003|Числовое значение вне допустимого диапазона|Возврат числового значения (в виде числового или строкового) для одного или нескольких столбцов привело бы к усечению всего числа (в отличие от дробной части).<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)<br /><br /> Дополнительные сведения см. в разделе [рекомендации по типам данных Interval и numeric](../../../odbc/reference/appendixes/guidelines-for-interval-and-numeric-data-types.md) в приложении г: типы данных.|  
|22007|Недопустимый формат даты и времени|Символьный столбец в результирующем наборе был привязан к структуре даты, времени или метки времени C, а значение в столбце является, соответственно, недействительной датой, временем или меткой времени.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22012|Деление на ноль|Возвращено значение из арифметического выражения, результатом которого является деление на ноль.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22015|Переполнение поля интервала|Назначение типа SQL с точным числовым или интервалом до типа Interval C привело к утере значащих цифр в начальном поле.<br /><br /> При выборке данных в тип C Interval не было представления значения типа SQL в типе Interval C.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|22018|Недопустимое символьное значение для спецификации приведения|Тип C был точным или приблизительным числовым, типом данных DateTime или интервалом. тип SQL столбца имеет символьный тип данных; и значение в столбце не было допустимым литералом привязанного типа C.<br /><br /> (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|24 000|Недопустимое состояние курсора|*Статеменсандле* был в выполненном состоянии, но с *статеменсандле*не связан ни один результирующий набор.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SqlError** в буфере * \*MessageText* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *статеменсандле*. Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** для *Статеменсандле*, а затем в *статеменсандле*был вызвана функция.<br /><br /> Функция была вызвана и до ее завершения была вызвана **SQLCancel** или **склканцелхандле** в *статеменсандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызвана асинхронно исполняемая функция для маркера соединения, связанного с *статеменсандле*. Эта асинхронная функция все еще выполнялась при вызове функции **SQLExtendedFetch** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для *статеменсандле* и возвращены SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.<br /><br /> (DM) указанный *статеменсандле* не находится в выполненном состоянии. Функция была вызвана без предварительного вызова **SQLExecDirect**, **SQLExecute**или функции каталога.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *статеменсандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для *статеменсандле* и возвращены SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) **SQLExtendedFetch** был вызван для *Статеменсандле* после вызова **SQLFetch** или **SQLFetchScroll** и до вызова **SQLFreeStmt** с параметром SQL_CLOSE.<br /><br /> (DM) **SQLBulkOperations** был вызван для инструкции до вызова **SQLFetch**, **SQLFetchScroll**или **SQLExtendedFetch** , а затем **SQLExtendedFetch** вызывался до вызова **SQLFreeStmt** с параметром SQL_CLOSE.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY106|Тип выборки вне допустимого диапазона|(DM) значение, указанное для аргумента *фетчориентатион* , недопустимо. (См. раздел "Комментарии".)<br /><br /> Аргумент *фетчориентатион* был SQL_FETCH_BOOKMARK, а атрибуту инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_OFF.<br /><br /> Значение параметра инструкции SQL_CURSOR_TYPE было SQL_CURSOR_FORWARD_ONLY, а значение аргумента *фетчориентатион* не SQL_FETCH_NEXT.<br /><br /> Аргумент *фетчориентатион* был SQL_FETCH_RESUME.|  
|HY107|Значение строки вне допустимого диапазона|Значение, указанное в параметре инструкции SQL_CURSOR_TYPE, было SQL_CURSOR_KEYSET_DRIVENо, но значение, указанное в атрибуте инструкции SQL_KEYSET_SIZE, было больше 0 и меньше значения, указанного в атрибуте инструкции SQL_ROWSET_SIZE .|  
|HY111|Недопустимое значение закладки|Аргумент *фетчориентатион* был SQL_FETCH_BOOKMARK, а закладка, указанная в аргументе *фетчоффсет* , недопустима.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает указанный тип выборки.<br /><br /> Драйвер или источник данных не поддерживает преобразование, заданное сочетанием *TargetType* в **SQLBindCol** и типом данных SQL соответствующего столбца. Эта ошибка применяется только в том случае, если тип данных SQL столбца был сопоставлен с типом данных SQL конкретного драйвера.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло до того, как источник данных вернул результирующий набор. Период ожидания задается через **SQLSetStmtOption**, SQL_QUERY_TIMEOUT.|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *статеменсандле* , не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Поведение **SQLExtendedFetch** идентично поведению **SQLFetchScroll**, за исключением следующих:  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** используют различные методы для возврата количества извлекаемых строк. **SQLExtendedFetch** возвращает количество строк, извлекаемых в * \*RowCountPtr*; **SQLFetchScroll** возвращает количество строк, извлекаемых непосредственно в буфер, на который указывает SQL_ATTR_ROWS_FETCHED_PTR. Дополнительные сведения см. в описании аргумента *RowCountPtr* .  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** возвращают состояние каждой строки в разных массивах. Дополнительные сведения см. в описании аргумента *ровстатусаррай* .  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** используют различные методы для получения закладки, когда *фетчориентатион* SQL_FETCH_BOOKMARK. **SQLExtendedFetch** не поддерживает закладки с переменной длиной или выбирали наборы строк с смещением, отличным от 0, из закладки. Дополнительные сведения см. в описании аргумента *фетчоффсет* .  
  
-   **SQLExtendedFetch** и **SQLFetchScroll** используют разные размеры наборов строк. **SQLExtendedFetch** использует значение атрибута оператора SQL_ROWSET_SIZE, а **SQLFetchScroll** использует значение атрибута инструкции SQL_ATTR_ROW_ARRAY_SIZE.  
  
-   **SQLExtendedFetch** имеет слегка отличающуюся семантику обработки ошибок, чем **SQLFetchScroll**. Дополнительные сведения см. в разделе "обработка ошибок" раздела "Комментарии" статьи [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
-   **SQLExtendedFetch** не поддерживает смещения привязки (атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR).  
  
-   Вызовы **SQLExtendedFetch** не могут смешиваться с вызовами **SQLFetch** или **SQLFetchScroll**, и если **SQLBulkOperations** вызывается до вызова любой функции FETCH, **SQLExtendedFetch** нельзя вызвать до тех пор, пока курсор не будет закрыт и открыт повторно. Это значит, что **SQLExtendedFetch** можно вызвать только в инструкции State S7. Дополнительные сведения см. в разделе [переходы инструкций](../../../odbc/reference/appendixes/statement-transitions.md) в приложении б: таблицы переходов состояния ODBC.  
  
 Когда приложение вызывает **SQLFetchScroll** при использовании драйвера ODBC 2 *. x* , диспетчер драйверов сопоставляет этот вызов с **SQLExtendedFetch**. Дополнительные сведения см. в разделе "драйверы SQLFetchScroll и ODBC 2 *. x* " в [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md).  
  
 В ODBC 2 *. x* **SQLExtendedFetch** был вызван для выборки нескольких строк, а **SQLFetch** был вызван для выборки одной строки. В ODBC 3 *. x*, с другой стороны, **SQLFetch** можно вызывать для выборки нескольких строк.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Тема|См. следующие документы.|  
|---------------------------|---------|  
|Привязка буфера к столбцу в результирующем наборе|[SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение операций с массовыми операциями вставки, обновления и удаления|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующем наборе|[SQLDescribeCol, функция](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Исполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Исполнение подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращение количества столбцов результирующего набора|[SQLNumResultCols, функция](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Размещение курсора, обновление данных в наборе строк, обновление или удаление данных в результирующем наборе|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|Задание атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
