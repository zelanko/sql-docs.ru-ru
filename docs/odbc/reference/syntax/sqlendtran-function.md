---
title: Функция SQLEndTran | Документация Майкрософт
ms.custom: ''
ms.date: 07/18/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLEndTran
apilocation:
- sqlsrv32.dll
- odbc32.dll
apitype: dllExport
f1_keywords:
- SQLEndTran
helpviewer_keywords:
- SQLEndTran function [ODBC]
ms.assetid: ff375ce1-eb50-4693-b1e6-70181a6dbf9f
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: cce7792e52fce4984f3da41e11d79c34b6b79e53
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/27/2020
ms.locfileid: "81302745"
---
# <a name="sqlendtran-function"></a>Функция SQLEndTran
**Соответствия**  
 Представленная версия: соответствие стандартам ODBC 3,0: ISO 92  
  
 **Сводка**  
 **SQLEndTran** запрашивает операцию фиксации или отката для всех активных операций во всех инструкциях, связанных с соединением. **SQLEndTran** также может запросить выполнение операции фиксации или отката для всех подключений, связанных с средой.  
  
> [!NOTE]  
>  Дополнительные сведения о том, что диспетчер драйверов сопоставляет эту функцию при использовании ODBC 3. Приложение *x* работает с ODBC 2. драйвер *x* см. в разделе [Сопоставление функций замены для обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
  
SQLRETURN SQLEndTran(  
     SQLSMALLINT   HandleType,  
     SQLHANDLE     Handle,  
     SQLSMALLINT   CompletionType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 Входной Идентификатор типа обработчика. Содержит либо SQL_HANDLE_ENV (если *Handle* является обработчиком среды), либо SQL_HANDLE_DBC (если *Handle* является маркером соединения).  
  
 *Дескриптор*  
 Входной Маркер типа, указанного параметром *параметром handletype*, который указывает область транзакции. Дополнительные сведения см. в разделе "Комментарии".  
  
 *комплетионтипе*  
 Входной Одно из следующих двух значений:  
  
 SQL_COMMIT SQL_ROLLBACK  
  
## <a name="returns"></a>Результаты  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Если **SQLEndTran** возвращает SQL_ERROR или SQL_SUCCESS_WITH_INFO, связанное значение SQLSTATE может быть получено путем вызова **SQLGetDiagRec** с соответствующим *параметром handletype* и *Handle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые функцией **SQLEndTran** , и объясняется каждый из них в контексте этой функции. Нотация "(DM)" предшествует описаниям SQLSTATE, возвращаемым диспетчером драйверов. Код возврата, связанный с каждым значением SQLSTATE, имеет SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Error|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение для конкретного драйвера. (Функция возвращает SQL_SUCCESS_WITH_INFO.)|  
|08003|Соединение не открыто|(DM) *параметром handletype* был SQL_HANDLE_DBC, а *обработчик* не находится в подключенном состоянии.|  
|08007|Сбой подключения во время транзакции|*Параметром handletype* был SQL_HANDLE_DBC, и соединение, связанное с этим *маркером* , завершилось сбоем во время выполнения функции, и не может быть определено, была ли запрошенная **фиксация** или **откат** выполнена до сбоя.|  
|25S01|Неизвестное состояние транзакции|Одно или несколько соединений в *обработчике* не удалось завершить транзакцию с указанным выходом, и результат неизвестен.|  
|25S02|Транзакция все еще активна|Драйвер не смог гарантировать, что вся работа в глобальной транзакции могла быть выполнена атомарно, а транзакция все еще активна.|  
|25S03|Выполняется откат транзакции|Драйвер не смог гарантировать, что вся работа в глобальной транзакции могла быть выполнена атомарно, а вся работа в транзакции, активной в *Handle* , была отменена.|  
|40001|Сбой сериализации|Произошел откат транзакции из-за взаимоблокировки ресурсов с другой транзакцией.|  
|40002|Нарушение ограничения целостности|*Комплетионтипе* был SQL_COMMIT, а фиксация изменений привела к нарушению ограничения целостности. В результате транзакция была отменена.|  
|HY000|Общая ошибка|Произошла ошибка, для которой нет определенного SQLSTATE и для которого не определен SQLSTATE для конкретной реализации. Сообщение об ошибке, возвращаемое функцией **SQLGetDiagRec** в буфере * \*сзмессажетекст* , описывает ошибку и ее причину.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Operation canceled|Асинхронная обработка включена для *коннектионхандле*. Функция была вызвана, и до завершения выполнения [функции склканцелхандле](../../../odbc/reference/syntax/sqlcancelhandle-function.md) была вызвана для *коннектионхандле*. Затем функция была вызвана в *коннектионхандле*.<br /><br /> Функция была вызвана, и до завершения выполнения **склканцелхандле** был вызван в *коннектионхандле* из другого потока многопоточного приложения.|  
|HY010|Ошибка последовательности функций|(DM) вызывается асинхронно исполняемая функция для маркера инструкции, связанного с *коннектионхандле* и по-прежнему выполнялась при вызове **SQLEndTran** .<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *коннектионхандле* и все еще выполнялась при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**или **SQLSetPos** были вызваны для маркера инструкции, связанного с *коннектионхандле* и возвращаемого SQL_NEED_DATA. Эта функция была вызвана перед отправкой данных для всех параметров или столбцов данных, выполняемых во время выполнения.<br /><br /> (DM) вызывается асинхронно исполняемая функция (не эта одна) для *маркера* с *параметром handletype* , для которого задано значение SQL_HANDLE_DBC и все еще выполнялось при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**или **SQLMoreResults** были вызваны для одного из дескрипторов инструкций, связанных с *дескриптором* и возвращенных SQL_PARAM_DATA_AVAILABLE. Эта функция была вызвана до получения данных для всех потоковых параметров.|  
|HY012|Недопустимый код операции транзакции|(DM) значение, указанное для аргумента *Комплетионтипе* , не было ни SQL_COMMIT, ни SQL_ROLLBACK.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, так как не удалось получить доступ к базовым объектам памяти, возможно, из-за нехватки памяти.|  
|HY092|Недопустимый идентификатор атрибута или параметра|(DM) значение, указанное для аргумента *параметром handletype* , не было ни SQL_HANDLE_ENV, ни SQL_HANDLE_DBC.|  
|HY115|SQLEndTran не разрешен для среды, содержащей соединение с включенным асинхронным выполнением функций|(DM) *параметром handletype* не может иметь значение SQL_HANDLE_ENV, если для подключения в среде включено асинхронное выполнение функций подключения.|  
|HY117|Подключение приостановлено из-за неизвестного состояния транзакции. Допускаются только функции отключения и только для чтения.|(DM) Дополнительные сведения о состоянии SUSPENDED см. в разделе комментариев этой статьи.|  
|HYC00|Необязательная функция не реализована|Драйвер или источник данных не поддерживает операцию **отката** .|  
|HYT01|Время ожидания подключения истекло|Время ожидания соединения истекло до ответа источника данных на запрос. Время ожидания соединения задается через **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, связанный с *коннектионхандле* , не поддерживает функцию.|  
|IM017|Опрос отключен в режиме асинхронного уведомления|При использовании модели уведомления опрос отключен.|  
|IM018|**Склкомплетеасинк** не был вызван для завершения предыдущей асинхронной операции с этим обработчиком.|Если предыдущий вызов функции в обработчике возвращает SQL_STILL_EXECUTING и если включен режим уведомления, то для обработки после обработки и завершения операции необходимо вызвать **склкомплетеасинк** .|  
  
## <a name="comments"></a>Комментарии  
 Для ODBC 3. драйвер *x* , если *параметром handletype* имеет SQL_HANDLE_ENV и *Handle* является допустимым обработчиком среды, диспетчер драйверов будет вызывать **SQLEndTran** в каждом драйвере, связанном с данной средой. Аргументом *Handle* для вызова драйвера будет обработчик среды драйвера. Для ODBC 2. драйвер *x* , если *параметром handletype* имеет SQL_HANDLE_ENV и *Handle* является допустимым обработчиком среды, и в этой среде имеется несколько соединений в подключенном состоянии, то диспетчер драйверов будет вызывать **SQLTransact** в драйвере один раз для каждого подключения в этом окружении в подключенном состоянии. Аргументом *Handle* в каждом вызове будет маркер соединения. В любом случае драйвер попытается зафиксировать или откатить транзакции, в зависимости от значения *комплетионтипе*, для всех подключений, которые находятся в подключенном состоянии в этой среде. Неактивные соединения не влияют на транзакцию.  
  
> [!NOTE]  
>  **SQLEndTran** нельзя использовать для фиксации или отката транзакций в общей среде. Значение SQLSTATE HY092 (недопустимый идентификатор атрибута или параметра) будет возвращено, если **SQLEndTran** вызывается с параметром *Handle* или маркером общей среды или маркером подключения в общей среде.  
  
 Диспетчер драйверов возвращает SQL_SUCCESS только в том случае, если он получает SQL_SUCCESS для каждого подключения. Если диспетчер драйверов получает SQL_ERROR в одном или нескольких соединениях, он возвращает SQL_ERROR приложению, а диагностические сведения помещаются в структуру диагностических данных среды. Чтобы определить, какое соединение или соединения не удалось выполнить во время операции фиксации или отката, приложение может вызвать **SQLGetDiagRec** для каждого подключения.  
  
> [!NOTE]  
>  Диспетчер драйверов не моделирует глобальную транзакцию во всех соединениях и, следовательно, не использует протоколы двухфазной фиксации.  
  
 Если *комплетионтипе* имеет значение SQL_COMMIT, **SQLEndTran** выдает запрос на фиксацию для всех активных операций в любой инструкции, связанной с затронутым соединением. Если *комплетионтипе* имеет значение SQL_ROLLBACK, **SQLEndTran** выдает запрос Rollback для всех активных операций в любой инструкции, связанной с затронутым соединением. Если ни одна транзакция не активна, **SQLEndTran** возвращает SQL_SUCCESS без влияния на источники данных. Дополнительные сведения см. в разделе [фиксация и откат транзакций](../../../odbc/reference/develop-app/committing-and-rolling-back-transactions.md).  
  
 Если драйвер находится в режиме фиксации вручную (путем вызова **SQLSetConnectAttr** с атрибутом SQL_ATTR_AUTOCOMMIT, для которого установлено значение SQL_AUTOCOMMIT_OFF), то новая транзакция неявно запускается при выполнении инструкции SQL, которая может содержаться в транзакции, для текущего источника данных. Дополнительные сведения см. в разделе [режим фиксации](../../../odbc/reference/develop-app/commit-mode.md).  
  
 Чтобы определить, как операции транзакций влияют на курсоры, приложение вызывает **SQLGetInfo** с параметрами SQL_CURSOR_ROLLBACK_BEHAVIOR и SQL_CURSOR_COMMIT_BEHAVIOR. Дополнительные сведения см. в следующих параграфах, а также [в разделе воздействие транзакций на курсоры и подготовленные инструкции](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md).  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_DELETE, **SQLEndTran** закрывается и удаляет все открытые курсоры во всех инструкциях, связанных с соединением, и отменяет все ожидающие результаты. **SQLEndTran** оставляет любую инструкцию в выделенном (неподготовленном) состоянии; приложение может повторно использовать их для последующих запросов SQL или вызывать **SQLFreeStmt** или **SQLFreeHandle** с *параметром handletypeом* SQL_HANDLE_STMT для их освобождения.  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_CLOSE, **SQLEndTran** закрывает все открытые курсоры во всех инструкциях, связанных с соединением. **SQLEndTran** оставляет любую инструкцию в подготовленном состоянии; приложение может вызвать **SQLExecute** для инструкции, связанной с соединением, без предварительного вызова **SQLPrepare**.  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR равно SQL_CB_PRESERVE, **SQLEndTran** не влияет на открытые курсоры, связанные с соединением. Курсоры остаются в строке, на которую они указывали перед вызовом **SQLEndTran**.  
  
 Для драйверов и источников данных, которые поддерживают транзакции, вызов **SQLEndTran** с SQL_COMMIT или SQL_ROLLBACK, если ни одна транзакция не активна, возвращает SQL_SUCCESS (что означает отсутствие зафиксированных или отмененных операций) и не влияет на источник данных.  
  
 Если драйвер находится в режиме автоматической фиксации, диспетчер драйверов не вызывает **SQLEndTran** в драйвере. **SQLEndTran** всегда возвращает SQL_SUCCESS независимо от того, вызывается ли он с *комплетионтипе* SQL_COMMIT или SQL_ROLLBACK.  
  
 Драйверы или источники данных, не поддерживающие транзакции (**SQLGetInfo** *параметр* SQLGetInfo SQL_TXN_CAPABLE SQL_TC_NONE), фактически всегда находятся в режиме автоматической фиксации и, следовательно, всегда возвращают SQL_SUCCESS для **SQLEndTran** независимо от того, вызваны они с *комплетионтипе* SQL_COMMIT или SQL_ROLLBACK. Такие драйверы и источники данных фактически не выполняют откат транзакций по запросу.  
  
## <a name="suspended-state"></a>Приостановленное состояние  
 В диспетчере драйверов, выпущенных до Windows 7, транзакция была активна, если **SQLEndTran** вернул SQL_ERROR из драйвера. Однако было возможно, что транзакция была успешно зафиксирована на сервере, но драйвер на клиенте не был уведомлен (например, из-за ошибки сети). Это приведет к неправильному состоянию подключения. Начиная с Windows 7, когда **SQLEndTran** возвращает SQL_ERROR, соединение может находиться в приостановленном состоянии. В приостановленном состоянии можно вызывать функции, доступные только для чтения. В конечном итоге приложение должно вызвать **SQLDisconnect** для приостановленного подключения к ресурсам освобождения.  
  
 Если выполняются все перечисленные ниже условия, соединение будет переведено в состояние SUSPENDED:  
  
-   Драйвер возвращает SQL_ERROR из **SQLEndTran**.  
  
-   Драйвер — ODBC версии 3,8 или более поздней.  
  
-   Версия приложения — 3,8 или более поздняя; или перекомпилированное приложение ODBC 2. x или 3. x успешно отменяет функцию **SQLEndTran** через **склканцелхандле**.  
  
-   Драйвер не вернул одно из следующих сообщений, что подтверждает, что транзакция не была завершена:  
  
    -   25S03: транзакция откатывается  
  
    -   40001: сбой сериализации  
  
    -   40002: ограничение целостности  
  
    -   HYC00: необязательный компонент не реализован  
  
 Если **SQLEndTran** был вызван в обработчике среды и одно из его подключений соответствует приведенным выше условиям, все соединения, подключающиеся к одному и тому же драйверу, будут переведены в состояние SUSPENDED.  
  
 После того как приложение вызывает **SQLDisconnect** в приостановленном соединении, соединение можно использовать для повторного подключения к другому источнику данных или к тому же источнику данных.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена асинхронной функции на основе маркера соединения.|[Функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md)|  
|Возврат сведений о драйвере или источнике данных|[SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md)|  
|Освобождение маркера|[SQLFreeHandle, функция](../../../odbc/reference/syntax/sqlfreehandle-function.md)|  
|Освобождение маркера инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Асинхронное выполнение (метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md)
