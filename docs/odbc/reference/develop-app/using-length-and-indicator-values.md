---
title: Использование значений длины и индикатора | Документация Майкрософт
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- length/indicator buffers [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 849792f1-cb1e-4bc2-b568-c0aff0b66199
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 442d0865ede4819ea3413d662411295daa5b48bd
ms.sourcegitcommit: 61381ef939415fe019285def9450d7583df1fed0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2018
ms.locfileid: "47646022"
---
# <a name="using-length-and-indicator-values"></a>Использование значений длины и индикатора
Буфер длины/индикатора используется для передачи байт данных в буфере данных или специальный индикатор, например SQL_NULL_DATA, который указывает, что данные имеют значение NULL. В зависимости от функции, в котором он используется буфер длины/индикатора определяется как SQLINTEGER или SQLSMALLINT. Таким образом единственный аргумент необходим для его описания. Если буфер данных nondeferred входного буфера, этот аргумент содержит длину в байтах сами данные, либо значением индикатора. Он часто называется *StrLen_or_Ind* или таким же именем. Например, следующий код вызывает **SQLPutData** для передачи буфера full данных; байтовая длина (*ValueLen*) передается непосредственно, так как буфер данных (*ValuePtr*) — Входной буфер.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLen;  
  
// Call local function to place data in ValuePtr. In ValueLen, return the  
// number of bytes of data placed in ValuePtr. If there is not enough  
// data, this will be less than 50.  
FillBuffer(ValuePtr, sizeof(ValuePtr), &ValueLen);  
  
// Call SQLPutData to send the data to the driver.  
SQLPutData(hstmt, ValuePtr, ValueLen);  
```  
  
 Если буфер данных отложенного входного буфера, nondeferred выходного буфера или выходной буфер, аргумент содержит адрес буфера длины и индикатора. Он часто называется *StrLen_or_IndPtr* или таким же именем. Например, следующий код вызывает **SQLGetData** для извлечения данных; полный буфер байтовая длина возвращается в приложение в буфер длины/индикатора (*ValueLenOrInd*), адрес которого является передаваемый **SQLGetData** так как соответствующий буфер данных (*ValuePtr*) — это nondeferred выходной буфер.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLenOrInd;  
SQLGetData(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &ValueLenOrInd);  
```  
  
 Если он запрещен в частности, аргумент буфера длины и индикатора может быть равен 0 (если nondeferred ввода) или указатель null (если отложенного ввода). Входной буфер в результате драйвер игнорировать байтовая длина данных. Возвращает сообщение об ошибке при передаче данных переменной длины, но всего происходит, когда передача данных, отличных от null, фиксированной длины, так как требуется ни длины, ни значение индикатора. Выходной буфер в результате драйвер не будет возвращать байтовая длина данных или значение индикатора. Это ошибка, если данные, возвращаемые драйвер имеет значение NULL, но чаще при получении данных фиксированной длины, не допускающие значения NULL, так как требуется ни длины, ни значение индикатора.  
  
 Как при передаче адрес буфера данных с отложенным драйвер адрес буфера отложенного длины и индикатора должен оставаться действительным до буфера освобождается.  
  
 Следующие значения длины могут использоваться в качестве значения длины и индикатора:  
  
-   *n*, где *n* > 0.  
  
-   0.  
  
-   SQL_NTS. Строки, отправляемой в буфере данных, соответствующий драйвер заканчивается нулевым байтом; Это удобный способ для программистов C передавать строки без необходимости вычисления их длина в байтах. Это значение является допустимым только в том случае, когда приложение отправляет данные в драйвер. Когда драйвер возвращает данные в приложение, он всегда возвращает фактическое байтовая длина данных.  
  
 Следующие значения могут использоваться в качестве значения длины и индикатора. Значение SQL_NULL_DATA хранится в поле дескриптора SQL_DESC_INDICATOR_PTR; все остальные значения хранятся в поля дескриптора SQL_DESC_OCTET_LENGTH_PTR.  
  
-   ЗНАЧЕНИЕ SQL_NULL_DATA. Данные значения данных NULL и значение в соответствующий буфер данных учитывается. Это значение является допустимым только для данных SQL, отправленных или полученных из драйвера.  
  
-   ЗНАЧЕНИЕ SQL_DATA_AT_EXEC. Буфер данных не содержит все данные. Вместо этого данные будут отправлены с **SQLPutData** при выполнении инструкции или **SQLBulkOperations** или **SQLSetPos** вызывается. Это значение является допустимым только для данных SQL, отправляемых к драйверу. Дополнительные сведения см. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
-   Результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Это значение аналогично значение SQL_DATA_AT_EXEC. Дополнительные сведения см. в разделе [отправки длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
-   SQL_NO_TOTAL. Драйвер не удается определить число байтов больших объемов данных, по-прежнему доступны для возврата в выходной буфер. Это значение является допустимым только для данных SQL, полученных от драйвера.  
  
-   ЗНАЧЕНИЕ SQL_DEFAULT_PARAM. Процедура — Чтобы использовать значение по умолчанию для входного параметра в процедуре вместо значения в соответствующий буфер данных.  
  
-   SQL_COLUMN_IGNORE. **SQLBulkOperations** или **SQLSetPos** должен игнорировать значение в буфер данных. При обновлении строки данных путем вызова **SQLBulkOperations** или **SQLSetPos,** значение столбца не изменяется. При вставке новой строки данных путем вызова **SQLBulkOperations**, значение столбца имеет значение по умолчанию или, если столбец имеет значение по умолчанию, значение NULL.
